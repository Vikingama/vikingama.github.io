[{"content":"政策转向，面向 B 端的业务不得不转向 C 端；而 C 端用户显然对性能和交互更为挑剔，于是老板决定上原生。为了赶工期，采用 Native + Web 的开发方式；经过调研，Native 和 Web 之间较为常用的通信方式为 JSBridge。为此，小组还开发了一个 包 来满足业务需要。\nWebView 如果 iOS/Android 要访问 Web 页面，需要使用 WebView（一个嵌入在操作系统里的组件）； WKWebView 基于 Safari， Android System WebView 基于 Chrome，当然还有微软的 Microsoft Edge WebView2 。\n在我看来，WebView 像是一个继承自浏览器引擎的类，具有完整的浏览器功能；开发者可以在其基础上对其进行定制化来满足业务需要；比如说，可以对 UA 进行定制，这样 Web 就可以对当前的运行环境做判断：\n1 2 3 4 5 6 7 8 9 10 export const isWeChatWebView = () =\u0026gt; { /** * 如果 UA 不满足条件，可以拒绝服务 * 比如“请在微信中访问” */ if (/(WeChat)/i.test(navigator.userAgent)) { return true; } return false; }; 以 WKWebView 为例， WKWebViewConfiguration 用来配置 WKWebView， URLRequest 用来指定访问的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ViewController: UIViewController, WKUIDelegate { var webView: WKWebView! // 加载 WKWebView override func loadView() { // 使用 WKWebViewConfiguration 对 WKWebView 进行配置 let webConfiguration = WKWebViewConfiguration() webView = WKWebView(frame: .zero, configuration: webConfiguration) webView.uiDelegate = self view = webView } override func viewDidLoad() { // 调用父级 viewDidLoad super.viewDidLoad() // 指定访问的 URL let myURL = URL(string: \u0026#34;https://www.apple.com\u0026#34;) let myRequest = URLRequest(url: myURL!) // 加载 URL webView.load(myRequest) } } JSBridge 因为 Native 和 Web 处于两个不同的运行环境中，为了进行通信，需要一个桥的东西来连接 Native 和 Web，这个桥就是 JSBridge。对于 Native 和 Web 这两个角色，Native 拥有更大的权限，它可以通过初始化一个 WebView 打开页面，也可以直接销毁 WebView 实例关闭页面；既然 Native 对 WebView 可以有完全的控制，那么 Native 就可以通过更改 WebView 实例中的 JS 运行时来间接的影响 Web 的行为，比如：\n在 window 上添加双方约定好的属性，比如 window.attr4Shared： Android 可以通过 evaluateJavascript 调用 Web 逻辑； iOS 可以通过 evaluateJavaScript:javaScriptString 调用 Web 逻辑； Web 可以调用 Android 通过 addJavascriptInterface 注入的全局属性/方法； Web 可以调用 iOS 通过 WKScriptMessageHandler 注入的全局属性/方法。 拦截 Web 对外部资源的访问，比如链接跳转、 URLScheme ； Android 可以通过 shouldOverrideUrlLoading 拦截 Web 对 URL 访问，实现 Web 对 Android 逻辑的调用； iOS 可以通过 WKNavigationDelegate 拦截 Web 对 URL 访问，实现 Web 对 iOS 逻辑的调用。 拦截全局方法的默认行为，比如 window.prompt： Android 可以通过 WebChromeClient 拦截 Web API 默认行为，实现 Web 对 Android 逻辑的调用； iOS 可以通过 WKUIDelegate 拦截 Web API 默认行为，实现 Web 对 iOS 逻辑的调用。 Android 使用 shouldOverrideUrlLoading 拦截对 URL 的访问（Web 调用 Native） 1 2 3 4 5 6 7 8 9 10 11 12 // 无法在短时间内回调多次 ​shouldOverrideUrlLoading​ 方法，也就是说频繁交互的情况下，会有较大概率只回调一次该方法 public class CustomWebViewClient extends WebViewClient { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { if (url.equals(\u0026#34;xxx\u0026#34;)) { // 执行 Web 逻辑 view.loadUrl(\u0026#34;javascript:setAllContent(\u0026#34; + json + \u0026#34;);\u0026#34;) return true; } return super.shouldOverrideUrlLoading(view, url); } } Android 使用 addJavascriptInterface 向 Web 注入内容（Web 调用 Native） 1 2 3 4 5 6 7 8 9 // 该方法是阻塞的，会等待 ​Native​ 方法的返回，​Native​ 会在一个后台线程中执行该方法调用 class Bridge { @JavascriptInterface fun send(msg: String) { doSomething() } } // Web 加载完毕后，window 对象上会多出一个 _sBridge 属性 webview.addJavascriptinterface(Bridge(), \u0026#34;_sBridge\u0026#34;) Android 使用 WebChromeClient 拦截 Web API（Web 调用 Native） 1 2 3 4 5 6 7 public class JSBridgeWebChromeClient extends WebChromeClient { @Override public boolean onJsPrompt(WebView view, String url, Stringt message, String defaultValue, JsPromptResult result) { // 处理具体逻辑 return true; } } Android 使用 evaluateJavascript 调用 Web（Native 调用 Web） 1 2 3 4 5 6 7 8 private void testEvaluateJavascript(WebView webView) { webView.evaluateJavascript(\u0026#34;window.getGreetings()\u0026#34;, new ValueCallback \u0026lt;String\u0026gt; () { @Override public void onReceiveValue(String value) { // 处理结果 } }); } iOS 使用 WKNavigationDelegate 拦截对 URL 的访问（Web 调用 Native） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 func webView( _ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -\u0026gt; Void ) { if navigationAction.request.url?.scheme == \u0026#34;haleyaction\u0026#34; { let url = navigationAction.request.url handleCustomAction(url: url!) // 取消加载 decisionHandler(WKNavigationActionPolicy.cancel) return } // 允许加载 decisionHandler(WKNavigationActionPolicy.allow) } func handleCustomAction(url: URL) { let host = url.host! switch host { case \u0026#34;scanClick\u0026#34;: print(\u0026#34;saoyisao\u0026#34;) case \u0026#34;shareClick\u0026#34;: share(url: url) case \u0026#34;getLocation\u0026#34;: getLocation() case \u0026#34;setColor\u0026#34;: changeBackGroundColor(url: url) case \u0026#34;payAction\u0026#34;: payAction(url: url) case \u0026#34;shake\u0026#34;: sharkeAction() case \u0026#34;back\u0026#34;: goBack() default: break } } iOS 使用 WKScriptMessageHandler 向 Web 注入内容（Web 调用 Native） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let wkConfig = WKWebViewConfiguration() let wkUserContentController = WKUserContentController() /** * Web 加载完毕后，window.webkit.messageHandlers 对象上会多出一个 getUserInfo 属性 * 可以通过调用 getUserInfo.postMessage 完成对 Native 的通信 */ wkUserContentController.add( self as WKScriptMessageHandler, name: \u0026#34;getUserInfo\u0026#34; ) wkConfig.userContentController = wkUserContentController /** * https://developer.apple.com/documentation/webkit/wkscriptmessagehandler/1396222-usercontentcontroller * 重写 WKScriptMessageHandler 中的 userContentController */ extension WKWebViewWithMessageHandler: WKScriptMessageHandler { func userContentController( _ userContentController: WKUserContentController, didReceive message: WKScriptMessage ) { let msg = message.body as! String let ac = UIAlertController(title: msg, message: msg, preferredStyle: .alert) ac.addAction(UIAlertAction(title: \u0026#34;Ok\u0026#34;, style: .default)) self.present(ac, animated: true) } } iOS 使用 WKUIDelegate 拦截 Web API（Web 调用 Native） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 extension ViewController: WKUIDelegate { // 获取 window.alert 内容 func webView( _ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -\u0026gt; Void ) { // 逻辑处理 } } extension ViewController: WKUIDelegate { // 获取 window.confirm 内容 func webView( _ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -\u0026gt; Void ) { // 逻辑处理 } } extension ViewController: WKUIDelegate { // 获取 window.prompt 内容 func webView( _ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -\u0026gt; Void ) { // 逻辑处理 } } iOS 使用 evaluateJavaScript 调用 Web（Native 调用 Web） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // evaluateJavaScript extension NativeInvokeJavaScriptBrowserViewController: WKNavigationDelegate { func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { switch requestJavaScriptMethod! { case \u0026#34;Switch2Font\u0026#34;: wkWebView.evaluateJavaScript(\u0026#34;window.nativeRegister.onSwitch2Font(\u0026#39;true\u0026#39;)\u0026#34;) case \u0026#34;Switch2Back\u0026#34;: wkWebView.evaluateJavaScript(\u0026#34;window.nativeRegister.onSwitch2Font(\u0026#39;false\u0026#39;)\u0026#34;) default: wkWebView.evaluateJavaScript(\u0026#34;window.nativeRegister.sayHello()\u0026#34;) } } } 具体实现 首先，需要定义一个全局对象，用来保存 JSBridge 相关的属性/方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export const isAndroid = () =\u0026gt; { if (/Android/i.test(navigator.userAgent)) { return true; } return false; }; export const isIOS = () =\u0026gt; { if (/(iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent)) { return true; } return false; }; export const isXLMWebView = () =\u0026gt; { if (/(XiaoLanMa)/i.test(navigator.userAgent)) { return true; } return false; }; window.XiaoLanMaBridge = { isAndroid, isIOS, isXLMWebView }; isAndroid ｜ isIOS ｜ isXLMWebView 这三个属性是用来给 Web 判断运行环境的，如果运行环境不满足需要，可以拒绝服务。\n然后，和 Native 明确 Web 需要调用的方法；Native 创建 WebView 时，向 WebView 的上下文注入一些方法，方便 Web 调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 interface UploadParams { chooseType: \u0026#39;Camera\u0026#39; | \u0026#39;PhotoAlbum\u0026#39; | \u0026#39;File\u0026#39;; // 拍照 ｜相册｜文件 isPrivate: boolean; // 是否开启“私有化”上传 maxNumber: number; // 最大文件个数 mimeTypes: Array\u0026lt;\u0026#39;image/jpeg\u0026#39; | \u0026#39;image/png\u0026#39; | \u0026#39;application/pdf\u0026#39;\u0026gt;; // 支持的文件类型 } // 这些都是和 APP 开发人员约定好的 export const nativeEventMapForWeb = { // 文件上传 fileUpload(params: UploadParams, callbackName) { if (isAndroid) { // Android 在全局暴露的方法 window.XiaoLanMaBridgeFromNative.fileUpload( JSON.stringify(params), callbackName ); } if (isIOS) { // iOS 在全局暴露的方法 window.webkit.messageHandlers.fileUpload.postMessage( JSON.stringify({ callbackName, data: params }) ); } }, // 获取用户信息 getUserInfo(params, callbackName) { if (isAndroid) { window.XiaoLanMaBridgeFromNative.getUserInfo( JSON.stringify(params), callbackName ); } if (isIOS) { window.webkit.messageHandlers.getUserInfo.postMessage( JSON.stringify({ callbackName, data: params }) ); } }, // 关闭 WebView closeWebView(params) { if (isAndroid) { window.XiaoLanMaBridgeFromNative.closeWebView(JSON.stringify(params)); } if (isIOS) { window.webkit.messageHandlers.closeWebView.postMessage( JSON.stringify({ data: params }) ); } } }; 接着，还需要一个对象来保存不同 EventName 对应的回调函数：\n1 2 3 window.XiaoLanMaBridge = { callNativeCallback: {} // 用来保存 callNative 对应的回调函数 }; 这样，当 Native 部分的逻辑执行完毕后，就可以通过调用我们事先约定好的全局函数将执行结果告诉 Web 端。\n最后，我们需要实现一个Web 调用 Native 功能的方法 callNative，用来注册 EventName 对应的回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 window.XiaoLanMaBridge = { callNative(nativeEventName, paramsToNative, callback, needLoop) { if (!isXLMWebView) { throw new Error(\u0026#39;请在 xxx 中运行\u0026#39;); } const callbackName = `${nativeEventName}Callback`; if (needLoop) { // 需要轮询调用 callback，比如查看“上传进度” if (callback) { // 保存 nativeEventName 对应的回调函数 this.callNativeCallback[callbackName] = responseFromNative =\u0026gt; { // Native 回传的结果一般为字符串 const { success, data, error, isFinished } = JSON.parse(responseFromNative); if (success) { callback({ data, isFinished }); } else { callback({ error, isFinished: true }); } // 如果轮询结束，记得清理回调函数 if (isFinished) { delete this.callNativeCallback[callbackName]; } }; // 调用 Native 逻辑，Native 处理完毕之后，会去调用我们的 callback nativeEventMapForWeb[nativeEventName](paramsToNative, callbackName); } } else { // 不需要轮询调用 callback，所以 reslove 就是此时的 callback return new Promise((resolve, reject) =\u0026gt; { this.callNativeCallback[callbackName] = responseFromNative =\u0026gt; { // 返回值需要和 Native 提前定义好 const { success, data, error } = JSON.parse(responseFromNative); if (success) { resolve(data); // 返回结果 } else { reject(error); // 抛出错误 } delete this.callNativeCallback[callbackName]; // 记得清理回调函数 }; nativeEventMapForWeb[nativeEventName](paramsToNative, callbackName); }); } } }; 以上就是 Web 主动调用 Native 方法的大致逻辑了；那么 Web 怎么订阅 Native 事件呢？比如 APP 从后台切换到前台、系统切换 Dark 模式等。\n这种场景也需要和 Native 开发人员确定订阅场景；当场景被触发时，Native 需要主动调用 nativeRegister 中的方法来通知 Web：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.XiaoLanMaBridge = { // 这里需要预先声明好所有的回调场景 nativeRegister: { onSwitch2Font() { // 可以看出，运行之前，需要先向 nativeRegisterCallback 添加 onSwitch2FontCallback 回调 window.XiaoLanMaBridge.nativeRegisterCallback.onSwitch2FontCallback({ success: true }); }, onTheme2Light() { window.XiaoLanMaBridge.nativeRegisterCallback.onTheme2LightCallback({ success: true }); }, onTheme2Dark() { window.XiaoLanMaBridge.nativeRegisterCallback.onTheme2DarkCallback({ success: true }); } }, // 保存 nativeRegister 回调 nativeRegisterCallback: {} }; 接着，也需要在 window.XiaoLanMaBridge 定义一个 addNativeEventListener 方法，用来将对应的回调函数保存至 nativeRegisterCallback 中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 window.XiaoLanMaBridge = { addNativeEventListener(nativeEventName, callback) { if (!isXLMWebView) { throw new Error(\u0026#39;请在 xxx 中运行\u0026#39;); } if (this.nativeRegister[nativeEventName]) { this.nativeRegisterCallback[`${nativeEventName}CallBack`] = ({ success }) =\u0026gt; { callback(success); }; } else { throw new Error(`${webEventName} 事件不存在`); } } }; 其实这种事件订阅的场景就是上一个调用 Native 方法的简化版；区别是 nativeRegister 中的方法需要 Native 主动去调用。\n具体应用 当需要通过 Native 选择并上传文件时，可以调用 upload 来实现；因为 Web 需要回显上传进度，需要轮询调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.XiaoLanMaBridge.callNative( \u0026#39;upload\u0026#39;, { chooseType: \u0026#39;File\u0026#39;, isPrivate: true, maxNumber: 1, mimeTypes: [\u0026#39;application/pdf\u0026#39;] }, ({ data, error, isFinished }) =\u0026gt; { if (error) { // 上传出错 Toast.error(error); } else { if (isFinished) { console.log(data); Toast.success(\u0026#39;上传成功\u0026#39;); } else { Toast.loading(`已上传 ${data.percent}%，请稍后`); } } }, true ); 当需要通过 Native 获取用户信息时，可以调用 getUserInfo 通知 APP 请求接口获取最新的用户信息并返回：\n1 2 3 4 5 6 7 8 (async () =\u0026gt; { try { const userInfo = await window.XiaoLanMaBridge.callNative(\u0026#39;getUserInfo\u0026#39;); console.log(\u0026#39;userInfo\u0026#39;, userInfo); } catch (error) { Toast.error(error); } })(); 当 APP 从后台切回前台时，想要刷新数据，可以通过订阅事件来解决：\n1 2 3 4 5 window.XiaoLanMaBridge.addNativeEventListener(\u0026#39;onSwitch2Font\u0026#39;, isSuccess =\u0026gt; { if (isSuccess) { this.getData(); } }); 参考 iOS 与 JavaScript 的交互（三）WKWebView Android JSBridge 原理与实现 ","date":"2023-06-05T00:00:00Z","image":"https://vikingama.github.io/img/cover/jsbridge.png","permalink":"https://vikingama.github.io/p/jsbridge-%E5%88%9D%E4%B8%8A%E6%89%8B/","title":"JSBridge 初上手"},{"content":"事例代码 新建 tracing.ts：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 import { ZoneContextManager } from \u0026#39;@opentelemetry/context-zone\u0026#39;; import { OTLPTraceExporter } from \u0026#39;@opentelemetry/exporter-trace-otlp-http\u0026#39;; import { registerInstrumentations } from \u0026#39;@opentelemetry/instrumentation\u0026#39;; import { DocumentLoadInstrumentation } from \u0026#39;@opentelemetry/instrumentation-document-load\u0026#39;; import { FetchInstrumentation } from \u0026#39;@opentelemetry/instrumentation-fetch\u0026#39;; import { UserInteractionInstrumentation } from \u0026#39;@opentelemetry/instrumentation-user-interaction\u0026#39;; import { XMLHttpRequestInstrumentation } from \u0026#39;@opentelemetry/instrumentation-xml-http-request\u0026#39;; import { Resource } from \u0026#39;@opentelemetry/resources\u0026#39;; import { BatchSpanProcessor } from \u0026#39;@opentelemetry/sdk-trace-base\u0026#39;; import { WebTracerProvider } from \u0026#39;@opentelemetry/sdk-trace-web\u0026#39;; import { SemanticResourceAttributes } from \u0026#39;@opentelemetry/semantic-conventions\u0026#39;; import { environment } from \u0026#39;src/environments/environment\u0026#39;; // Init const resource = Resource.default().merge( new Resource({ // 通过 environment.name 变量来区分不同环境的应用 [SemanticResourceAttributes.SERVICE_NAME]: `${environment.name}` }) ); // Tracing const provider = new WebTracerProvider({ resource }); if (!environment.production) { // 开发环境使用 ConsoleSpanExporter，便于调试 const consoleExporter = new ConsoleSpanExporter(); const consoleProcessor = new SimpleSpanProcessor(consoleExporter); provider.addSpanProcessor(consoleProcessor); } else { // 生产环境使用 OTLPTraceExporter const traceUrl = \u0026#39;https://otelcol.xxx.com/v1/traces\u0026#39;; const traceExporter = new OTLPTraceExporter({ url: traceUrl, headers: {} // 使用 xhr 而不是 navigator.sendBeacon }); const traceProcessor = new BatchSpanProcessor(traceExporter, { maxExportBatchSize: 10, maxQueueSize: 100 }); provider.addSpanProcessor(traceProcessor); } provider.register({ contextManager: new ZoneContextManager() }); // Register const propagateTraceHeaderCorsUrls = /.+/g; // 哪些跨域接口添加“追踪请求头” const ignoreUrls = [ /** * 哪些接口不添加“追踪请求头”： * 1.本地 DevServer/HMR 接口 * 2.第三方 SDK 调用的接口 * 3.加载静态资源的接口 */ /^(https:\\/\\/static-offline-objects.xxx.com|https:\\/\\/static-objects.xxx.com|https:\\/\\/qiniu.xxx.com|https:\\/\\/oss.xxx.com)/g, /^(https:\\/\\/eos-scp-int.sit.xxx-express.com)/g, /^(https:\\/\\/eos-scp.sit.xxx-express.com)/g, /^(https:\\/\\/eos-scp-int.xxx-express.com)/g, /^(https:\\/\\/eos-scp.xxx-express.com)/g, /^(https:\\/\\/s9.cnzz.com\\/z_stat.php)/g, /^(http:\\/\\/localhost)/g, /^(http:\\/\\/192.168)/g, /^(http:\\/\\/0.0.0.0)/g ]; registerInstrumentations({ instrumentations: [ // 处理页面加载 new DocumentLoadInstrumentation(), // 处理用户交互 new UserInteractionInstrumentation(), // 处理 Fetch new FetchInstrumentation({ clearTimingResources: true, propagateTraceHeaderCorsUrls, ignoreUrls }), // 处理 XHR new XMLHttpRequestInstrumentation({ clearTimingResources: true, propagateTraceHeaderCorsUrls, ignoreUrls }) ], tracerProvider: provider }); 在应用入口（以 Angular 为例，如遇接口报错，尝试更新 NgZone 版本）引入 tracing.ts：\n1 2 3 4 5 6 7 8 9 10 11 import { enableProdMode } from \u0026#39;@angular/core\u0026#39;; import { platformBrowserDynamic } from \u0026#39;@angular/platform-browser-dynamic\u0026#39;; import { AppModule } from \u0026#39;./app/app.module\u0026#39;; import { environment } from \u0026#39;./environments/environment\u0026#39;; import \u0026#39;./tracing\u0026#39;; if (environment.production) { enableProdMode(); } platformBrowserDynamic() .bootstrapModule(AppModule) .catch(err =\u0026gt; console.error(err)); 数据传递流程 每次从前端发起请求时，OTLP 会在请求头中注入 traceparent/X-B3 字段（取决于使用的是 W3C 规范 还是 B3 规范 ），用来将前后端链路信息关联起来；同时，客户端会将收集到的链路数据通过 OTLPTraceExporter 提交给追踪服务器；服务端会将收集到的链路数据通过 Java Agent 提交给追踪服务器。\n参考 到底什么是 RUM？生产环境如何选择靠谱的前端监控系统 What Can OpenTelemetry Do for Frontend Developers? Adding OpenTelemetry to An Angular Application OpenTelemetry Documentation OpenTelemetry 规范阅读 ","date":"2023-02-06T00:00:00Z","image":"https://vikingama.github.io/img/cover/opentelemetry.png","permalink":"https://vikingama.github.io/p/%E5%89%8D%E7%AB%AF-spa-%E5%BA%94%E7%94%A8%E9%80%9A%E8%BF%87-opentelemetry-%E6%8E%A5%E5%85%A5%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/","title":"前端 SPA 应用通过 OpenTelemetry 接入“链路追踪”"},{"content":"ngTemplateOutlet 从字面来看，就像 \u0026lt;router-outlet/\u0026gt; 之于 router 一样，ngTemplateOutlet 就是 TemplateRef 的“出口”。除了渲染 TemplateRef 之外，它还支持指定一个对象 context 作为“模版内容”的渲染上下文。\nVue 的 scopedSlots 和 React 的 renderProps 以及后来的 Composition API 和 Hooks 都在践行“逻辑与 UI”的分离；因为 UI 的自由度非常高，形态千变万化，而交互逻辑的自由度就小不少，UI 更多是内在逻辑的延伸。有了 ngTemplateOutlet，也可以在 Angular 中分离逻辑与 UI（虽然 Angular 在这方面的最佳实践是“依赖注入 Service”）。\n使用 ngTemplateOutlet 构造 DynamicTabListSlotComponent：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 组件渲染了一个 ng-container，这就是 TemplateRef 的出口 @Component({ selector: \u0026#39;dynamic-tab-list-slot\u0026#39;, template: ` \u0026lt;ng-container *ngTemplateOutlet=\u0026#34;tabListTemplate; context: temp\u0026#34; \u0026gt;\u0026lt;/ng-container\u0026gt; `, /** * ngTemplateOutlet * 可以拆成 * [ngTemplateOutlet]、[ngTemplateOutletContext] * 两个属性 */ template: ` \u0026lt;ng-container [ngTemplateOutlet]=\u0026#34;tabListTemplate\u0026#34; [ngTemplateOutletContext]=\u0026#34;temp\u0026#34; \u0026gt;\u0026lt;/ng-container\u0026gt; ` }) export class DynamicTabListSlotComponent implements OnChanges { // 传入的请求参数 @Input() orgId?: number = null; // 传入的函数，用来格式化接口返回的数据 @Input() formatter = v =\u0026gt; v; // 传入的 tabListTemplate 所指向的 TemplateRef @Input() tabListTemplate: TemplateRef\u0026lt;any\u0026gt;; // 接口返回新的数据之后，通过自定义事件抛出 @Output() updated = new EventEmitter(); /** * TemplateRef 渲染的上下文，其中包含了： * 1. 数据集合 * 2. 请求状态 */ temp = { loading: false, tabList: [] }; // 依赖注入 ApiService constructor(private apiService: ApiService) {} // 如果传入的“请求参数”变化，重新请求接口 ngOnChanges(changes: SimpleChanges): void { if (changes?.orgId) { this.getTabList(); } } // 副作用函数 getTabList() { const park = []; if (typeof this.orgId !== \u0026#39;number\u0026#39;) { this.temp.tabList = park.map(this.formatter); this.updated.emit({ origin: park, formatted: this.temp.tabList }); return; } // 可以直接修改“上下文”中的数据 this.temp.loading = true; this.apiService .dynamicTabInDailyReconciliation({ orgId: this.orgId }) .subscribe(response =\u0026gt; { if (response.success) { // 请求成功，更新“上下文” this.temp.tabList = [...response.data].map(this.formatter); // 通过自定义事件抛出数据 this.updated.emit({ origin: [...response.data], formatted: this.temp.tabList }); } else { // 请求失败 this.temp.tabList = park.map(this.formatter); this.updated.emit({ origin: park, formatted: this.temp.tabList }); } // 更新“请求状态” this.temp.loading = false; }); } } 使用 DynamicTabListSlotComponent：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;!-- 当 currentOrgId 发生变化 会重新发起请求，拉取最新数据 更新“上下文”，触发 updated --\u0026gt; \u0026lt;app-dynamic-tab-list-slot (updated)=\u0026#34;handleTabListUpdate($event)\u0026#34; [tabListTemplate]=\u0026#34;tabListTemplate\u0026#34; [formatter]=\u0026#34;tabListFormatter\u0026#34; [orgId]=\u0026#34;currentOrgId\u0026#34; \u0026gt; \u0026lt;!-- tabListTemplate 指向的 ng-template 包含了“渲染模版” 使用 let-* 语法，解构“上下文”中的属性值 tabListLoading -\u0026gt; context.loading tabList -\u0026gt; context.tabList --\u0026gt; \u0026lt;ng-template #tabListTemplate let-tabList=\u0026#34;tabList\u0026#34; let-tabListLoading=\u0026#34;loading\u0026#34; \u0026gt; \u0026lt;!-- 这里不仅可以是 nz-tabset，也可以是 nz-checkbox、nz-radio、nz-select ... --\u0026gt; \u0026lt;nz-tabset nzSize=\u0026#34;small\u0026#34; nzTabPosition=\u0026#34;top\u0026#34; [nzTabBarGutter]=\u0026#34;4\u0026#34; [nzTabBarExtraContent]=\u0026#34;extraTemplate\u0026#34; [(nzSelectedIndex)]=\u0026#34;currentSelectedIndex\u0026#34; (nzSelectedIndexChange)=\u0026#34;handleSelectedIndexChange($event)\u0026#34; \u0026gt; \u0026lt;nz-tab nzTitle=\u0026#34;代征\u0026#34; *ngIf=\u0026#34;tabList.includes(Service.dz)\u0026#34;\u0026gt; \u0026lt;ng-template nz-tab\u0026gt; \u0026lt;app-reconciliation [orgId]=\u0026#34;currentOrgId\u0026#34; [platform]=\u0026#34;Service.dz\u0026#34; [selectedIndex]=\u0026#34;currentSelectedIndex\u0026#34; \u0026gt;\u0026lt;/app-reconciliation\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/nz-tab\u0026gt; \u0026lt;nz-tab nzTitle=\u0026#34;轻税\u0026#34; *ngIf=\u0026#34;tabList.includes(Service.qs)\u0026#34;\u0026gt; \u0026lt;ng-template nz-tab\u0026gt; \u0026lt;app-reconciliation [orgId]=\u0026#34;currentOrgId\u0026#34; [platform]=\u0026#34;Service.qs\u0026#34; [selectedIndex]=\u0026#34;currentSelectedIndex\u0026#34; \u0026gt;\u0026lt;/app-reconciliation\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/nz-tab\u0026gt; ... \u0026lt;/nz-tabset\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/app-dynamic-tab-list-slot\u0026gt; createEmbeddedView 可以替代 ngTemplateOutlet 指令；同时，如果“逻辑组件”仅有一个 ngTemplateOutlet（仅渲染一个 TemplateRef），可以使用 ContentChild 获取 TemplateRef：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 @Component({ selector: \u0026#39;app-codes\u0026#39;, template: ` \u0026lt;ng-container #vcf\u0026gt;\u0026lt;/ng-container\u0026gt; ` }) export class CodesComponent implements OnInit, AfterViewInit { // 这里不再使用 @Input，而是直接通过 ContentChild 获取 TemplateRef @ContentChild(TemplateRef) content: TemplateRef\u0026lt;any\u0026gt;; // 这里必须使用 { read: ViewContainerRef } 明确 ViewChild 的类型 @ViewChild(\u0026#39;vcf\u0026#39;, { read: ViewContainerRef }) vcf; @Output() update = new EventEmitter\u0026lt;string[]\u0026gt;(); @Input() codes: Array\u0026lt;string\u0026gt;; @Input() type: string; list: CodeItem[] = [ { name: \u0026#39;云票\u0026#39;, code: \u0026#39;yp\u0026#39;, children: [...adminMenus()] }, { name: \u0026#39;账套管理\u0026#39;, code: \u0026#39;zt\u0026#39;, children: [...adminBatchMenus()] }, { name: \u0026#39;记账中心\u0026#39;, code: \u0026#39;jz\u0026#39;, children: [...adminNoteMenus()] } ]; constructor(private cdf: ChangeDetectorRef) {} ngOnInit(): void { // 使用传来的 codes 对数据进行初始化 let temp = [...this.list]; temp = this.handleInitWithFilter(temp as CodeItem[]); temp = this.handleInitWithCodes(temp as CodeItem[]); temp[0].active = true; this.list = [...temp]; } ngAfterViewInit() { /** * this.vcf 初始化完成后，在 this.vcf 中渲染 this.content * createEmbeddedView 的第二个参数为“渲染上下文” * 这里将数据 list 绑定到“缺省”属性 $implicit 上 * 同时将“用户操作”封装在 handleChecked 中 */ this?.vcf?.createEmbeddedView(this.content, { handleChecked: (v, o) =\u0026gt; this.handleChecked(o), $implicit: this.list }); this.cdf.detectChanges(); } // 下面这些繁琐复杂的逻辑被封装在组件内部，对外只暴露了“渲染上下文”中的两个属性 handleInitWithFilter(arr) { return [...arr].filter(item =\u0026gt; { if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { item.children = this.handleInitWithFilter(item.children); } return !item?.hiddenForSetting; }); } handleInitWithCodes(arr) { return [...arr].map(item =\u0026gt; { let checked = false; if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { item.children = this.handleInitWithCodes(item.children); const { length: l1 } = item.children; const { length: l2 } = item.children.filter(({ checked }) =\u0026gt; checked); checked = l1 === l2; } else { checked = this?.codes?.includes(item.code) ? true : false; } return { ...item, active: false, checked }; }); } handleGenCodes(arr, temp) { arr.forEach(item =\u0026gt; { if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { this.handleGenCodes(item.children, temp); } else { if (item.checked) { temp.push(item.code); } } }); } handleChecked({ code }) { let temp = []; this.list = [...this.list].map(item =\u0026gt; this.handleItem(code, item)); this.handleGenCodes(this.list, temp); this.update.emit(temp); } handleItem(code, item) { if (item.code === code) { item.checked = !item.checked; if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { item.children = item.children.map(child =\u0026gt; this.handleAll(child, item.checked) ); } } if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { item.children = item.children.map(child =\u0026gt; this.handleItem(code, child)); item.checked = item.children.every(child =\u0026gt; child.checked); } return item; } handleAll(item, checked) { item.checked = checked; if (Array.isArray(item?.children) \u0026amp;\u0026amp; item?.children?.length \u0026gt; 0) { item.children = item.children.map(child =\u0026gt; this.handleAll(child, checked) ); } return item; } } 从 context 中取出 list 和 handleChecked 即可完成 UI 的渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;app-codes [type]=\u0026#34;type\u0026#34; [codes]=\u0026#34;role.codes\u0026#34; (update)=\u0026#34;handleUpdate($event)\u0026#34;\u0026gt; \u0026lt;!-- UI 包含在 ng-template 中，背后的逻辑封装在 CodesComponent 中 CodesComponent 内部 ContentChild 的存在使得不再需要“模版变量” CodesComponent 通过 ContentChild 来获取 ng-template 的引用 同时，通过 let-* 语法，解构出 context 中的属性 --\u0026gt; \u0026lt;ng-template let-list let-handleChecked=\u0026#34;handleChecked\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;nz-collapse [nzAccordion]=\u0026#34;true\u0026#34; [nzBordered]=\u0026#34;false\u0026#34; [nzGhost]=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;nz-collapse-panel *ngFor=\u0026#34;let f1 of list\u0026#34; [nzHeader]=\u0026#34;collapsePanelHeader\u0026#34; [(nzActive)]=\u0026#34;f1.active\u0026#34; [nzShowArrow]=\u0026#34;false\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;collapse-panel-content\u0026#34;\u0026gt; \u0026lt;div nz-row *ngFor=\u0026#34;let f2 of f1.children\u0026#34;\u0026gt; \u0026lt;div nz-col nzSpan=\u0026#34;6\u0026#34; class=\u0026#34;left-cell label-cell\u0026#34;\u0026gt; \u0026lt;label nz-checkbox [ngModel]=\u0026#34;f2.checked\u0026#34; [ngModelOptions]=\u0026#34;{ standalone: true }\u0026#34; (ngModelChange)=\u0026#34;handleChecked($event, f2)\u0026#34; \u0026gt; {{ f2.name }} \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div nz-col nzSpan=\u0026#34;18\u0026#34; class=\u0026#34;right-cell label-cell\u0026#34;\u0026gt; \u0026lt;label *ngFor=\u0026#34;let f3 of f2.children\u0026#34; nz-checkbox [ngModel]=\u0026#34;f3.checked\u0026#34; [ngModelOptions]=\u0026#34;{ standalone: true }\u0026#34; (ngModelChange)=\u0026#34;handleChecked($event, f3)\u0026#34; \u0026gt; {{ f3.name }} \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ng-template #collapsePanelHeader\u0026gt; \u0026lt;div nz-row class=\u0026#34;collapse-panel-header\u0026#34; nzAlign=\u0026#34;middle\u0026#34;\u0026gt; \u0026lt;div nz-col [nzSpan]=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;label nz-checkbox [ngModel]=\u0026#34;f1.checked\u0026#34; [ngModelOptions]=\u0026#34;{ standalone: true }\u0026#34; (ngModelChange)=\u0026#34;handleChecked($event, f1)\u0026#34; \u0026gt; {{ f1.name }} \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div nz-col [nzSpan]=\u0026#34;12\u0026#34;\u0026gt; \u0026lt;div nz-row nzJustify=\u0026#34;end\u0026#34;\u0026gt; \u0026lt;a nz-button nzType=\u0026#34;link\u0026#34; *ngIf=\u0026#34;f1.active\u0026#34;\u0026gt; 收起 \u0026lt;i nz-icon nzType=\u0026#34;up\u0026#34; nzTheme=\u0026#34;outline\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;a nz-button nzType=\u0026#34;link\u0026#34; *ngIf=\u0026#34;!f1.active\u0026#34;\u0026gt; 展开 \u0026lt;i nz-icon nzType=\u0026#34;down\u0026#34; nzTheme=\u0026#34;outline\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/nz-collapse-panel\u0026gt; \u0026lt;/nz-collapse\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/app-codes\u0026gt; ngComponentOutlet 组件类装饰器中有一个可选的属性 selector，selector 决定了组件的实例化位置；当组件装饰器中缺少 selector 属性（或者 selector 属性值为空）时，Ng 会为其生成一个 \u0026lt;ng-component/\u0026gt; 标签。\n没有 selector 属性的组件可以通过以下两种方式渲染到页面中：\nngComponentOutlet； router-outlet。 \u0026lt;router-outlet/\u0026gt; 不用多说了；和 ngTemplateOutlet 一样，ngComponentOutlet 也是通过 ng-container 渲染组件的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component({ selector: \u0026#39;app-ng-component-outlet-example\u0026#39;, template: ` \u0026lt;ng-container *ngComponentOutlet=\u0026#34;component\u0026#34;\u0026gt;\u0026lt;/ng-container\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; (click)=\u0026#34;handleComponentSwitch()\u0026#34;\u0026gt;switch\u0026lt;/button\u0026gt; ` }) export class NgComponentOutletExampleComponent { component: any = AComponent; handleComponentSwitch() { if (this.component.name === \u0026#39;A\u0026#39;) { this.component = BComponent; } else { this.component = AComponent; } } } formControlName 在自定义元素上使用 formControlName：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 /** * 首先，需要明确一点 * 无论是“模版驱动表单（ngModel）” * 还是“响应式表单（formControlName）” * 内部实现都是 FormControl * NgModel 内部继承了 FormControl */ type OnChangeType = (value: any) =\u0026gt; void; type OnTouchedType = () =\u0026gt; any; @Component({ selector: \u0026#39;app-administrative-division\u0026#39;, providers: [ /** * 这里没有使用 forwardRef 的必要 * forwardRef 的作用是“返回对‘值’的引用” * 因为，“类修饰符”是在“类被定义”之后才生效的 * 所以，无需使用 forwardRef 将“类的引用”捕获在闭包里 */ { // useExisting: forwardRef(() =\u0026gt; AdministrativeDivisionComponent), useExisting: AdministrativeDivisionComponent, provide: NG_VALUE_ACCESSOR, multi: true } ] }) export class AdministrativeDivisionComponent implements OnInit, ControlValueAccessor { /** * ControlValueAccessor 在“Form API”和“DOM”之间扮演者桥梁的角色 * 组件通过将自身注册为 NG_VALUE_ACCESSOR * 并且 implements ControlValueAccessor * 任何自定义组件都能和“Form API”进行沟通 * 原生表单元素能和“Form API”沟通的原因是 * Angular 内部已经帮助实现了一部分“指令”： * SelectMultipleControlValueAccessor * CheckboxControlValueAccessor * SelectControlValueAccessor * RadioControlValueAccessor * DefaultValueAccessor * NumberValueAccessor * RangeValueAccessor */ @Input() nzValue = null; @Input() nzDisabled = false; @Input() placeholder = \u0026#39;\u0026#39;; @Output() readonly nzValueChange = new EventEmitter(); @ViewChild(\u0026#39;buttonElement\u0026#39;) buttonElement!: ElementRef\u0026lt;HTMLButtonElement\u0026gt;; @ViewChild(\u0026#39;selectElement\u0026#39;) selectElement!: ElementRef\u0026lt;HTMLSelectElement\u0026gt;; provinceValue = null; cityValue = null; areaValue = null; currentProvinceList = []; currentCityList = []; currentAreaList = []; loadingProvinceList = false; loadingCityList = false; loadingAreaList = false; isEditMode = false; onChange: OnChangeType = () =\u0026gt; {}; onTouched: OnTouchedType = () =\u0026gt; {}; constructor(private apiService: ApiService) {} ngOnInit() { this.getCurrentProvinceList(); } focus(): void { if (this.isEditMode) { this.selectElement.nativeElement.focus(); } else { this.buttonElement.nativeElement.focus(); } } blur(): void { if (this.isEditMode) { this.selectElement.nativeElement.blur(); } else { this.buttonElement.nativeElement.blur(); } } /** * 接收 FormControl 传来的 value * 将 value 更新到 UI 上 */ writeValue(value: any) { this.nzValue = value; } /** * registerOnChange 会被 FormControl 用来注册回调 fn * 当 UI 中的值变化时，fn 会被调用 */ registerOnChange(fn: OnChangeType) { this.onChange = fn; } /** * 用来处理用户对组件的交互 * 通常可以不用处理交互 */ registerOnTouched(fn: OnTouchedType) { this.onTouched = fn; } setDisabledState(disabled) { this.nzDisabled = disabled; } handleSwitch2Edit() { this.isEditMode = !this.isEditMode; } handleProvinceValueChange(value) { this.provinceValue = value; this.getCurrentCityList(value); } handleCityValueChange(value) { this.cityValue = value; this.getCurrentAreaList(value); } handleAreaValueChange(value) { this.areaValue = value; const { provinceName } = this.provinceValue; const { cityName } = this.cityValue; const { areaName } = this.areaValue; const temp = `${provinceName}${cityName}${areaName}`; this.nzValue = temp; this.isEditMode = false; this.onChange(this.nzValue); this.nzValueChange.emit(this.nzValue); } getCurrentProvinceList() { // ... } getCurrentCityList({ provinceId }) { // ... } getCurrentAreaList({ cityId }) { // ... } } 将自身注册为 NG_VALUE_ACCESSOR 这种方式有一些局限，它在 Validator 被触发时，不能根据验证结果作出反应；但是优势是可以绑定自定义事件。\n如果需要对 Validator 作出反应，可以依赖注入 NgControl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 type OnChangeType = (value: string[] | null) =\u0026gt; void; type OnTouchedType = () =\u0026gt; any; @Component({ selector: \u0026#39;hema-quarterly-picker\u0026#39;, templateUrl: \u0026#39;./hema-quarterly-picker.component.html\u0026#39;, styleUrls: [\u0026#39;./hema-quarterly-picker.component.scss\u0026#39;] }) export class HemaQuarterlyPickerComponent implements ControlValueAccessor { @Input() nzValue: string[]; // 默认日期 @Input() nzDisabled = false; @Input() nzPlaceHolder = \u0026#39;请选择\u0026#39;; @Input() nzAllowClear = false; @Input() style: any; onChange: OnChangeType = () =\u0026gt; {}; onTouched: OnTouchedType = () =\u0026gt; {}; quarterMonth = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12] ]; visible = false; quarterly: number; year: number; cachYear: number; interval = null; showClose = false; get isError() { return this.control.dirty \u0026amp;\u0026amp; this.control.invalid \u0026amp;\u0026amp; !this.control.disabled; } constructor(private control: NgControl) { // 获取 NgControl 实例 this.control \u0026amp;\u0026amp; (this.control.valueAccessor = this); } writeValue(value: string[]) { this.nzValue = value; this.hendleInit(); } registerOnChange(fn: OnChangeType) { this.onChange = fn; } registerOnTouched(fn: OnTouchedType) { this.onTouched = fn; } setDisabledState(disabled: boolean) { this.nzDisabled = disabled; } handleChange(value: string[]) { this.nzValue = value; this.onChange(this.nzValue); // ... } } asyncPipe 一般情况下，我们会在 ngOnInit 中请求组件需要的初始化数据；但是这会导致相关的副作用散落在组件的各个部分。\n借助 Angular 提供的 AsyncPipe，组件可以以流的形式来处理这部分逻辑；这样，相关逻辑就被数据流“串联”起来了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 @Component({ template: ` \u0026lt;nz-table (nzPageIndexChange)=\u0026#34;handlePageIndexChange($event)\u0026#34; (nzPageSizeChange)=\u0026#34;handlePageSizeChange($event)\u0026#34; [nzData]=\u0026#34;banlanceList$ | async as banlanceList\u0026#34; [nzPageIndex]=\u0026#34;paginationData.pageIndex\u0026#34; [nzPageSize]=\u0026#34;paginationData.pageSize\u0026#34; [nzTotal]=\u0026#34;paginationData.total\u0026#34; [nzLoading]=\u0026#34;loading\u0026#34; \u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr *ngFor=\u0026#34;let item of banlanceList\u0026#34;\u0026gt;...\u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/nz-table\u0026gt; ` }) export class ExclusiveAccountBalanceComponent { // 数据流起始于路由查询参数 banlanceList$ = this.route.queryParams.pipe( // 执行“请求发起前”的副作用 tap((params: SearchParams) =\u0026gt; { this.lastQueryParams = params; this.loading = true; }), // 切换到数据请求数据流，发起请求并会自动舍弃上次请求（自动处理竞态问题） switchMap(params =\u0026gt; this.apiService.exclusiveDailyAccountBalancePage(params) ), // 执行“请求发起后”的副作用 tap(({ pages = 0, paginationData = {} }) =\u0026gt; { this.paginationData = paginationData as PaginationData; this.pages = pages; this.loading = false; }), // 对数据流进行格式化 map(({ records = [] }) =\u0026gt; records) ); paginationData: PaginationData = { pageIndex: 1, pageSize: 10, total: 0 }; pages = 0; lastQueryParams: SearchParams = {}; loading = false; constructor( private apiService: ApiService, private router: Router, private route: ActivatedRoute ) {} handleSearched(queryParams) { // 路由查询参数变化，新的数据被放入数据流中 this.router.navigate([], { relativeTo: this.route, queryParams, queryParamsHandling: \u0026#39;merge\u0026#39; }); } handleRefreshed() { // 将上次的查询数据，重新放入数据流中 (this.banlanceList$ as AnonymousSubject\u0026lt;SearchParams\u0026gt;).next( this.lastQueryParams ); } } directive 指令的好处是，可以在同一元素上叠加多个指令来完成不同的逻辑。\n指令 carousel 绑定了三个 key：from、autoplay、withDelay； 对应传入的值也有三个：images、\u0026lsquo;on\u0026rsquo;、2000。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @Directive({ selector: \u0026#39;[carousel]\u0026#39; }) export class CarouselDirective implements OnInit, OnDestroy { @Input(carouselFrom) images: string[]; @Input(carouselAutoplay) set autoplay(autoplay: \u0026#39;on\u0026#39; | \u0026#39;off\u0026#39;) { autoplay === \u0026#39;on\u0026#39; ? this.setAutoplayTimer() : this.clearAutoplayTimer(); } @Input(carouselWithDelay) set delay(delay: number) { this._autoplayDelay = delay; } get delay() { return this._autoplayDelay || 1000; } private _autoplayDelay: number; private setAutoplayTimer() { this.timerId = setInterval(() =\u0026gt; { this.next(); }, this.delay); } private clearAutoplayTimer() { clearInterval(this.timerId); } context: CarouselContext | null = null; timerId: number | null = null; index: number | null = 0; constructor( private tpl: TemplateRef\u0026lt;CarouselContext\u0026gt;, private vcr: ViewContainerRef ) {} ngOnInit() { this.context = { $implicit: this.images[0], controller: { next: () =\u0026gt; this.next(), prev: () =\u0026gt; this.prev() } }; this.vcr.createEmbeddedView(this.tpl, this.context); } ngOnDestroy() { this.clearAutoplayTimer(); } next() { this.index++; if (this.index \u0026gt;= this.images.length) { this.index = 0; } this.context.$implicit = this.images[this.index]; } prev() { this.index--; if (this.index \u0026lt; 0) { this.index = this.images.length - 1; } this.context.$implicit = this.images[this.index]; } } 使用指令：\n1 2 3 4 5 6 7 8 \u0026lt;div *carousel=\u0026#34;let item from images autoplay \u0026#39;on\u0026#39; withDelay 1500\u0026#34;\u0026gt; \u0026lt;img [src]=\u0026#34;item\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div *carousel=\u0026#34;let item from images; let ctrl = controller autoplay \u0026#39;off\u0026#39;\u0026#34;\u0026gt; \u0026lt;img [src]=\u0026#34;item\u0026#34; /\u0026gt; \u0026lt;button (click)=\u0026#34;ctrl.prev()\u0026#34;\u0026gt;\u0026amp;lt;\u0026lt;/button\u0026gt; \u0026lt;button (click)=\u0026#34;ctrl.next()\u0026#34;\u0026gt;\u0026amp;gt;\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; runOutsideAngular 在 Angular 中，DOM 事件的触发会导致 Ng 进行“变更检测”；如果该事件的副作用最终没有造成“绑定值”的更新；那么当前的“变更检测”就是多余的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Component({ selector: \u0026#39;app-event-listener\u0026#39;, template: ` \u0026lt;button nz-button nzType=\u0026#34;primary\u0026#34; (click)=\u0026#34;handleClick($event)\u0026#34;\u0026gt; 点击 \u0026lt;/button\u0026gt; ` }) export class EventListenerComponent implements AfterViewChecked { ngAfterViewChecked(): void { // 每次“变更检测”之后调用 console.log(\u0026#39;AfterViewChecked\u0026#39;); } handleClick(e: MouseEvent) { // 执行的副作用和 Angular 无关 console.log(e); } } /** * 每次点击按钮，控制台依次输出： * PointerEvent {...} * AfterViewChecked * ... */ 这么看来，最理想的状态是，只对会造成“绑定值”更新的副作用进行“变更检测”（这不就是 Vue 吗？）；但是，Ng 没有响应式系统，它只能通过 NgZone 拦截所有可能导致数据变更的函数调用来处理数据“响应”。好在 NgZone 提供了一个 runOutsideAngular 方法，可以使副作用的执行不触发“变更检测”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component({ selector: \u0026#39;app-event-listener\u0026#39;, template: ` \u0026lt;button nz-button nzType=\u0026#34;primary\u0026#34; (click)=\u0026#34;handleClick($event)\u0026#34;\u0026gt; 点击 \u0026lt;/button\u0026gt; ` }) export class EventListenerComponent implements AfterViewChecked { constructor(private zone: NgZone) {} ngAfterViewChecked(): void { // 每次“变更检测”之后调用 console.log(\u0026#39;AfterViewChecked\u0026#39;); } handleClick(e: MouseEvent) { // 使用 runOutsideAngular 包裹“副作用” this.zone.runOutsideAngular(() =\u0026gt; { console.log(e); }); } } /** * 每次点击按钮，控制台依次输出： * PointerEvent {...} * AfterViewChecked * ... */ 可以看到 runOutsideAngular 并没有起作用，原因是事件回调 handleClick 已经注册在了 Ng 内部：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Component({ selector: \u0026#39;app-event-listener\u0026#39;, template: ` \u0026lt;button #btn nz-button nzType=\u0026#34;primary\u0026#34;\u0026gt;点击\u0026lt;/button\u0026gt; ` }) export class EventListenerComponent implements AfterViewInit, AfterViewChecked { @ViewChild(\u0026#39;btn\u0026#39;) btn!: ElementRef\u0026lt;HTMLButtonElement\u0026gt;; constructor(private renderer: Renderer2, private zone: NgZone) {} ngAfterViewInit(): void { this.zone.runOutsideAngular(() =\u0026gt; { // 以下三种均在 runOutsideAngular 内部完成事件的绑定 this.setupClickListener1(); this.setupClickListener2(); this.setupClickListener3(); }); } ngAfterViewChecked(): void { console.log(\u0026#39;AfterViewChecked\u0026#39;); } setupClickListener1() { (this.btn as any).elementRef.nativeElement.addEventListener( \u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { console.log(e); } ); } setupClickListener2() { this.renderer.listen( (this.btn as any).elementRef.nativeElement, \u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { console.log(e); } ); } setupClickListener3() { fromEvent((this.btn as any).elementRef.nativeElement, \u0026#39;click\u0026#39;).subscribe( (e: MouseEvent) =\u0026gt; { console.log(e); } ); } } /** * 以上三种绑定方式，每次点击按钮，控制台依次输出： * PointerEvent {...} * ... */ 可以使用“指令”将这部分逻辑进行封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Directive({ selector: \u0026#39;[click.zoneless]\u0026#39; }) export class ClickZonelessDirective implements OnInit, OnDestroy { @Output(\u0026#39;click.zoneless\u0026#39;) clickZoneless = new EventEmitter\u0026lt;MouseEvent\u0026gt;(); private removeListener: Function; constructor( private readonly zone: NgZone, private readonly el: ElementRef, private readonly renderer: Renderer2 ) {} ngOnInit() { this.zone.runOutsideAngular(() =\u0026gt; { this.setupListener(); }); } ngOnDestroy() { this.removeListener(); } setupListener() { this.removeListener = this.renderer.listen( this.el.nativeElement, \u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { this.clickZoneless.emit(e); console.log(e); } ); } } /** * 每次点击按钮，控制台依次输出： * PointerEvent {...} * ... */ 但是这种方式不够灵活，总不能一种事件就写一个指令。可以借助 EventManager 实现同样的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // zoneless-event.service.ts @Injectable({ providedIn: \u0026#39;root\u0026#39; }) export class ZonelessEventService { manager: EventManager; supports(eventName: string): boolean { return eventName.endsWith(\u0026#39;.zoneless\u0026#39;); } addEventListener( element: HTMLElement, eventName: keyof HTMLElementEventMap, handler: EventListener ): Function { const [nativeEventName] = eventName.split(\u0026#39;.\u0026#39;); this.manager.getZone().runOutsideAngular(() =\u0026gt; { element.addEventListener(nativeEventName, handler); }); return () =\u0026gt; element.removeEventListener(nativeEventName, handler); } } // app.module.ts @NgModule({ bootstrap: [AppComponent], declarations: [AppComponent], imports: [BrowserModule], providers: [ { // @Inject(EVENT_MANAGER_PLUGINS) 就可以拿到 ZonelessEventService provide: EVENT_MANAGER_PLUGINS, useClass: ZonelessEventService, multi: true } ] }) export class AppModule {} ExpressionChangedAfterItHasBeenCheckedError 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component({ template: ` \u0026lt;label nz-checkbox [(ngModel)]=\u0026#34;checkbox\u0026#34;\u0026gt; \u0026lt;span [textContent]=\u0026#34;time | date : \u0026#39;hh:mm:ss:SSS\u0026#39;\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; `, selector: \u0026#39;app-example\u0026#39; }) export class ListComponent { checkbox = false; get time() { return Date.now(); } } /** * 每次勾选多选框，控制台输出： * NG0100: ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. * ... */ 控制台会报** NG100 错误 **，原因是多选框的勾选会改变 checkbox，从而触发“变更检测”，导致 DOM 更新，在 DOM 重新渲染的过程中，timeGetter 的返回值和在“变更检测”过程中的返回值不同；渲染前后的值的不同被“发现”了，导致错误被抛出。\n值的变化是什么时候被发现的呢？在组件被渲染到页面的过程中，组件内部会有一个被称为 View 的数据结构，保存着对组件实例的引用和绑定表达式的值；在变更检测过程中，编译器会将需要更新的 DOM 属性打上标记；对于每个被标记的属性，编译器都会创建一个绑定，该绑定定义了要更新的属性名称以及用来获取新值的表达式。\n在“变更检测”过程中，会运行编译器为视图生成的所有绑定表达式，并将执行结果和储存在 View 中的 oldValue进行比较，这就是“脏”检查的由来；如果值有变化，那么就会更新“界面”和“oldValue”；当前组件的“变更检测”进行完毕，就会对“子组件”进行相同的操作。\n在上述例子中，Angular 在 spanView 和 timeGetter 之间建立了一种绑定关系；在每次检测过程中，绑定表达式被执行，timeGetter 返回的时间戳并被日期管道处理，日期管道返回的值会和 oldValue 进行比较，如果检测到值的差异，spanView 的 textContent 会被更新。\n在开发环境中，每个“变更检测周期（整个组件树完成变更检测）”之后会同步进行一次“额外的检测”，以确保“最终值”和变更检测过程中的值一致；不同于“变更检测”，在“额外检测”过程中，如果检测到“值的不同”，不会进行视图更新，而是抛出ExpressionChangedAfterItHasBeenCheckedError错误。\n简单的说，如果值总是在“变更检测”期间发生变化，就会造成“变更检测死循环”；“ExpressionChangedAfterItHasBeenCheckedError”错误就是在出现“变更检测死循环”的情况下被抛出的；或者说，当应用内部状态和渲染结果不匹配时，就会抛出“ExpressionChangedAfterItHasBeenCheckedError”。\n参考 How To Use ControlValueAccessor To Enhance Date Input With Automatic Conversion And Validation Component Initialization Without ngOnInit With Async Pipes For Observables And ngOnChanges A Gentle Introduction Into Change Detection in Angular Running Event Listeners Outside Of The NgZone Understanding Angular Structural Directives ","date":"2022-11-03T00:00:00Z","image":"https://vikingama.github.io/img/cover/angular.png","permalink":"https://vikingama.github.io/p/angular-%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/","title":"Angular 组件设计"},{"content":"需求 随着政府对个体户税收政策的收紧，公司需要采集客户的“话术视频”来作为规避业务风险的“凭据”。具体来说就是，需要用户在手机端录制一段“我已同意 xxx”的视频，并且录制完成之后，上传至服务器保存。\n经过调研搜集，大致有两种实现思路： 基于 input[capture] 的实现 和 基于 WebRTC 的实现 ；input 这种不是本文重点，略过。\n基于 WebRTC 的实现的基本思路是：\n调用 MediaDevices 获取设备相机和麦克风权限； 调用 getUserMedia 方法创建 MediaStream 数据流； 调用 MediaRecorder 捕获媒体流并对数据流捕获和缓存； 如果文件较大，可能需要 Blob 等 API 对媒体流进行分包上传； 如果产品有需要，可能后端要调用 ffmpeg 等工具对视频编码进行转换。 WebRTC 前端调用设备采集视频流主要采用的是 WebRTC 实时通讯技术 ，它是一项可以用于视频聊天、音频聊天或 P2P 文件分享的技术。\n整个 WebRTC 主要有以下几个 API 组成：\nMediaDevices ，提供访问连接媒体输入的设备（相机、麦克风以及屏幕共享等），可以使你取得任何硬件资源的媒体数据： getUserMedia ，为 RTC 连接获取设备的摄像头与麦克风权限并接入设备信号；会提示用户给予使用媒体输入的许可； getDisplayMedia ，提示用户去选择和授权捕获屏幕内容在一个 MediaStream 里。 MediaStream 是一个媒体内容的流，一个流包含几个轨道，比如视频和音频轨道； RTCDataChannel ，用来设置 P2P 数据连接，在两者之间建立一个双向数据通道连接； RTCPeerConnection ，用于配置音频或视频聊天。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 let media = null; // 请求当前设备可用的媒体输入输出设备 const enumerateDevicesPromise = navigator.mediaDevices.enumerateDevices(); enumerateDevicesPromise .then(mediaDevices =\u0026gt; { if (!Array.isArray(mediaDevices)) { throw new Error(\u0026#39;未找到媒体设备\u0026#39;); } mediaDevices.forEach(({ deviceId, groupId, kind, label }) =\u0026gt; { console.group(\u0026#39;EnumerateDevices\u0026#39;); console.log(\u0026#39;设备 ID\u0026#39;, deviceId); console.log(\u0026#39;设备组 ID\u0026#39;, groupId); console.log(\u0026#39;设备类型\u0026#39;, kind); console.log(\u0026#39;设备名称\u0026#39;, label); console.groupEnd(); }); const mediaDevicesKinds = mediaDevices.map(({ kind }) =\u0026gt; kind); if (!mediaDevicesKinds.includes(\u0026#39;videoinput\u0026#39;)) { throw new Error(\u0026#39;没有相机权限\u0026#39;); } if (!mediaDevicesKinds.includes(\u0026#39;audioinput\u0026#39;)) { throw new Error(\u0026#39;没有麦克风权限\u0026#39;); } }) .catch(error =\u0026gt; { console.error(error); }); // 请求当前设备可用的 Constraints 属性 const supportedConstraints = navigator.mediaDevices.getSupportedConstraints(); const supportedConstraintsKey = Object.entries(supportedConstraints) .filter(item =\u0026gt; item[1]) .map(item =\u0026gt; item[0]); // MediaStreamConstraints 对象，用于指定“请求的媒体类型和相对应的参数” const userMediaConstraints = { video: { width: { min: 1024, ideal: 1280, max: 1920 }, // 指定视频宽度 height: { min: 776, ideal: 720, max: 1080 }, // 指定视频高度 frameRate: { min: 15, ideal: 30, max: 60 }, // 指定视频帧率 facingMode: { exact: \u0026#39;environment\u0026#39; } // 强制使用后置摄像头 // facingMode: \u0026#39;user\u0026#39; // 优先使用前置摄像头 }, // video: true, // 不指定分辨率 audio: true }; // 过滤 userMediaConstraints 中可用的属性 Object.keys(userMediaConstraints).forEach(key =\u0026gt; { if (!supportedConstraintsKey.includes(key)) { delete userMediaConstraints[key]; } }); // 返回的 promise 可能既不会 resolve 也不会 reject，因为现在的操作系统权限控制不是非黑即白的 const userMediaPromise = navigator.mediaDevices.getUserMedia(userMediaConstraints); userMediaPromise .then(mediaStream =\u0026gt; { // 如果用户授予了媒体权限，userMediaPromise 会 resolve 一个 MediaStream 对象 const monitorEle = document.querySelector(\u0026#39;.monitor\u0026#39;); /** * 使用 srcObject 将不需要借助 URL.createObjectURL（搭配 src 属性） * 仅有 Safari 完整支持了 MediaStream、MediaSource、Blob、File * 大部分浏览器仅支持 MediaStream，不过对我们来说足够了 */ monitorEle.loop = false; monitorEle.muted = true; monitorEle.srcObject = mediaStream; monitorEle.onloadedmetadata = () =\u0026gt; { // 视频元数据加载完毕，开始播放 monitorEle.play(); }; }) .catch(error =\u0026gt; { // 如果用户拒绝了媒体权限，会 reject 一个 PermissionDeniedError/NotFoundError switch (error.name) { case \u0026#39;AbortError\u0026#39;: console.error(\u0026#39;中止错误\u0026#39;); break; case \u0026#39;NotAllowedError\u0026#39;: console.error(\u0026#39;拒绝错误，用户拒绝了媒体访问请求\u0026#39;); break; case \u0026#39;NotFoundError\u0026#39;: console.error(\u0026#39;找不到错误\u0026#39;); break; case \u0026#39;NotReadableError\u0026#39;: console.error(\u0026#39;无法读取错误，可能是硬件、软件问题\u0026#39;); break; case \u0026#39;OverconstrainedError\u0026#39;: console.error(\u0026#39;无法满足要求错误，无法满足 constraint 的要求\u0026#39;); break; case \u0026#39;SecurityError\u0026#39;: console.error(\u0026#39;安全错误，设备媒体被禁止，和用户设置有关\u0026#39;); break; case \u0026#39;TypeError\u0026#39;: console.error(\u0026#39;类型错误，constraint 设置问题\u0026#39;); break; default: // 建议将 error 上报 break; } }); // 用来进行屏幕共享/录屏，当前业务场景下用不到 let captureStream = null; const getDisplayMediaPromise = navigator.mediaDevices.getDisplayMedia(userMediaConstraints); getDisplayMediaPromise .then(mediaStream =\u0026gt; { captureStream = mediaStream; }) .catch(error =\u0026gt; { switch (error.name) { case \u0026#39;AbortError\u0026#39;: console.error(\u0026#39;中止错误\u0026#39;); break; case \u0026#39;InvalidStateError\u0026#39;: console.error(\u0026#39;无效状态错误，当前页面处于非激活状态\u0026#39;); break; case \u0026#39;NotAllowedError\u0026#39;: console.error( \u0026#39;拒绝错误，用户拒绝了访问屏幕区域的权限或者不允许当前浏览实例访问屏幕共享\u0026#39; ); break; case \u0026#39;NotFoundError\u0026#39;: console.error(\u0026#39;找不到错误，没有可用于捕获的屏幕视频源\u0026#39;); break; case \u0026#39;NotReadableError\u0026#39;: console.error( \u0026#39;无法读取错误，发生了硬件或操作系统级别错误或锁定，从而预先占用了共享所选源\u0026#39; ); break; case \u0026#39;OverconstrainedError\u0026#39;: console.error( \u0026#39;转换错误，创建流后，由于无法生成兼容的流导致应用指定的 constraints 失效\u0026#39; ); break; case \u0026#39;TypeError\u0026#39;: console.error(\u0026#39;类型错误，constraint 设置问题\u0026#39;); break; default: // 建议将 error 上报 break; } }) .finally(() =\u0026gt; { // 保存 captureStream，保存至服务器 }); // 接下来就是使用 MediaRecorder 进行视频流的录制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 let chunks = []; const { isTypeSupported } = MediaRecorder; const mimeType = isTypeSupported(\u0026#39;video/mp4\u0026#39;) ? \u0026#39;video/mp4\u0026#39; : isTypeSupported(\u0026#39;video/mpeg\u0026#39;) ? \u0026#39;video/mpeg\u0026#39; : isTypeSupported(\u0026#39;video/webm;codecs=h264\u0026#39;) ? \u0026#39;video/webm;codecs=h264\u0026#39; : isTypeSupported(\u0026#39;video/webm;codecs=h265\u0026#39;) ? \u0026#39;video/webm;codecs=h265\u0026#39; : isTypeSupported(\u0026#39;video/webm;codecs=vp8\u0026#39;) ? \u0026#39;video/webm;codecs=vp8\u0026#39; : isTypeSupported(\u0026#39;video/webm;codecs=vp9\u0026#39;) ? \u0026#39;video/webm;codecs=vp9\u0026#39; : isTypeSupported(\u0026#39;video/webm\u0026#39;) ? \u0026#39;video/webm\u0026#39; : \u0026#39;video/*\u0026#39;; const mediaRecorder = new MediaRecorder(mediaStream, { mimeType }); mediaRecorder.ondataavailable = ({ data }) =\u0026gt; { if (data.size \u0026gt; 0) { chunks.push(e.data); } }; mediaRecorder.onstart = () =\u0026gt; { console.log(\u0026#39;录制开始\u0026#39;); }; mediaRecorder.onpause = () =\u0026gt; { console.log(\u0026#39;录制暂停\u0026#39;); }; mediaRecorder.onresume = () =\u0026gt; { console.log(\u0026#39;录制继续\u0026#39;); }; mediaRecorder.onstop = () =\u0026gt; { console.log(\u0026#39;录制停止\u0026#39;); }; mediaRecorder.onerror = () =\u0026gt; { console.error(\u0026#39;录制失败\u0026#39;); }; mediaRecorder.start(); // 开始录制 mediaRecorder.pause(); // 暂停录制 mediaRecorder.resume(); // 继续录制 mediaRecorder.stop(); // 结束录制 // 暂停/继续录制 const pauseBtn = document.querySelector(\u0026#39;.pause-btn\u0026#39;); pauseBtn.onclick = () =\u0026gt; { if (mediaRecorder.state === \u0026#39;recording\u0026#39;) { mediaRecorder.pause(); } else if (mediaRecorder.state === \u0026#39;paused\u0026#39;) { mediaRecorder.resume(); } }; 兼容性 根据 旷视发布的 RTC 兼容性说明 ，iOS 和原生 Android 内置的浏览器和 WebView 组件都已经很好的支持了 WebRTC；腾讯的 X5 也对 WebRTC 有不错的支持。\n如果出现了运行错误，可以使用 adapter.js 垫片并使用 Agora WebRTC Precall Test 检测当前环境对 WebRTC 的支持情况。\n小米部分机型不识别 MediaStream，并且没有对应的开发文档。\n如果 iOS 不能实时预览和回放，请 参阅 。\nDEMO 在 这里 。\n","date":"2022-04-25T00:00:00Z","image":"https://vikingama.github.io/img/cover/webrtc.png","permalink":"https://vikingama.github.io/p/webrtc-%E5%88%9D%E4%B8%8A%E6%89%8B/","title":"WebRTC 初上手"},{"content":"组件 在 Angular 中，组件是用来定义视图的，一个应用至少有一个根组件（属于根模块的一部分）；组件由三部分组成：组件类（控制组件模板渲染）、组件模板、组件样式（默认仅对当前组件生效，不会污染全局）；可以使用 ng generate 命令或 编辑器扩展 快速新建组件（服务、管道\u0026hellip;）：\n组件模板，语法和 HTML 几乎相同，多了一些 Angular 独有的指令和标签； 组件样式，作用域仅限于当前组件（可以通过“样式封装策略 encapsulation”进行更改）； 组件类，就是普通的 class；组件类中声明的属性和方法会自动注入组件模板中。 组件的父子关系是通过“组件的视图对象”间接建立的；每个组件都有一个宿主视图和一些内建视图。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 const slideMotion = trigger(\u0026#39;slideMotion\u0026#39;, [ // 创建一组有名字的 CSS 样式，它会在成功转换到指定的状态时应用到元素上 state( \u0026#39;void\u0026#39;, // 定义一个或多个要用于动画中的 CSS 样式 style({ opacity: 0, transform: \u0026#39;scaleY(0.8)\u0026#39; }) ), state( \u0026#39;enter\u0026#39;, style({ opacity: 1, transform: \u0026#39;scaleY(1)\u0026#39; }) ), // 定义两个命名状态之间的动画序列 transition(\u0026#39;void =\u0026gt; *\u0026#39;, [animate(\u0026#39;0.2s cubic-bezier(0.7, 0.3, 0.1, 1)\u0026#39;)]), transition(\u0026#39;* =\u0026gt; void\u0026#39;, [animate(\u0026#39;0.2s cubic-bezier(0.86, 0, 0.07, 1)\u0026#39;)]) ]); // 组件类需要由 @Component 装饰器进行修饰 @Component({ // 动画相关元数据，用来放置“定义动画的触发器” animations: [slideMotion], /** * 变更检测策略： * 1. ChangeDetectionStrategy.Default：异步逻辑结束（事件、请求等等），NgZone 会自上而下对整个组件树做变更检测 * 2. ChangeDetectionStrategy.OnPush：用来跳过某些变更检测（因为不是每个操作都需要进行变更检测） * 在 OnPush 策略下，有四种情况仍旧可以触发变更检测： * 1. 组件 @Input 引用变化（这种情况下，搭配 Immutable.js 使用更佳） * 2. 组件及其子组件的 DOM 事件触发（计时器、异步请求、Promise 均不会触发检测） * 3. 组件内 Observable 订阅事件，同时设置 AsyncPipe * 4. 手动调用： * ChangeDetectorRef.detectChanges()，立即触发组件的变更检测 * ChangeDetectorRef.markForCheck()，等待应用的下一轮变更检测 * ApplicationRef.tick()，触发整个应用的变更检测 */ changeDetection: ChangeDetectionStrategy.Default, /** * 样式封装策略： * 1. ViewEncapsulation.ShadowDom，样式仅添加到 ShadowDOM 宿主中，基于 ShadowDOM 实现组件样式的封装与隔离； * 2. ViewEncapsulation.Emulated，默认策略，样式会被添加到 \u0026lt;head\u0026gt; 中，基于 CSS 属性选择器来实现组件样式的封装与隔离； * 3. ViewEncapsulation.None，样式会被添加到 \u0026lt;head\u0026gt; 中，不对样式进行封装与隔离，样式作用于全局（document）。 * ViewEncapsulation.ShadowDom 不是默认策略的原因是“并不是每个浏览器都支持 ShadowDOM” */ encapsulation: ViewEncapsulation.Emulated, /** * 放置一些『被动态调用』的组件，这些组件没有“直接”在模板中使用，Ng 是不知道是否应该对这些组件进行编译的 * entryComponents 引入的组件会通过 ViewContainerRef.createComponent 方法被动态调用 * 编译器会将这些组件编译并为他们创建“工厂函数” * 比如，一些在 Modal 中展示的组件 */ entryComponents: [], // 改写默认的插值表达式起止分界符，在和第三方库冲突的时候才会修改 interpolation: [], // 仅在 CommonJS 规范下有意义，用于解析组件模板和样式 moduleId: \u0026#39;\u0026#39;, // 是否从编译后的模板中移除多余的空白字符 preserveWhitespaces: false, /** * 组件“在模版中”只能以 \u0026lt;app-example\u0026gt;\u0026lt;/app-example\u0026gt; 的方式进行调用 * selector 决定了组件在模版中的调用方式 * 当 Angular 在模版中找到相应的标签时 * 就把该组件实例化在那里 */ selector: \u0026#39;app-example\u0026#39;, // 组件“在模版中”只能以 \u0026lt;xxx [app-example]\u0026gt;\u0026lt;/xxx\u0026gt; 的方式进行调用 selector: \u0026#39;[app-example]\u0026#39;, // 内部样式字符串 styles: \u0026#39;div{...} div\u0026gt;p{...}\u0026#39;, // 外部样式路径 styleUrls: [\u0026#39;./app.component.scss\u0026#39;], /** * 内部模板字符串 * template 和 templateUrl 不能同时存在 */ template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;p\u0026gt;...\u0026lt;/p\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;, // 外部模板路径 templateUrl: \u0026#39;./app.component.html\u0026#39;, // viewProviders 注册的 provider 只对 viewChildren 可见，对 contentChildren 不可见 viewProviders: [BbService], /** * providers 注册的 provider 对 contentChildren 和 viewChildren 均可见 * 如果你愿意的话，可以总是使用 providers 而忽略 viewProviders */ providers: [AaService] }) class ExampleComponent implements OnChanges, DoCheck, OnDestroy, OnInit, AfterContentInit, AfterContentChecked, AfterViewInit, AfterViewChecked { private temp; /** * 使用 @Input 修饰组件要从外部接受的属性 * \u0026lt;app-example [propOne]=\u0026#34;someValue\u0026#34;\u0026gt;\u0026lt;/app-example\u0026gt; */ @Input() propOne = \u0026#39;defaultPropOneValue\u0026#39;; /** * 可以给 propTwo 起一个别名（风格指南并不推荐） * \u0026lt;app-example [prop-two]=\u0026#34;someValue\u0026#34;\u0026gt;\u0026lt;/app-example\u0026gt; * 在组件内部，仍可以用 this.propTwo 访问接受到的属性值 */ @Input(\u0026#39;prop-two\u0026#39;) propTwo = \u0026#39;defaultPropTwoValue\u0026#39;; /** * 可以把 propThree 写成 getter/setter * 来“监听”外部的值的变化 */ @Input(\u0026#39;prop-three\u0026#39;) get propThree() { return this.temp; } set propThree(value) { // 可以执行一些别的逻辑 this.temp = value; } /** * 使用 @Output 修饰组件上绑定的自定义事件 * 通过 this.updatePropOne.emit(newValue) 向外传值（$event 会接收到 newValue） * \u0026lt;app-example (updatePropOneAlias)=\u0026#34;handleXXX($event)\u0026#34;\u0026gt;\u0026lt;/app-example\u0026gt; * EventEmitter 继承了 RxJS 中的 Subject * export declare interface EventEmitter\u0026lt;T\u0026gt; extends Subject\u0026lt;T\u0026gt; {...} * 在“Service”中不能使用 EventEmitter，可以使用 Subject 代替 */ @Output(\u0026#39;updatePropOneAlias\u0026#39;) updatePropOne = new EventEmitter\u0026lt;any\u0026gt;(); /** * Angular 不会接管构造函数 * 在构建组件树的时候会被调用 * 此时，还不能访问组件 DOM（ngOnInit 可以访问 DOM） * 组件初始化需要在生命周期函数中进行 * 这里仅仅用来注入一些组件需要依赖的服务 * 『依赖注入』机制会分析构造函数的『形参』 * 调用时，已经处理好根/父级 injectors 了 * 在 class 实例化的过程中，会向上查找 providers * 并将查找的结果传递回构造函数，在构造完成之后才会设置指令的数据绑定输入属性 */ constructor( /** * constructor 是在 injector 上下文中调用的唯一方法 * Angular 的 DI 系统会自动帮我们实例化注入的 Service * 并将服务实例绑定到当前实例上（也就是 this） * 方便我们以 this.xxService 的方式调用 */ private aaService: AaService, private bbService: BbService, private ccService: CcService ) {} /** * Angular 的运行机制分为两部分： * 1. 构建组件树；（调用 contructor） * 2. 执行脏检查。（调用生命周期函数） * 生命周期钩子（属于变更检测的一部分，起始于组件实例化，结束于组件实例的销毁）的执行顺序： * 1. ngOnChanges（可能执行多次，需注意逻辑精简，仅在有 @Input 属性的情况下才执行） * 2. ngOnInit * 3. ngDoCheck（可能执行多次，需注意逻辑精简） * 4. ngAfterContentInit * 5. ngAfterContentChecked（可能执行多次，需注意逻辑精简） * 6. ngAfterViewInit（仅存在组件，不能用于指令） * 7. ngAfterViewChecked（可能执行多次，需注意逻辑精简；仅存在组件，不能用于指令） * 8. ngOnDestroy * Compiler 会检查组件的钩子函数，给组件赋予不同的 NodeFlags * 在“脏检查”阶段，Angular 会根据组件的 NodeFlags 来调用对应的“钩子” */ ngOnChanges( // changes 仅包含了每个『发生变化』的属性 changes: SimpleChanges ): void { /** * 1. 如果组件绑定过输入属性，所绑定的一个或多个输入属性的值发生变化时都会调用 * 2. 如果绑定的是一个对象，如果对象的引用没变，ngOnChanges 就不会执行 * 3. 如果你的组件『没有输入属性』，框架就『不会调用该方法』 * 4. 在 ngOnInit 之前调用 */ for (const propName in changes) { const { currentValue, previousValue, firstChange } = changes[propName]; console.log( `current: ${currentValue}, previous: ${previousValue}, isFirstChange: ${firstChange}` ); } if (\u0026#39;propThree\u0026#39; in changes) { // 除了 getter/setter，也可以酱紫“监听”变化 } } ngOnInit(): void { /** * 在 ngOnChanges 第一次完成调用之后执行（即使没有绑定任何输入属性） * 用来执行复杂的在构造函数之外的组件初始化逻辑 * 获取初始数据的好地方 */ this.route.queryParams.subscribe(params =\u0026gt; { // 每当路由的查询参数变化，都重新获取数据 this.fetchData(params); }); } ngDoCheck(): void { /** * 用于检测 Angular 无法捕获的变更 * 紧跟在每次执行变更检测时的 ngOnChanges 和首次执行变更检测时的 ngOnInit 后调用 */ } ngAfterContentInit(): void { /** * 当 Angular 把外部内容投影进组件视图或指令所在的视图之后调用 * ngDoCheck 首次调用之后调用 * 仅仅调用一次 */ } ngAfterContentChecked(): void { /** * 每当 Angular 把外部内容投影进组件视图或指令所在的视图之后调用 * ngAfterContentInit 每次调用之后调用 * ngDoCheck 每次调用之后调用 */ } ngAfterViewInit(): void { /** * 当 Angular 初始化完组件视图及其子视图或包含该指令的视图之后调用 * ngAfterContentChecked 首次调用之后调用 * 仅仅调用一次 */ } ngAfterViewChecked(): void { /** * 每当 Angular 做完组件视图和子视图或包含该指令的视图的变更检测之后调用 * ngAfterContentChecked 每次调用之后调用 * ngAfterViewInit 每次调用之后调用 */ } ngOnDestroy(): void { /** * 每当指令/组件销毁之前立即调用，用于释放不会被垃圾回收的资源： * 1. 反注册在应用服务中注册的回调 * 2. 取消订阅可观察对象 * 3. 移除事件绑定 * 4. 清除计时器 */ } } 指令（没有“模版”的特殊组件） 指令用来将自定义行为附加到 DOM 中：\n结构性指令：通过添加、移除、替换 DOM 来修改布局，例如：*ngIf、*ngFor、*ngSwitch、*ngSwitchDefault、*ngComponentOutlet、*ngTemplateOutlet； 属性型指令：改变已有元素的外观或行为，例如：ngClass、ngStyle、ngModel、ngNonBindable、ngPreserveWhitespaces； Angular 没有提供 AngularJS 中的 ng-show 指令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Directive({ /** * \u0026lt;div [app-example] #exampleRef=\u0026#34;example\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; * 可以通过 exampleRef 获取到“当前指令的引用” */ exportAs: \u0026#39;example\u0026#39;, // 将类的属性映射到宿主元素的绑定 host: { /** * 当宿主元素（绑定的元素）上的 click 事件被触发时 * 调用当前指令内的 onClick 方法 */ \u0026#39;(click)\u0026#39;: \u0026#39;onClick()\u0026#39;, // 宿主元素的 class 被设置为 class-name-example（this.innerClass 的值） \u0026#39;[class]\u0026#39;: \u0026#39;innerClass\u0026#39; }, // 可以替代 @Input 装饰器 inputs: [], // 可以替代 @Output 装饰器 outputs: [], /** * 指令代码会被 AOT（ahead-of-time）编译器忽略 * 也就是说相关代码不会被预编译（打包的时候编译） * 而是保留到运行时进行动态编译 */ jit: true, // 依赖注入，详见“组件” providers: [], /** * 用来标记在哪些元素/组件上使用指令 * \u0026lt;div [app-example]\u0026gt;\u0026lt;/div\u0026gt; */ selector: \u0026#39;[app-example]\u0026#39; }) class ExampleDirective { // 也可以通过 @HostBinding 向宿主元素“绑定属性” @HostBinding(\u0026#39;class\u0026#39;) class = \u0026#39;class-name\u0026#39;; // 也可以通过 @HostListener 向宿主元素“绑定事件” @HostListener(\u0026#39;input\u0026#39;, [\u0026#39;$event\u0026#39;]) onInput(event) { console.log(event); } constructor(el: ElementRef, render2: Renderer2) { // 通过 ElementRef 可以拿到“宿主元素”的引用 el.nativeElement.style.backgroundColor = \u0026#39;red\u0026#39;; } innerClass: string = \u0026#39;class-name-example\u0026#39;; onClick() { console.log(\u0026#39;宿主元素上触发了 click 事件\u0026#39;); // 借助于 Renderer2 可以修改 Angular 的默认渲染行为 this.render2.setStyle(this.el.nativeElement, \u0026#39;color\u0026#39;, \u0026#39;red\u0026#39;); } } 结构型指令的实现需要借助辅助类 TemplateRef 和 ViewContainerRef：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 一个“延迟渲染”的例子 @Directive({ selector: \u0026#39;[delayRender]\u0026#39; }) export class DelayRender { constructor( private viewContainerRef: ViewContainerRef, // 对容器 View 的引用 private templateRef: TemplateRef\u0026lt;any\u0026gt; // 对 ng-template 的引用 ) {} @Input() set delayRender(timer: number) { this.viewContainerRef.clear(); setTimeout(() =\u0026gt; { this.viewContainerRef.createEmbeddedView(this.templateRef); }, timer); } } 管道 Angular 内置了 async（从 Promise/Observable 中取值）、date、currency、json（JSON2String）、uppercase、lowercase、titlecase、precent 等管道。\n无论是用法还是效果都和 Vue 3.0 中已经删除的 filter 很像，用于数据转换。\n有一点需要注意：管道操作符的优先级高于逻辑运算符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 type DomSanitizerType = \u0026#39;html\u0026#39; | \u0026#39;style\u0026#39; | \u0026#39;js\u0026#39; | \u0026#39;url\u0026#39; | \u0026#39;resourceUrl\u0026#39;; type NzSafeAny = any; @Pipe({ name: \u0026#39;sanitizer\u0026#39;, // 管道名称 /** * 是否为“纯”管道： * 1. “纯”管道只有在原始数据/对象的\u0026#34;引用变更\u0026#34;时才会执行； * 2. “纯”管道会\u0026#34;忽略引用类型内部属性\u0026#34;的变化（引用没变）； * 3. “纯”管道内部的的 transform 方法必须为“纯”函数； * 4. “非纯”管道性能较差（任何交互行为都会触发执行）。 */ pure: true }) export class SanitizerPipe implements PipeTransform { // 实现一个“管道”，需要 implements PipeTransform 并实现 transform 方法 constructor(protected sanitizer: DomSanitizer) {} transform(value: NzSafeAny, type: \u0026#39;html\u0026#39;): SafeHtml; transform(value: NzSafeAny, type: \u0026#39;style\u0026#39;): SafeStyle; transform(value: NzSafeAny, type: \u0026#39;js\u0026#39;): SafeScript; transform(value: NzSafeAny, type: \u0026#39;url\u0026#39;): SafeUrl; transform(value: NzSafeAny, type: \u0026#39;resourceUrl\u0026#39;): SafeResourceUrl; transform( value: NzSafeAny, type: DomSanitizerType = \u0026#39;html\u0026#39; ): SafeHtml | SafeStyle | SafeScript | SafeUrl | SafeResourceUrl { switch (type) { case \u0026#39;html\u0026#39;: // 绕过安全检查，并信任给定的值是一个安全的 HTML return this.sanitizer.bypassSecurityTrustHtml(value); case \u0026#39;style\u0026#39;: // 绕过安全检查，并信任给定的值是一个安全的 CSS return this.sanitizer.bypassSecurityTrustStyle(value); case \u0026#39;js\u0026#39;: // 绕过安全检查，并信任给定的值是一个安全的 JS return this.sanitizer.bypassSecurityTrustScript(value); case \u0026#39;url\u0026#39;: // 绕过安全检查，并信任给定的值是一个安全的样式 URL（可以安全的用在 \u0026lt;img src\u0026gt; 中） return this.sanitizer.bypassSecurityTrustUrl(value); case \u0026#39;resourceUrl\u0026#39;: // 绕过安全检查，并信任给定的值是一个安全的资源 URL（可以安全的用在 \u0026lt;script src\u0026gt;、\u0026lt;iframe src\u0026gt; 中） return this.sanitizer.bypassSecurityTrustResourceUrl(value); default: throw new Error(`指定的安全类型无效`); } } } 通常我们会在 ngOnInit 中的进行数据请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class TicketListComponent implements OnInit { data: Array\u0026lt;{ id: number; title: srting; }\u0026gt;; constructor(private route: ActivatedRoute, private apiService: ApiService) {} ngOnInit() { this.apiService.fetchTickets1().subscribe(list =\u0026gt; (this.data = list || [])); // 或者 this.route.queryParams.subscribe(params =\u0026gt; { this.apiService .fetchTickets2(params.id) .subscribe(list =\u0026gt; (this.data = list || [])); }); } } AsyncPipe 可以替代 ngOnInit 完成这部分逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 interface Seller { id: number; name: srting; } interface Ticket { id: number; title: string; } @Component({ template: ` \u0026lt;p\u0026gt; \u0026lt;span\u0026gt;{{ (firstSeller$ | async).name }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; // 借助 as 将其重命名为 list \u0026lt;ul *ngIf=\u0026#34;tickets$ | async as list\u0026#34;\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of list\u0026#34;\u0026gt;{{ item.title | emptyValue }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; ` }) class SellerComponent { // 借助 pipe + map 对数据进行处理 readonly firstSeller$: Seller = this.apiService.fetchSellers().pipe( map(list =\u0026gt; { const { id, name } = list[0]; return { id, name }; }) ); // 借助 switchMap 切换数据流 readonly tickets$: Ticket = this.route.queryParams.pipe( switchMap(params =\u0026gt; this.apiService.fetchTickets(params.id)) ); constructor(private route: ActivatedRoute, private apiService: ApiService) {} } 如果不喜欢模版中出现太多 async，可以借助 combineLatest 将多个 Observable 合并：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @Component({ template: ` \u0026lt;ng-container *ngIf=\u0026#34;vm$ | async as vm\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of vm.boys\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of vm.girls\u0026#34;\u0026gt;{{ item.name }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of vm.dogs\u0026#34;\u0026gt;{{ item.nickName }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li *ngFor=\u0026#34;let item of vm.cats\u0026#34;\u0026gt;{{ item.nickName }}\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/ng-container\u0026gt; ` }) class BuyerComponent { readonly vm$ = combineLatest([ this.route.queryParams.pipe( switchMap(params =\u0026gt; this.apiService.fetchBoys(params.id)) ), this.route.queryParams.pipe( switchMap(params =\u0026gt; this.apiService.fetchGirls(params.id)) ), this.apiService.fetchDogs(), this.apiService.fetchCats() ]).pipe( map(([boys = [], girls = [], dogs = [], cats = []]) =\u0026gt; ({ boys, girls, dogs, cats })) ); constructor(private route: ActivatedRoute, private apiService: ApiService) {} } 自从 Angular 的编译和渲染引擎切换到 Ivy 之后：\nChangeDetectionStrategy.Default 策略下，在每次“变更检测”的过程中，“纯”管道的 transform 方法，只有在入参发生变化的情况下才会被调用； ChangeDetectionStrategy.Default 策略下，在每次“变更检测”的过程中，“非纯”管道的 transform 方法都会被调用； 当使用 async 管道时（它是“非纯”的），最好使用 ChangeDetectionStrategy.OnPush 策略； 无论是否是“纯”管道，每个管道都会有自己的实例（ViewEngine 时期，“纯”管道是共享实例的）； 在同一模版中，使用了两次 A 管道，则会有两个 A 管道的实例存在。 服务 服务是 Angular 的核心，他是专门用来处理某件事情的（数据请求、数据共享等）具有明确定义的 class；一般情况下，服务用来创建与视图无关但需要跨组件共享的数据/逻辑。\n官方推崇“Component 处理页面展示，Service 处理内在逻辑”的原则（有点像 React 中的 UI 组件和逻辑组件）。\n服务一般（具体看 providedIn 的取值）以单例的形式存在，实例化之后，应用于整个应用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @Injectable({ /** * providedIn 有四种取值： * 1. platform：平台级别注入，所有应用共享一个服务单例（仅适用于在一个 window 下运行多个 Angular 应用，有点微前端的意思）； * 2. root：应用程序（AppModule）/系统/全局/根级别注入，服务可以在整个应用中使用，而且共享同一个服务实例； * 3. [NgModule]：仅注入指定的 NgModule 中，仅可在指定的 NgModule 中使用，有 TreeShaking 加成； * 4. any：在每个注入的模块中，提供一个唯一的实例； * 5. null：仅仅表明可注入。 * 这种方式要优于 @NgModule({providers: [xxx]})，因为可以被 Tree Shaking */ providedIn: \u0026#39;root\u0026#39; }) class ApiPublicService { // 服务也可依赖别的服务，这里就依赖了 HttpClient constructor(private http: HttpClient) {} private paginationData(data: any): PaginationData { return { total: data.total, pageSize: data.size, pageIndex: data.current }; } private buildResponse(response) { const temp = { success: response.success, status: response.status, data: response.data, raw: response, records: response?.data?.records || [], objects: response?.data || {} }; if (response.errorCode) { temp.errorCode = response.errorCode; } if (response.errorMessage) { temp.errorMessage = response.errorMessage; } return temp; } private toResponse() { return pipe( map(response =\u0026gt; this.buildResponse(response)), tap(response =\u0026gt; { if (response.errorCode === \u0026#39;LOGIN_INVALID\u0026#39;) { // ... } else if (!response.success) { // ... } }) ); } public fetchList(params: ApiParams) { return this.http .get(`${environment.apiHost}/api/v1/list`, { params }) .pipe( this.toResponse(), map(response =\u0026gt; ({ paginationData: this.paginationData(response.data), records: response.data.records, pages: response.data.pages })) ); } } 模块 NgModule 是 Angular 的基本构造块（NgModule 和 ESModule 不同但互补），也是 Angular 对“依赖”进行组织的一种形式；其为组件提供了编译上下文；一个 Angular 应用由至少一个根模块（AppModule）和多个特性模块组成。\nNgModule 可以将组件及其相关代码（服务等）关联，形成功能单元（一般是按照业务划分的）；模块之间即相互独立又可通过 imports/exports 建立联系；模块可以让代码更“内聚”。\n一个 Angular 应用一般包含四种模块：\n根模块（引导模块），一个应用仅有一个根模块； 核心模块，为应用提供基础能力的模块，比如：路由模块、数据请求模块； 公共模块，包含了：公共组件、公共管道、公共指令； 业务模块，封装了具体业务的模块。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @NgModule({ /** * 使用：platformBrowserDynamic().bootstrapModule(AppModule) 启动根模块 * 只有根模块（一个应用只有一个）才设置这个属性 * 表示该模块应用的主视图（一般是根组件） * 同时也表明这个模块是“根模块” */ bootstrap: [AppComponent], /** * 声明该模块（包含/定义）的组件、管道、指令 * 这些组件、管道、指令是当前模块“私有的”（如果没有放入 exports） * 一个组件/指令/管道只能属于一个模块，不能同时把一个类声明在几个模块中 */ declarations: [ExampleComponent, ExamplePipe, ExampleDirective], /** * 如果组件没有直接在模版中使用，AOT 就不会提前编译组件 * 如果将组件添加到 entryComponents * AOT 就会提前编译组件 */ entryComponents: [], /** * 当前 NgModule 在 getNgModuleById 中的名字或唯一标识符 * 如果为 undefined，则该模块不会被注册到 getNgModuleById 中 * 用到的不多，官网也没做过多介绍，Angular 会自动帮我们处理 */ id: undefined, /** * 导入（当前模块运行需要依赖的的）其他模块： * 1. 被导入模块的 exports（低优先级）会和当前模块的 declarations（高优先级）合并 * 2. 被导入模块的 providers 会和当前模块的 providers 合并 * 3. 被导入模块的路由会和当前模块的路由合并 */ imports: [BrowserModule, OneModule, TwoModule], // 暴露（可供其他模块使用的）当前模块中的一些组件、指令和管道 exports: [], // 编译器选项，详见“指令” jit: true, /** * 当前模块需要的提供者（可注入对象，例如：ApiService） * 如果 provider 在根模块注入，则注入的 provider 为单例模式 */ providers: [], /** * 当前 NgModule 中允许使用的声明元素的 HTML 架构 * 当遇到不认识的元素时，怎么做处理 * 用于测试代码，业务中用不上 */ schemas: [] }) class ExampleModule {} 表单 Angular 提供了两种不同的方法来通过表单处理用户输入：响应式表单和模板驱动表单。两者都从视图中捕获用户输入事件、验证用户输入、创建表单模型、修改数据模型，并提供跟踪这些更改的途径：\n响应式表单：提供对底层表单对象模型直接、显式的访问；可伸缩性、可扩展性、可复用性和可测试性都更高；视图和数据模型之间使用同步数据流； 模版驱动表单：依赖模板中的指令来创建和操作底层的对象模型，在扩展性方面不如响应式表单，专注于简单场景，视图和数据模型之间使用异步数据流。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 /** * 使用“响应式表单”，需要在 NgModule 中导入 ReactiveFormsModule 和 FormsModule： * ReactiveFormsModule：提供 formControl、ngFormGroup 等指令； * FormsModule：提供 ngForm、ngModel 等模版驱动指令。 * ngForm 的 selector 包含了 form:not([formGroup]) ； * 所以，一般不用显式添加 ngForm 指令。 */ import { FormBuilder, // 提供一种更方便使用 FormGroup、FormArray 和 FormControl 的方式 FormControl, // 保存了字段的值和状态（是否合法、是否修改、是否禁用等） FormGroup, // 用来创建和管理一组 FormControl Validators } from \u0026#39;@angular/forms\u0026#39;; /** * submit 与 ngSubmit 的区别： * submit 是 DOM 事件，ngSubmit 是 Angular 事件； * 阻止默认行为需要在 submit 中进行； * ngSubmit 比 submit 先触发； * 两者的事件对象是一样的。 */ @Component({ selector: \u0026#39;app-form\u0026#39;, template: ` \u0026lt;form [formGroup]=\u0026#34;validateForm\u0026#34; (ngSubmit)=\u0026#34;handleSubmit($event)\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Name:\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;name\u0026#34; name=\u0026#34;name\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;age\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Age:\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;age\u0026#34; name=\u0026#34;age\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;age\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;div formGroupName=\u0026#34;address\u0026#34; alt=\u0026#34;嵌套表单组\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;street\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Street:\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;street\u0026#34; name=\u0026#34;street\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;street\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;city\u0026#34;\u0026gt; \u0026lt;span\u0026gt;City:\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;city\u0026#34; name=\u0026#34;city\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;city\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;state\u0026#34;\u0026gt; \u0026lt;span\u0026gt;State:\u0026lt;/span\u0026gt; \u0026lt;input id=\u0026#34;state\u0026#34; name=\u0026#34;state\u0026#34; type=\u0026#34;text\u0026#34; formControlName=\u0026#34;state\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button (click)=\u0026#34;handleFormUpdate()\u0026#34;\u0026gt;Update\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ` }) class FormComponent implements OnInit { validateForm: FormGroup; constructor(private fb: FormBuilder) {} ngOnInit() { /** * 一般使用这种，并且对于“动态表单”，最好在初始化的时候就将所有表单属性列出 * 而不是根据条件来动态的 addControl/removeControl * 因为那样，整个表单逻辑会非常不直观和零散 */ this.validateForm = this.fb.group({ name: [\u0026#39;\u0026#39;, Validators.required], age: [\u0026#39;18\u0026#39;, Validators.required], address: this.fb.group({ street: [\u0026#39;\u0026#39;, Validators.required], city: [\u0026#39;\u0026#39;, Validators.required], state: [\u0026#39;\u0026#39;, Validators.required] }) }); // 很少使用这种 this.validateForm = new FormGroup({ name: new FormControl(\u0026#39;\u0026#39;), age: new FormControl(\u0026#39;18\u0026#39;), address: new FormGroup({ street: new FormControl(\u0026#39;\u0026#39;), city: new FormControl(\u0026#39;\u0026#39;), state: new FormControl(\u0026#39;\u0026#39;) }) }); { /** * 表单不仅可以是一个对象，而且可以是一个数组 * 不过在表单验证的时候，可能需要类型断言 */ this.exampleForm = this.formBuilder.array([]); /** * 通过 push 向数组表单中添加表单项 * 还有 insert、removeAt 等方法 */ this.exampleForm.push( this.formBuilder.group({ type: [\u0026#39;SELF_EMPLOYED\u0026#39;, []], accountName: [accountName, [Validators.required]], accountNo: [accountNo, [Validators.required]], bankName: [bankName, [Validators.required]], bankBranchName: [bankBranchName, [Validators.required]] }) ); } { this.validateForm.valueChanges.subscribe(form =\u0026gt; { // 可以通过 valueChanges 来监听表单变化 }); } } handleSetDefault() { // 单个赋值 this.validateForm.get(\u0026#39;name\u0026#39;).setValue(\u0026#39;Bob\u0026#39;); this.validateForm.get(\u0026#39;address\u0026#39;).get(\u0026#39;street\u0026#39;).setValue(\u0026#39;Gongshu\u0026#39;); // 批量赋值 this.validateForm.patchValue({ gender: \u0026#39;male\u0026#39;, // 不会抛出错误 age: \u0026#39;21\u0026#39;, address: { city: \u0026#39;Zhejiang\u0026#39; } }); } handleSubmit($event) { $event.preventDefault(); const validArray = []; this.valid(this.validateForm, validArray); if (validArray.includes(false)) { return false; } console.log(this.validateForm.value); } // 对于嵌套多层的表单，可以使用递归进行验证 valid(form, temp = []) { if (form instanceof FormGroup) { Object.keys(form.controls).forEach(control =\u0026gt; this.valid(form.controls[control], temp) ); } else if (form instanceof FormArray) { form.controls.forEach(control =\u0026gt; this.valid(control, temp)); } else if (form instanceof FormControl) { form.markAsDirty(); form.updateValueAndValidity(); temp.push(form.disabled ? true : form.valid); } } } 路由 Router 是一个提供导航和操纵 URL 能力的 NgModule；通过将浏览器 URL 解释为更改视图的操作指令来启用导航：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 interface Route { canActivate?: any[]; // 调用 canActivate 钩子来确定“是否激活匹配到的路由” canActivateChild?: any[]; // 调用 canActivateChild 钩子来确定“路径参数的变化时，是否激活匹配到的子路由” canDeactivate?: any[]; // 调用 canDeactivate 钩子来确定“是否允许离开当前路由” canLoad?: any[]; // 调用 canLoad 钩子来确定“是否允许加载‘懒加载’的模块” children?: Route[]; // 嵌套子路由配置 component?: Type\u0026lt;any\u0026gt;; // 匹配之后，要实例化的组件 data?: Data; // 携带的数据，可通过 ActivatedRoute 获取 loadChildren?: LoadChildren; // 懒加载模块 matcher?: UrlMatcher; // 自定义匹配算 outlet?: string; // 当同级有多个 \u0026lt;router-outlet name=\u0026#34;xxx\u0026#34;/\u0026gt; 时，指定从渲染出口 path?: string; // 匹配路径 pathMatch?: string; // 路径匹配策略，prefix（默认）｜full redirectTo?: string; // 匹配之后，要重定向的路径 resolve?: ResolveData; // 与路由关联的解析数据 runGuardsAndResolvers?: RunGuardsAndResolvers; // 定义 Guards 和 Resolvers 的运行时机 } // 路由配置 const routes: Route[] = [ { path: \u0026#39;/login\u0026#39;, canActivate: [LoginGuard], // 懒加载只适用于“模块”，不适用于“组件” loadChildren: () =\u0026gt; import(\u0026#39;./login/login.module\u0026#39;).then(m =\u0026gt; m.LoginModule) }, // ... { path: \u0026#39;**\u0026#39;, component: NotFoundComponent } ]; @NgModule({ imports: [ // forRoot 表示“这是一个根路由模块”，在一个应用中只会使用一次 RouterModule.forRoot(routes, { /** * initialNavigation 取值： * enabled/enabledBlocking，引导程序被阻止，直到初始导航完成，一般 SSR 的时候才用得到 * enabledNonBlocking，引导程序不会被阻塞 * disabled，不执行初始导航 */ initialNavigation: \u0026#39;enabledNonBlocking\u0026#39;, anchorScrolling: \u0026#39;enabled\u0026#39;, // 当 URL 中有锚点时，是否滚动到锚点（\u0026#39;disabled\u0026#39;|\u0026#39;enabled\u0026#39;|\u0026#39;top\u0026#39;） enableTracing: false, // 为 true 时，Router 会将每次导航过程中触发的“路由生命周期”输出到控制台 onSameUrlNavigation: \u0026#39;ignore\u0026#39;, // 当导航到当前地址是的行为（\u0026#39;reload\u0026#39;|\u0026#39;ignore\u0026#39;） paramsInheritanceStrategy: \u0026#39;emptyOnly\u0026#39;, // 如何将参数、数据从父路由合并到子路由 preloadingStrategy: \u0026#39;NoPreloading\u0026#39;, // 预加载策略 scrollPositionRestoration: \u0026#39;enabled\u0026#39;, // 发生“导航回退”是否重置滚动位置（\u0026#39;disabled\u0026#39;|\u0026#39;enabled\u0026#39;|\u0026#39;top\u0026#39;） relativeLinkResolution: \u0026#39;legacy\u0026#39;, // 相对路径的导航策略 urlUpdateStrategy: \u0026#39;deferred\u0026#39;, // 浏览器地址栏的更新策略（默认在导航成功之后再更新） useHash: false, // 环境不支持 History API 时，可使用哈希导航 errorHandler: error =\u0026gt; error, // 自定义错误处理 scrollOffset: () =\u0026gt; [0, 0] // 路由导航后的滚动偏移量 }) ], exports: [RouterModule] }) export class AppRoutingModule {} 路由钩子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Injectable({ providedIn: \u0026#39;root\u0026#39; }) class LoginGuard implements CanActive, CanActiveChild { canActive(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) { const auth = this.authService.currentAuth(); const user = this.authService.currentUser(); if (route.url[0].path === \u0026#39;login\u0026#39;) { sessionStorage.removeItem(\u0026#39;auth\u0026#39;); sessionStorage.removeItem(\u0026#39;user\u0026#39;); } else if (!auth || !user) { return false; } return true; } } 在组件中获取路由信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import { ActivatedRoute, NavigationEnd, Router } from \u0026#39;@angular/router\u0026#39;; @Component({ selector: \u0026#39;app-general\u0026#39; }) export class GeneralComponent implements OnInit { isExclusive: boolean; get currentQueryParams() { // 可以通过 router 获取查询参数 const { url, parseUrl } = this.router; const { queryParams } = parseUrl(url); return queryParams; } constructor(private route: ActivatedRoute, private router: Router) {} ngOnInit() { // 在组件初始化的时候，订阅路由查询参数的变化 this.route.queryParams.subscribe(params =\u0026gt; { this.handleFetchData(params); }); // 订阅路由事件 this.router.events.subscribe(e =\u0026gt; { if (e instanceof NavigationEnd) { this.handleNavigationEnd(); } }); } handleFetchData(params) { // ... } handleNavigationEnd() { // 在导航结束时 const { exclusive } = this.currentQueryParams; this.isExclusive = String(exclusive) === \u0026#39;true\u0026#39;; } handleSwitchUrl($event, { exclusive = null, path = null }) { $event.stopPropagation(); let temp = []; let queryParams = null; const queryParamsHandling = \u0026#39;\u0026#39;; if (path) { temp = [path]; } if (exclusive) { queryParams = { exclusive }; } // 相对于当前路由进行导航并重置 URL 中的查询参数 this.router.navigate(temp, { relativeTo: this.route, queryParams, queryParamsHandling }); } } 依赖注入 依赖是指系统中的各个组成部分之间的相互关系；具体到 Angular，是指某个 class 执行其功能“所需的”服务（@Injectable）或对象。\n在传统模式中，如果组件 A 依赖服务 B，A 会在内部创建一个 B 的实例；在依赖注入模式中，依赖项 B 会通过 A 的 constructor 注入（默认行为是 new 调用），保存在 A 的私有属性上。\n当 class 需要某个依赖时，该依赖就会作为参数添加到 class 的构造函数中。当 Angular 实例化 class 时，DI 会在“注入器树”中查找（从局部开始，向上冒泡，直到 root）provider；如果没有找到 provider，会报错。\n如果要保证外部注入的服务是自己（当前 class）独有的（ 沙箱式隔离 ），只需在自己的元数据 providers 中列出 Service 即可（就能拥有自己独有的服务实例）。\n如果“允许依赖缺失”或者需要“限制依赖查找范围”，可以使用修饰符更改默认的依赖查找机制：\n@Host 表示禁止在“请求该依赖的组件”以上查找依赖； @Self 表示只在该组件的注入器中查找提供者，就是仅在 @Component({providers:[]}) 中查找，找不到就报错； @SkipSelf 表示跳过局部注入器，向上查找，与 @Self 相反； @Optional 表示找不到依赖就返回 null，即使找不到，也不报错。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 @Component({ /** * 如果不需要“独有”服务实例，就不需要 providers * 在每个 @Component({providers:[xxx]}) 中单独声明 * 每个 Component 就独享这个 Service 实例 */ providers: [ { provide: AaService, // 为 DI 令牌（依赖的标识）关联一个“固定的值” useValue: 123 }, { provide: BbService, // DI 令牌 /** * 为公共类/默认类换上一个“替代实现” * 令牌和注入内容不一定“同名” */ useClass: CcService // DI 内容 }, { provide: AliasService, /** * 为服务创建别名，提供了两种途径来访问同一服务对象 * 也可以用来“收窄/简化”BbService */ useExisting: BbService }, { provide: Example, // 通过“工厂函数”来创建依赖实例 useFactory: user =\u0026gt; { if (user.token) { return new SignUp(); } return new SignIn(); }, // 用于指定“工厂函数”所使用的依赖 deps: [User] }, DdService ] }) class ExampleComponent { constructor( @Inject(AaService) private aa: any, @SkipSelf() private bb: BbService, private eg: Example ) {} } 双向绑定 Angular 也有 Vue 中的 v-model 机制（modelValue/update:modelValue），语法为 [(value)]；实现思路同样也是基于“组件传值”和“自定义事件”（语法糖）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Component({ template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;app-input-model [(example)]=\u0026#34;exampleValue\u0026#34;\u0026gt;\u0026lt;/app-input-model\u0026gt;\u0026lt;span\u0026gt;{{ exampleValue }}\u0026lt;/span\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; }) class FormComponent { exampleValue = null; } @Component({ template: \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; [value]=\u0026#34;example\u0026#34; (input)=\u0026#34;handleInput($event)\u0026#34; /\u0026gt;\u0026#39;, selector: \u0026#39;app-input-model\u0026#39; }) class InputModelComponent { @Input() example; // 事件名称必须和 @Input 属性相对应，为 xxxChange @Output() exampleChange = new EventEmitter\u0026lt;any\u0026gt;(); handleInput(e) { // 官方文档中，在这里直接对 example 进行了修改，我表示不理解 this.exampleChange.emit(e.target.value); } } 绑定语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;my-component #component [@animation]=\u0026#34;animation\u0026#34; [(banana)]=\u0026#34;banana\u0026#34; [options]=\u0026#34;options\u0026#34; (output)=\u0026#34;onOutput($event)\u0026#34; (click)=\u0026#34;onClick()\u0026#34; \u0026gt;\u0026lt;/my-component\u0026gt; \u0026lt;!-- 如果你有强迫症的话，Ng 支持另一种模版语法 --\u0026gt; \u0026lt;my-component ref-component bind-animate-animation=\u0026#34;animation\u0026#34; bindon-banana=\u0026#34;banana\u0026#34; bind-options=\u0026#34;options\u0026#34; on-output=\u0026#34;onOutput($event)\u0026#34; on-click=\u0026#34;onClick()\u0026#34; \u0026gt;\u0026lt;/my-component\u0026gt; 模版变量 模版变量，顾名思义，就是存在于组件模版中的变量；模版变量可以引用：元素、指令、组件等：\n如果在组件上声明变量，该变量就会引用该组件实例； 如果在原生 HTML 标签上声明变量，该变量就会引用该元素； 如果你在 \u0026lt;ng-template/\u0026gt; 上声明变量，该变量就会引用一个 TemplateRef 实例； 如果该变量在右侧指定了一个名字（例如，#var=\u0026ldquo;ngModel\u0026rdquo;），该变量就会引用所在元素上具有这个 exportAs 名字的指令或组件。 1 2 3 4 5 6 7 8 \u0026lt;!-- # 声明了一个模版变量 phone --\u0026gt; \u0026lt;input #phone type=\u0026#34;text\u0026#34; placeholder=\u0026#34;phone number\u0026#34; /\u0026gt; \u0026lt;!-- button 通过模版变量获取到了 input 的 value --\u0026gt; \u0026lt;button (click)=\u0026#34;callPhone(phone.value)\u0026#34;\u0026gt;take a call\u0026lt;/button\u0026gt; \u0026lt;!-- 模版输入变量 --\u0026gt; \u0026lt;ng-template #heroRef let-hero let-i=\u0026#34;index\u0026#34; let-even=\u0026#34;!isOdd\u0026#34;\u0026gt; \u0026lt;span [class]=\u0026#34;{ \u0026#39;even-row\u0026#39;: even }\u0026#34;\u0026gt;{{ i }}: {{ hero.name }}\u0026lt;/span\u0026gt; \u0026lt;/ng-template\u0026gt; 模版变量可以在“包含此模板变量”的模板中的任何地方引用它；既然使用模版变量的前提是“包含此模板变量”，那么决定模版边界的“结构型指令（例如，ngIf、ngFor、\u0026lt;ng-template/\u0026gt;）”也决定了模版变量的作用域。\n网络请求 要使用 HttpClient，需要在模块中导入 HttpClientModule；一般情况下，在 AppModule 导入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import { BrowserModule } from \u0026#39;@angular/platform-browser\u0026#39;; import { HttpClientModule } from \u0026#39;@angular/common/http\u0026#39;; @NgModule({ providers: [ /** * HTTP_INTERCEPTORS 是 InjectionToken 实例 * 可以作为各个依赖项的唯一标识，方便依赖项被查找 * 当然，唯一标识不一定要是 InjectionToken 实例 * 可以被“唯一识别”就好，比如，NZ_I18N */ { provide: NZ_I18N, useValue: zh_CN }, /** * 使用一个 InjectionToken 初始化多个 provider * 酱紫就可以通过 @Inject(HTTP_INTERCEPTORS) 获取多个 provider * 如果 multi: false，后边的 provide 会覆盖前边的 provider */ { provide: HTTP_INTERCEPTORS, useClass: SpinInterceptor, multi: true }, { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true } ], imports: [BrowserModule, HttpClientModule], declarations: [AppComponent], bootstrap: [AppComponent] }) export class AppModule {} 发起 HTTP 请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import { HttpClient, HttpErrorResponse, HttpHeaders, HttpParams } from \u0026#39;@angular/common/http\u0026#39;; import { catchError, retry, throwError } from \u0026#39;rxjs/operators\u0026#39;; @Injectable({}) export class ApiService { /** * HttpClient 返回的 Observer 是“冷的”，不需要手动 unsubscribe * 请求成功时，会在 responseObserver.next 调用之后，调用 responseObserver.complete * 请求失败时，会调用 responseObserver.error */ constructor(private http: HttpClient) {} options = { // 自定义请求头 headers: new HttpHeaders({ \u0026#39;Content-Type\u0026#39;: \u0026#39;multipart/form-data\u0026#39;, Authorization: \u0026#39;au9mtPT3WwkDxfs\u0026#39; }), // 指定要返回的响应内容（联合类型：\u0026#39;body\u0026#39;|\u0026#39;events\u0026#39;|\u0026#39;response\u0026#39;） observe: \u0026#39;body\u0026#39; as const, // 查询参数，会被 encode 进 URL 中 params: new HttpParams({}), // 是否回报请求进度 reportProgress: true, // 指定返回数据的格式（联合类型：\u0026#39;arraybuffer\u0026#39;|\u0026#39;blob\u0026#39;|\u0026#39;json\u0026#39;|\u0026#39;text\u0026#39;） responseType: \u0026#39;json\u0026#39; as const, withCredentials: true }; getConfig(params) { return this.http .get(`${environment.apiHost}/api/v1`, { ...this.options, params }) .pipe( retry(3), // 如果请求失败，最多重复请求三次 catchError(this.handleError) // 错误处理函数 ); } updateConfig(body) { return this.http.post( `${environment.apiHost}/api/v1`, body /* 请求体 */, options /* 请求选项 */ ); } modifyConfig(body) { return this.http.put( `${environment.apiHost}/api/v1`, body /* 请求体 */, options /* 请求选项 */ ); } deleteConfig(params) { return this.http.delete(`${environment.apiHost}/api/v1`, { ...this.options, params }); } handleError(error) { if (error.status === 401) { // ... } return throwError(() =\u0026gt; error); } } 特殊标签 \u0026lt;ng-container/\u0026gt;，类似于 Vue 模版中的 \u0026lt;template/\u0026gt; 或者 React.Fragment；无实际意义，用来对模板片段按照展示逻辑进行分组：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- ng-container 最常使用的场景就是和 *ngFor 搭配 --\u0026gt; \u0026lt;nz-select\u0026gt; \u0026lt;ng-container *ngFor=\u0026#34;let item of branchList\u0026#34;\u0026gt; \u0026lt;nz-option *ngIf=\u0026#34;item.show\u0026#34; [nzValue]=\u0026#34;item.brabank_id\u0026#34; [nzLabel]=\u0026#34;item.brabank_name\u0026#34; \u0026gt;\u0026lt;/nz-option\u0026gt; \u0026lt;/ng-container\u0026gt; \u0026lt;/nz-select\u0026gt; \u0026lt;ng-template/\u0026gt;，用来定义（声明）模版片段；默认情况下，定义的模版片段不会直接渲染，需要指定渲染的位置；一般配合结构性指令使用：\n1 2 3 4 5 6 7 \u0026lt;!-- 当 seconds 被重置时，会条件渲染 #actionResendSMS 片段 --\u0026gt; \u0026lt;ng-container *ngIf=\u0026#34;seconds !== 0; else actionResendSMS\u0026#34;\u0026gt; \u0026lt;span\u0026gt;接受短信大约需要 {{ seconds }} 秒\u0026lt;/span\u0026gt; \u0026lt;/ng-container\u0026gt; \u0026lt;ng-template #actionResendSMS\u0026gt; \u0026lt;a (click)=\u0026#34;handleSendSMS()\u0026#34;\u0026gt;重新获取验证码\u0026lt;/a\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;ng-container/\u0026gt; 搭配 \u0026lt;ng-template/\u0026gt; 可以构造作用域插槽，实现逻辑与 UI 的分离，从而实现逻辑复用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 封装逻辑 @Component({ selector: \u0026#39;app-user-list-slot\u0026#39;, template: ` \u0026lt;ng-container *ngTemplateOutlet=\u0026#34;userListSlot; context: temp\u0026#34; \u0026gt;\u0026lt;/ng-container\u0026gt; ` }) class UserListSlotComponent implements OnChange { /** * 通过 userListSlot 指向一段 HTML 片段 * 可以使用 @ContentChild(TemplateRef) * 那样无需我们指定“投射内容” * 标签包含的所有 HTML * 都是“投射内容” */ @Input() userListSlot: TemplateRef\u0026lt;any\u0026gt;; @Input() formatFn = v =\u0026gt; v; @Input() groupId = null; @Output() updated = new EventEmitter(); temp = { loading: false, list: [] }; constructor(private apiService: ApiService) {} ngOnChanges(changes: SimpleChanges): void { if (changes?.groupId) { this.fetchUserList(); } } fetchUserList() { this.temp.loading = true; this.apiService .getUserList({ groupId: this.groupId }) .subscribe(({ success = false, data = [] }) =\u0026gt; { if (success) { this.temp.list = data.map(this.formatFn); } this.temp.list = []; this.temp.loading = false; this.updated.emit({ ...temp, originalData: data }); }); } } // 使用插槽 @Component({ template: ` \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; \u0026lt;app-user-list-slot [userListSlot]=\u0026#34;userListTemplate\u0026#34; [formatFn]=\u0026#34;userListFormatter\u0026#34; [groupId]=\u0026#34;groupId\u0026#34; (updated)=\u0026#34;(handleUserListUpdated)\u0026#34; \u0026gt; \u0026lt;ng-template #userListTemplate let-userList=\u0026#34;list\u0026#34; let-loadingUserList=\u0026#34;loading\u0026#34; \u0026gt; \u0026lt;nz-select [nzLoading]=\u0026#34;loadingUserList\u0026#34;\u0026gt; \u0026lt;nz-option [nzValue]=\u0026#34;option.id\u0026#34; [nzLabel]=\u0026#34;option.name\u0026#34; *ngFor=\u0026#34;let option of userList\u0026#34; \u0026gt;\u0026lt;/nz-option\u0026gt; \u0026lt;/nz-select\u0026gt; \u0026lt;/ng-template\u0026gt; \u0026lt;/app-user-list-slot\u0026gt; \u0026lt;div\u0026gt;...\u0026lt;/div\u0026gt; ` }) class DormitoryConfigureComponent { groupId = 21; userListFormatter = ({ id, name }) =\u0026gt; ({ id, name }); handleUserListUpdated({ originalData }) { console.log(originalData); } } \u0026lt;ng-content/\u0026gt;，使用在组件内部，可以使组件 “接受外部插入进来的内容” ，相当于 Vue 模版中的 \u0026lt;slot/\u0026gt;：\nAngular 中并没有“具名插槽”的概念，但是 \u0026lt;ng-content/\u0026gt; 有一个 select 属性（CSS 选择器，不支持变量），可以起到对外部插入的内容进行过滤的作用； 相比于 \u0026lt;router-outlet/\u0026gt;，\u0026lt;ng-content/\u0026gt; 展示的内容是由外部插入的，\u0026lt;router-outlet/\u0026gt; 展示的内容是由路由表指定的； 如果你的组件包含不带 select 属性的 \u0026lt;ng-content/\u0026gt; 元素，则该实例将接收所有与其他 \u0026lt;ng-content/\u0026gt; 元素都不匹配的投影组件。 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!-- 例如，nz-button 的 template --\u0026gt; \u0026lt;i nz-icon nzType=\u0026#34;loading\u0026#34; *ngIf=\u0026#34;nzLoading\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt; \u0026lt;!-- 使用时 --\u0026gt; \u0026lt;a nz-button\u0026gt;例子\u0026lt;/a\u0026gt; \u0026lt;!-- 渲染的结果，“例子”会被插入到 ng-content 当作 Vue 中的“具名插槽”理解就好 --\u0026gt; \u0026lt;a nz-button\u0026gt; \u0026lt;i nz-icon nzType=\u0026#34;loading\u0026#34; *ngIf=\u0026#34;nzLoading\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 例子 \u0026lt;/a\u0026gt; 特殊选择器 ::ng-deep、/deep/、\u0026gt;\u0026gt;\u0026gt;，将样式应用到全局；所以请在 ::ng-deep 之前带上 :host，防止污染全局样式； :host、:host(condition)，宿主元素选择器/当“宿主元素”满足 condition 时； :host-context(condition)，当“宿主的祖先元素”满足 condition 时。 ContentChild 与 ViewChild @ViewChild() 从当前组件模版中获取组件对象（Vue/React 中 ref 的功能）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Component({ selector: \u0026#39;user-list\u0026#39;, template: \u0026#39;\u0026lt;nz-spin\u0026gt;\u0026lt;form #form\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;user-detail\u0026gt;\u0026lt;/user-detail\u0026gt;\u0026lt;/nz-spin\u0026gt;\u0026#39; }) export class UserListComponent implements OnInit, AfterViewInit { @ViewChild(NzSpinComponent) nzSpinRef: NzSpinComponent; @ViewChild(\u0026#39;form\u0026#39;) formRef: ElementRef; ngOnInit() { // 在 ngOnInit 钩子中是获取不到的 console.log(this.nzSpinRef); // undefined console.log(this.formRef); // undefined } ngAfterViewInit() { // 通过 ViewChild 从当前模版中获取组件实例 console.log(this.nzSpinRef); console.log(this.formRef); } } @ContentChild() 从当前组件模版的外部投射进来的内容（类似 React 中的 props.children）中获取组件对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Component({ selector: \u0026#39;user-list\u0026#39;, template: \u0026#39;\u0026lt;user-detail\u0026gt;\u0026lt;span #span\u0026gt;用户交易\u0026lt;/span\u0026gt;\u0026lt;user-trade\u0026gt;\u0026lt;/user-trade\u0026gt;\u0026lt;/user-detail\u0026gt;\u0026#39; }) export class UserListComponent {} @Component({ selector: \u0026#39;user-detail\u0026#39;, template: \u0026#34;\u0026lt;h2\u0026gt;用户详情\u0026lt;/h2\u0026gt;\u0026lt;div class=\u0026#39;user-detail\u0026#39;\u0026gt;\u0026lt;ng-content\u0026gt;\u0026lt;/ng-content\u0026gt;\u0026lt;/div\u0026gt;\u0026#34; }) export class UserDetailComponent implements OnInit, AfterViewInit { @ContentChild(\u0026#39;span\u0026#39;) spanRef: ElementRef; @ContentChild(UserTradeComponent) userTradeRef: UserTradeComponent; ngOnInit() { // 在 ngOnInit 钩子中是获取不到的 console.log(this.spanRef); // undefined console.log(this.userTradeRef); // undefined } ngAfterViewInit() { // 从 ng-content 中获取组件/DOM 元素 console.log(this.spanRef); console.log(this.userTradeRef); } } 说明：\nContentChild 和 ViewChild 指向的类型不同（一个在当前模版中查找，一个在当前模版的外部投射内容中查找）； ViewChild 对应的是 ngAfterViewInit、ngAfterViewChecked； ContentChild 对应的是 ngAfterContentInit、ngAfterContentChecked； AfterView 关心的是 ViewChildren，ViewChildren 的元素标签会出现在当前组件的模版中； AfterContent 关心的是 ContentChildren，ContentChildren 被投射进当前组件中。 ChangeDetectorRef 首先，每个组件都有自己的变更检测器，一个应用包含多个组件，组件之间的层级关系形成了“组件树”。\nAngular 的默认检测机制是：当一个组件发生变更时，无论它在组件树的什么位置，都会触发树中的所有的变更检测器；Ng 会从“自顶向下”，扫描树所有节点。\nChangeDetectorRef 为组件实例提供了自定义变更检测功能，可以将组件从变更检测树中添加或删除；ChangeDetectorRef 提供了五个方法：\nmarkForCheck()，在 ChangeDetectionStrategy.OnPush 策略下，将视图标记为“需要变更检测”； detach()，将组件从变更检测树中删除，在 reattach 被调用之前，不会再进行变更检测； reattach()，将之前被 detach 的组件添加到变更检测树中； checkNoChanges()，对该视图及其子视图进行变更检测，如有变化，报异常（仅在开发环境有效）； detectChanges()，对该视图及其子视图手动进行一次变更检测。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class DataListProvider { get data() { // 假设数据量很大，并且变化频繁 return [1, 2, 3, 4, 5]; } } @Component({ template: ` \u0026lt;li *ngFor=\u0026#34;let item of dataProvider.data\u0026#34;\u0026gt;{{ item }}\u0026lt;/li\u0026gt; ` }) class GiantList { constructor( private ref: ChangeDetectorRef, public dataProvider: DataListProvider ) { // 放弃 Ng 的变更检测策略 ref.detach(); // 间隔 5 秒手动进行变更检测，提高应用性能 setInterval(() =\u0026gt; { this.ref.detectChanges(); }, 5000); } } 在开发的过程中，可能会遇到** NG100 错误 **，特别是在 ngAfterViewInit 钩子中执行“手动”渲染操作时；原因是，在开发模式下，每次\u0026quot;变更检测\u0026quot;后，都会执行一次\u0026quot;附加检查\u0026quot;，如果在附加检查过程中，视图和\u0026quot;变更检测\u0026quot;后的视图不一致，会报 NG100 错误。\n解决方法是，将同步渲染逻辑改为异步（宏任务、微任务均可），或者同步调用 detectChanges 重新进行变更检测。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @Component({ template: ` \u0026lt;ng-container #vcf\u0026gt;\u0026lt;/ng-container\u0026gt; ` }) export class CodesComponent implements OnInit, AfterViewInit { @ContentChild(TemplateRef) content: TemplateRef\u0026lt;any\u0026gt;; @ViewChild(\u0026#39;vcf\u0026#39;, { read: ViewContainerRef }) vcf; list: CodeItem[] = []; constructor(private cdf: ChangeDetectorRef) {} ngOnInit(): void { // ... } ngAfterViewInit() { this?.vcf?.createEmbeddedView(this.content, { handleChecked: (v, o) =\u0026gt; this.handleChecked(o), $implicit: this.list }); // 渲染完后，进行一次变更检测 this.cdf.detectChanges(); } // ... } Rx(ReactiveX)JS RxJS 是 ReactiveX 在 JS 中的实现，相似的还有 RxJava、RxSwift\u0026hellip;；ReactiveX 是 FRP（函数响应式编程）的践行者。\n操作符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 // 创建器，用来创建“流（数据序列）”，返回值是一个 Observable 对象 import { def, from, fromEvent, interval, of, range, timer } from \u0026#39;rxjs\u0026#39;; import { fromPromise } from \u0026#39;rxjs/internal/observable/fromPromise\u0026#39;; // 操作符，用来处理“流” import { buffer, bufferCount, bufferTime, catchError, combineLatest, concat, distinct, distinctUntilChanged, filter, finalize, first, forkJoin, last, map, merge, race, zip } from \u0026#39;rxjs/operators\u0026#39;; new Observable\u0026lt;any\u0026gt;((observer: Observer\u0026lt;any\u0026gt;) =\u0026gt; { setTimeout(() =\u0026gt; { // 任何时间，都可以通过 next 将值传入“流”中 observer.next(1000); }, 1000); }); /** * of 可以将“单一值”创建为“流” * “单一值”可以为任何数据类型 */ of(1, 2, 3, 4, 5) .pipe( filter(item =\u0026gt; item % 2 === 1), map(item =\u0026gt; item * 3) ) /** * 冷 Observable 必须被 subscribe 之后才会“产生”数据 * 如果没有 subscribe，之前的 pipe 就不会执行 * 所以，在 Angular 中，对同一接口多次 subscribe 会导致发起多次请求 * subscribe 表示“可观察对象”与“观察者”之间“建立了联系” */ .subscribe(item =\u0026gt; console.log(item)); // 3 9 15 // from 可以将数组的每一项放入“流”中 from([1, 2, 3, 4, 5]) .pipe( filter(item =\u0026gt; item % 2 === 1), map(item =\u0026gt; item * 3) ) .subscribe(item =\u0026gt; console.log(item)); // 3 9 15 // fromEvent 可以替代 addEventListener，是“热”的 const fromEvent$ = fromEvent(document.querySelector(\u0026#39;#title\u0026#39;), \u0026#39;click\u0026#39;); fromEvent$.subscribe(v =\u0026gt; console.log(v)); // PointerEvent // range 可以从“范围”产生“流” range(1, 5) .pipe( filter(item =\u0026gt; item % 2 === 1), map(item =\u0026gt; item * 3) ) .subscribe(item =\u0026gt; console.log(item)); // 3 9 15 const p = new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;Promise Begin...\u0026#39;); setTimeout(() =\u0026gt; resolve(\u0026#39;Promise Resolved...\u0026#39;), 1000); }); /** * fromPromise 接受一个 Promise 实例 * 当这个 Promise 状态确定之后，将输出值放入“流”中 * 即使没有 subscribe，这个 Promise 也会执行 * 从 6.0 开始，可以使用 from 替代 fromPromise */ fromPromise(p).subscribe(item =\u0026gt; console.log(item)); /** * defer 用来“惰性地”创建“流” * 他接受一个“产生流”的“工厂函数” * 当调用 defer 时，“流”还不存在，“流”会被“按需”创建 * 当“流”被“需要”的时候，才会调用“工厂函数”，产生“流” * 只要没有 subscribe，“工厂函数”就不会执行，Promise 也就不会执行 */ defer(() =\u0026gt; from(p)).subscribe(item =\u0026gt; console.log(item)); /** * timer(首次等待时间，重复间隔时间) 用来创建“定时器流” * 他创建的是一种“无尽流”（务必要在适当的时候取消订阅） * 数据会不断重复的被放入“流”中 * 有点像 setInterval */ timer(3000, 1000).subscribe(item =\u0026gt; console.log(item)); // 等待 3 秒：0 1 2 3... // interval（重复间隔时间），是 timer 的语法糖 interval(1000).subscribe(item =\u0026gt; console.log(item)); // 0 1 2 3... // first 操作符 from([0, 1, 2, 3]) .pipe(first(v =\u0026gt; v !== 0)) .subscribe({ next(v) { console.log(v); // 1 }, complete() { console.log(\u0026#39;complete\u0026#39;); } }); // last 操作符 from([0, 1, 2, 3]) .pipe(last(v =\u0026gt; v !== 0)) .subscribe({ next(v) { console.log(v); // 3 }, complete() { console.log(\u0026#39;complete\u0026#39;); } }); // distinct 操作符（过滤之前出现过的数据，去重作用） from([1, 2, 2, 3, 3, 3]) .pipe(distinct()) .subscribe({ next(v) { console.log(v); // 1, 2, 3 }, complete() { console.log(\u0026#39;complete\u0026#39;); } }); // distinctUntilChanged 操作符（过滤“上次”出现过的数据） from([2, 1, 2, 1, 3, 3, 3]) .pipe(distinctUntilChanged()) .subscribe({ next(v) { console.log(v); // 2, 1, 2, 1, 3 }, complete() { console.log(\u0026#39;complete\u0026#39;); } }); // combineLatest 操作符 const cl1 = new Subject(); const cl2 = new Subject(); // 一秒钟后，cl2 接收到值之后，打印 [\u0026#39;cl1\u0026#39;, \u0026#39;cl2\u0026#39;] combineLatest([cl1, cl2]).subscribe(v =\u0026gt; console.log(v)); cl1.next(\u0026#39;cl1\u0026#39;); setTimeout(() =\u0026gt; { cl2.next(\u0026#39;cl2\u0026#39;); }, 1000); // merge 操作符 const m1 = new Subject(); const m2 = new Subject(); const m3 = new Subject(); merge(m1, m2, m3).subscribe(v =\u0026gt; console.log(v)); // m3, m1 一秒钟后 m2 m3.next(\u0026#39;m3\u0026#39;); setTimeout(() =\u0026gt; { m2.next(\u0026#39;m2\u0026#39;); }, 1000); m1.next(\u0026#39;m1\u0026#39;); // zip 操作符，强调值的数量相同 const z1 = new Subject(); const z2 = new Subject(); zip(z1, z2).subscribe(v =\u0026gt; console.log(v)); z1.next(1); // 不打印 z1.next(2); // 不打印 z2.next(3); // [1, 3]，z1 和 z2 里值的数量相同，打印出 z1 和 z2 里的第一个值 z2.next(4); // [2, 4]，z1 和 z2 里值的数量相同，打印出 z1 和 z2 里的第二个值 // concat 操作符 const c1 = new Subject(); const c2 = new Subject(); concat(c1, c2).subscribe(v =\u0026gt; console.log(v)); c1.next(1); // 1 c2.next(2); // 不打印 c1.complete(); c2.next(3); // 3，c1 被 complete 之前，c2 的值被忽略 // forkJoin 操作符 const fj1 = new Subject(); const fj2 = new Subject(); forkJoin(fj1, fj2).subscribe(v =\u0026gt; console.log(v)); fj1.next(1); // 不打印 fj2.next(2); // 不打印 fj1.complete(); // 不打印 fj2.complete(); // [1, 2] // race 操作符 const r1 = new Subject(); const r2 = new Subject(); race(r1, r2).subscribe(v =\u0026gt; console.log(v)); r2.next(1); // 1 r1.next(2); // 不打印，r1 没有竞争过 r2 r2.next(3); // 3 r1.next(4); // 不打印 // catchError 操作符 new Observable(sub =\u0026gt; { sub.next(\u0026#39;normal\u0026#39;); // 会走到 subscribe sub.error(\u0026#39;error\u0026#39;); }) .pipe( catchError(error =\u0026gt; { console.log(error); // 只会打印 error return of(\u0026#39;catched\u0026#39;); // 会走到 subscribe }) ) .subscribe(v =\u0026gt; { console.log(v); // 先打印 normal 再打印 catched }); // buffer 操作符，收集输出值（缓冲区） interval(1000) .pipe(buffer(fromEvent(document, \u0026#39;click\u0026#39;))) .subscribe(v =\u0026gt; { /** * [0, 1, 2, 3] * [4, 5, 6, 7, 8, 9, 10] * ... */ console.log(v); }); // bufferCount 操作符，收集输出值 interval(1000) .pipe(bufferCount(3)) // 三个三个走 .subscribe(v =\u0026gt; { /** * [0, 1, 2] * [3, 4, 5] * ... */ console.log(v); }); // bufferTime 操作符，收集输出值 interval(1000) .pipe(bufferTime(3000, 1000)) .subscribe(v =\u0026gt; { /** * 等 3 秒 [0, 1] * 等 1 秒 [0, 1, 2, 3] * 等 1 秒 [2, 3, 4, 5] * ... */ console.log(v); }); // finalize 操作符 const f = new Subject(); f.pipe(finalize(() =\u0026gt; console.log(\u0026#39;finalize\u0026#39;))).subscribe(v =\u0026gt; console.log(v)); f.next(\u0026#39;next\u0026#39;); // next f.error(\u0026#39;error\u0026#39;); // finalize f.complete(); // finalize Observable 不同于创建器（调用后返回 Observable 对象），Subject 是一个实现了 Observable 接口的“类”；需要先进行 new 调用，然后将数据“手动”放入“流”中（subject.next(value)）。\n有别于普通的 Observable 对象（单播），new Subject 返回的是一个“多播”，可以被多次 subscribe，可以将值传递给多个观察者；所以常常被用来存放应用状态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import { Subject } from \u0026#39;rxjs\u0026#39;; const subject = new Subject\u0026lt;unknown\u0026gt;(); subject.subscribe((res: unknown) =\u0026gt; { console.log(\u0026#39;one\u0026#39;, res); }); subject.subscribe((res: unknown) =\u0026gt; { console.log(\u0026#39;two\u0026#39;, res); }); // 每个 subscribe 都收到新值 subject.next(1); // one 1, two 1 subject.next(2); // one 2, two 2 // 通过 subject 将 observable 转换为“多播” const observable = from([1, 2, 3]); observable.subscribe(subject); // one 1, two: 1 // one 2, two: 2 // one 3, two: 3 当 subscribe 被调用时，会返回一个“订阅凭证”；“订阅凭证”包含了一个 unsubscribe 方法，用来取消“订阅”（调用即可）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import { Observable, Subscription, interval } from \u0026#39;rxjs\u0026#39;; let temp = new Observable(o =\u0026gt; o.next(window.performance.now())); // 每次调用 subscribe 后生成了新的值，next 被调用了两次（数据产生于每次订阅后） temp.subscribe(value =\u0026gt; console.log(value)); // 4491799.400000002 temp.subscribe(value =\u0026gt; console.log(value)); // 4491799.699999999 // 执行顺序：2 -\u0026gt; 0 -\u0026gt; 3 -\u0026gt; 1 -\u0026gt; 4 -\u0026gt; 0 -\u0026gt; 5 -\u0026gt; 1 -\u0026gt; 6 const park = new Observable(subscriber =\u0026gt; { /** * 每次调用 subscribe 后，这个函数会重新执行 * 不会被放到微任务列表/下个事件循环 */ console.log(\u0026#39;0\u0026#39;); subscriber.next(); console.log(\u0026#39;1\u0026#39;); }); console.log(\u0026#39;2\u0026#39;); park.subscribe(() =\u0026gt; { console.log(\u0026#39;3\u0026#39;); }); console.log(\u0026#39;4\u0026#39;); park.subscribe(() =\u0026gt; { console.log(\u0026#39;5\u0026#39;); }); console.log(\u0026#39;6\u0026#39;); /** * subCollection.add * subCollection.remove * subCollection.unsubscribe */ const subCollection = new Subscription(); const observable1 = interval(400); const observable2 = interval(300); const subscription1 = observable1.subscribe(v =\u0026gt; console.log(v)); const subscription2 = observable2.subscribe(v =\u0026gt; console.log(v)); subCollection.add(subscription1); subCollection.add(subscription2); setTimeout(() =\u0026gt; { // 可以存起来，一起被取消 subCollection.unsubscribe(); }, 1000); “冷”与“热” “可观察对象”的分类：\n“冷”可观察对象，在 subscribe 之后，才将“值”添加到“流”中；有多少个订阅就会生成多少个订阅实例（单播，订阅接收到的值是相同的）； “热”可观察对象，在创建之后，立即产生了“值”；多个订阅共享同一个实例（多播，订阅接收到的值取决于什么时间开始订阅的）。 特殊的“可观察对象”：\nAsyncSubject，多播；需要初始值；只有当 complete 时，才会将“最后一个值”发送给订阅者； BehaviorSubject，多播；需要初始值；保存了发送出去的“最后一个值”，“新的”订阅者会接收到这个值； ReplaySubject，多播；需要初始值；保存了发送出去的“所有值”，“新的”订阅者会接收到所有“旧”值； Subject，多播；不需要初始值；不会保存之前的任何值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 import { AsyncSubject, EMPTY, Observable, Subject, throwError } from \u0026#39;rxjs\u0026#39;; const mySubject = new Subject\u0026lt;number\u0026gt;(); mySubject.next(10); mySubject.subscribe(v =\u0026gt; { /** * 因为 20 是 subscribe 才后放入流的 * 而 10 是 subscribe 才前放入流的 * 只会打印 20，没有接收到 10 */ console.log(v); }); mySubject.next(20); let outter = 0; const cold = new Observable(sub =\u0026gt; { outter++; let inner = 0; sub.next({ inner, outter }); }); cold.subscribe(v =\u0026gt; console.log(v)); cold.subscribe(v =\u0026gt; console.log(v)); const hot = new AsyncSubject(); setInterval(() =\u0026gt; { hot.next(Math.random()); }, 1000); setTimeout(() =\u0026gt; { /** * hot.complete 调用之后 * hot.error 和 hot.next 的调用将被忽略 */ hot.complete(); }, 2000); setTimeout(() =\u0026gt; { /** * hot.error 调用之后 * subscribe 拿不到最后一个值 * hot.complete 和 hot.next 的调用将被忽略 */ hot.error(Math.random()); }, 3000); hot.subscribe({ complete() { console.log(\u0026#39;complete\u0026#39;); }, error(e) { console.log(\u0026#39;error\u0026#39;, e); }, next(v) { /** * 只有 hot.complete 被调用 * subscribe.next 才能拿到最后一个值 */ console.log(\u0026#39;next\u0026#39;, v); } }); EMPTY.subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;只会触发 complete\u0026#39;) }); throwError(() =\u0026gt; \u0026#39;ERROR\u0026#39;).subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;只会触发 error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); xxxMap switchMap：会自动帮我们处理“竞态”；在第一个请求没有完成的情况下，发起第二个请求；第一个请求将被忽略； mergeMap：不会帮我们处理“竞态”；最终会使用哪个请求返回的结果，不一定；有可能新的请求使用旧的结果； exhaustMap：第一个请求没处理完成，就会忽略新的请求；只有第一个求请完成的情况下，才能处理新的请求； concatMap：开启队列，按顺序处理所有的请求及其副作用；不会丢弃老的/新的请求。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import { Subject, timer } from \u0026#39;rxjs\u0026#39;; import { mapTo, switchMap, mergeMap, concatMap, exhaustMap } from \u0026#39;rxjs/operators\u0026#39;; const sub = new Subject\u0026lt;string\u0026gt;(); function anyLongRunningOp(value: string) { return timer(Math.floor(Math.random() * 1000)).pipe(mapTo(value)); } function triggerEvents(operator: any) { sub .asObservable() .pipe(operator(value =\u0026gt; anyLongRunningOp(value))) .subscribe(value =\u0026gt; console.log(\u0026#39;Got:\u0026#39;, value)); sub.next(\u0026#39;First\u0026#39;); sub.next(\u0026#39;Second\u0026#39;); } /** * concatMap 会开启一个队列，保存每一个传入的值以及对应的操作 * 当第一个值 First 走完所有流程之后，才会开始处理 Second * 所以结果是： * 若干秒之后，打印 Got: First * 又若干秒之后，打印 Got: Second */ triggerEvents(concatMap); /** * exhaustMap 只关心传入的第一个值 First，并忽略后续传入的所有值 * 除非第一个值的流程已经走完，第二个值才传入 * 所以结果是： * 若干秒之后，打印 Got: First，Second 这个值被丢弃 * 如果 Second 是在若干秒之后才传入的，此时 First 流程已经走完 * 那么，会打印 Got:Second */ triggerEvents(exhaustMap); /** * mergeMap 不会等待上次流程的结束 * 他会同时处理传入的所有值 * 并且不保证顺序与传入顺序 * 所以结果是： * 若干秒之后，同时打印出 Got:First、Got:Second * 至于哪个在前，哪个在后，不确定 */ triggerEvents(mergeMap); /** * 如果第二个值 Second 在两秒之内传给 switchMap * switchMap 会丢弃对第一个值 First 的处理 * 所以结果是： * 若干秒之后，只会打印 Got: Second * First 这个值被丢弃 */ triggerEvents(switchMap); filter 与 takeWhile 1 2 3 4 5 6 7 8 9 10 11 import { of } from \u0026#39;rxjs\u0026#39;; import { takeWhile, filter } from \u0026#39;rxjs/operators\u0026#39;; const source = of(3, 3, 3, 9, 1, 4, 5, 8, 96, 3, 66, 3, 3, 3); // takeWhile 遇到不满足条件的数据，就 complete source .pipe(takeWhile(it =\u0026gt; it === 3)) .subscribe(val =\u0026gt; console.log(\u0026#39;takeWhile\u0026#39;, val)); // 3 3 3 // filter 遇到不满足条件的数据，过滤掉，没有 complete source .pipe(filter(it =\u0026gt; it === 3)) .subscribe(val =\u0026gt; console.log(\u0026#39;filter\u0026#39;, val)); // 3 3 3 3 3 3 3 first 与 take(1) 当 first 可以从数据流中取得一个值的时候，等同于 take(1)； 当 first 不能从数据流中取得一个值的时候，会直接抛错误，而 take(1) 不会。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import { EMPTY, range } from \u0026#39;rxjs\u0026#39;; import { first, take } from \u0026#39;rxjs/operators\u0026#39;; // first 遇上 EMPTY 打印 error EMPTY.pipe(first()).subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); // 打印 next complete range(1, 5) .pipe(first()) .subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); // 不满足条件，打印 error range(1, 5) .pipe(first(val =\u0026gt; val \u0026gt; 5)) .subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); // take(1) 遇上 EMPTY 打印 complete EMPTY.pipe(take(1)).subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); // 打印 next complete range(1, 5) .pipe(take(1)) .subscribe({ next: () =\u0026gt; console.log(\u0026#39;next\u0026#39;), error: () =\u0026gt; console.log(\u0026#39;error\u0026#39;), complete: () =\u0026gt; console.log(\u0026#39;complete\u0026#39;) }); AOT 与 JIT 组件和模版需要经过编译，才能在浏览器中运行；Angular 提供了两种编译方式：\nAhead-Of-Time 预编译（在打包/构建时编译，Angular 9 之后）： 和别的模版一样，*.vue 和 *.jsx 也需要进行编译才能在浏览器中运行； 可以尽早地检测到代码中的错误，用户体验更有保障； 省去了在运行时编译的开销，应用响应更快； 减少了受 XSS 攻击的风险； 可以减小应用的体积。 Just-In-Time 即时编译（在运行时编译，Angular 9 之前）： 代码修改之后不需要重新编译，编译会在代码执行之前进行（按需编译）； 编译工作大多在浏览器内部进行，编译时间更短； 在项目中，较少被用到的组件更适合即时编译。 AOT 预编译分为三个阶段：\n代码分析：收集元数据并检验元数据中的错误： 被收集的元数据存在于类装饰器/构造函数中； AOT 收集器会根据 TS 编译器生成的 *.d.ts 输出 *.metadata.json； *.metadata.json 包括了全部装饰器的元数据，结构就像 AST 一样； AOT 编译器不支持“箭头函数”，所以不要在元数据中使用“() =\u0026gt; {}”。 代码生成：解释元数据（*.metadata.json），并对含有 useClass、useValue、useFactory 和 data 的对象字面量进行特殊处理（元数据重写）； 模版类型检查：TS 编译器会验证模版中绑定的表达式。 JIT 编译器可以替代 AOT 编译器，在“运行时”将模板编译（需要将 compiler 打包）为浏览器中的可执行模板代码。\n安全 为了防范 XSS，Angular 认为所有值都是不可信任的；任何值在插入 DOM 之前，都会被进行“无害化”处理（前提是使用 Angular 模版，如果在代码中直接使用 DOM API，将没有“无害化”处理）。\nAngular 定义了四个安全上下文：\nHTML：被解释为 HTML 的值，例如被绑定到 innerHTML 的值； CSS：作为 CSS 被绑定到 style 属性的值； 网址：作为 URL 使用的值，例如被绑定到 a 标签 href 属性的值； 资源：作为代码需要被下载并运行的值，例如被绑定到 script 标签 src 属性的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Component({ template: ` \u0026lt;!-- {{ 插值中的内容总会被“无害化”}} --\u0026gt; \u0026lt;p class=\u0026#34;e2e-inner-html-interpolated\u0026#34;\u0026gt;{{ htmlSnippet }}\u0026lt;/p\u0026gt; \u0026lt;!-- 绑定到 innerHTML 属性上的值，默认被认为是“不安全”的 会被自动进行“无害化” \u0026lt;script\u0026gt; 会被移除 --\u0026gt; \u0026lt;p class=\u0026#34;e2e-inner-html-bound\u0026#34; [innerHTML]=\u0026#34;htmlSnippet\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; ` }) export class InnerHtmlComponent { htmlSnippet = \u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;...\u0026#34;)\u0026lt;/script\u0026gt;\u0026lt;b\u0026gt;Syntax\u0026lt;/b\u0026gt;\u0026#39;; } 如果某个值被确认是可信的，可以通过 DomSanitizer 将这个值标记为安全值，安全的值将不会被进行“无害化”。\nDomSanitizer 提供了六种方法：\nsanitize(context, value)：根据给定的安全上下文 context，对 value 进行“无害化”； bypassSecurityTrustHtml(value)：信任给定的值 value 是一个安全的 HTML； bypassSecurityTrustStyle(value)：信任给定的值 value 是一个安全的样式； bypassSecurityTrustScript(value)：信任给定的值 value 是一个安全的 JS； bypassSecurityTrustUrl(value)：信任给定的值 value 是一个安全的 URL； bypassSecurityTrustResourceUrl(value)：信任给定的值 value 是一个安全的资源。 1 2 3 4 5 6 7 8 9 10 11 12 13 @Component({ template: ` \u0026lt;h4\u0026gt;自动无害化处理\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a [href]=\u0026#34;dangerousUrl\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;h4\u0026gt;不会进行无害化处理\u0026lt;/h4\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a [href]=\u0026#34;trustedUrl\u0026#34;\u0026gt;Click Me\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; ` }) export class BypassSecurityTrustComponent { constructor(private sanitizer: DomSanitizer) {} dangerousUrl = \u0026#39;javascript:alert(\u0026#34;Hello\u0026#34;)\u0026#39;; trustUrl = this.sanitizer.bypassSecurityTrustUrl(this.dangerousUrl); } 参考 Improved Dependency Injection With The New ProvidedIn Scopes \u0026lsquo;any\u0026rsquo; And \u0026lsquo;platform\u0026rsquo; Simplified Explanation of switchMap, concatMap, mergeMap, and exhaustMap 深入理解 Angular 依赖注入（二）：依赖注入在 Angular 中的应用 Angular Change Detection：变更检测策略 What Is AOT And JIT Compiler In Angular? ng-template、ng-content、ng-container 使用 ng-content 进行组件内容投射 viewProviders vs providers Cold vs Hot Observables RxJS 快速入门 ","date":"2022-03-16T00:00:00Z","image":"https://vikingama.github.io/img/cover/angular.png","permalink":"https://vikingama.github.io/p/angular-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/","title":"Angular 快速上手"},{"content":"前置知识 CSS/CSS3 长度、时间、频率、角度单位大全 CSS 值类型文档大全 CSS 全局关键字属性值：\ninherit，继承属性值； initial，CSS 语法中规定的初始值，不是浏览器内置样式的初始值； unset，对于有继承性的属性，等同于 inherit；对于没有继承性的属性，等同于 initial，常常（all:unset）酱紫使用； revert，还原为浏览器内置样式。 all 指代除了自定义属性（还有 unicode-bidi 和 direction）之外的所有 CSS 属性：\ninitial，无实际价值； inherit，无实际价值； unset，让元素的样式表现和 span 一样； revert，让元素恢复成浏览器内置样式。 @supports 是用来检测当前浏览器是否支持某个 CSS 新特性的最规范、最正统的处理方法（当然，没 IE 什么事）：\n浏览器提供了相应的 JS 接口 CSS.supports(propertyName, value)； @supports 规则的花括号可以包含其他任意 @ 规则，甚至是包含 @supports 规则自身。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* 支持弹性布局 */ @supports (display: flex) { /* 可以嵌套其他规则 */ @media screen and (max-width: 720px) { div { /* ... */ } } } /* 不支持弹性布局 */ @supports not (display: flex) { /* 可以嵌套 @supports 自身 */ @supports (animation: none) { span { /* ... */ } } } /* 同时支持弹性布局和网格布局 */ @supports (display: flex) and (display: grid) { /* 可以嵌套 @keyframes */ @keyframes hahaha { from { /* ... */ } to { /* ... */ } } } /* 支持弹性布局或者支持网格布局 */ @supports (display: flex) or (display: grid) { /* ... */ } 总之，Web 开发是没有必要让所有浏览器都显示得一模一样的；好的浏览器有更好的显示，糟糕的浏览器就只有普通的显示；这才是对用户更负责任的做法。\nwidth:fit-content fit-content 的样式表现就是 CSS2.1 规范中的 shrink-to-fit，称其为包裹性；尺寸收缩但不会超出包含块级元素的尺寸限制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;style\u0026gt; p { background: red; color: white; } /* 字数少时居中显示，字数多时左对齐显示 */ p \u0026gt; .table-span { display: table; margin: auto; background: blue; } p \u0026gt; .fit-content { display: block; margin: auto; width: fit-content; background: green; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span class=\u0026#34;table-span\u0026#34;\u0026gt;Ribeye tail rump tenderloin chislic venison.\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;fit-content\u0026#34;\u0026gt;Ribeye tail rump tenderloin chislic venison.\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; \u0026lt;span class=\u0026#34;table-span\u0026#34;\u0026gt; Flank chuck biltong, beef tenderloin tri-tip andouille alcatra cow ball tip. Ribeye short ribs tail short loin, capicola pork belly landjaeger ham drumstick salami flank. \u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;fit-content\u0026#34;\u0026gt; Flank chuck biltong, beef tenderloin tri-tip andouille alcatra cow ball tip. Ribeye short ribs tail short loin, capicola pork belly landjaeger ham drumstick salami flank. \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; fit-content 的优点：让元素有了确定的尺寸；从此，让元素上下左右都居中有了一种新的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;style\u0026gt; .fit-content-to-center { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; /* 不必再借用 transform 属性了，减小了过渡动画的计算量 */ width: fit-content; height: fit-content; } \u0026lt;/style\u0026gt; \u0026lt;span class=\u0026#34;fit-content-to-center\u0026#34;\u0026gt; Ribeye tail rump tenderloin chislic venison. \u0026lt;/span\u0026gt; stretch、available 和 fill-available 的作用都是一致的，那就是让元素的尺寸自动填满可用空间，就如同 div 元素的默认尺寸表现：\nstretch，弹性拉伸，用于替换之前的 fill-available 和 available； available，可用空间，Firefox 使用的关键字，需要配合 -moz- 前缀使用； fill-available，填充可用空间，Webkit 使用的关键字，需要配合 -webkit- 前缀使用。 所以，使用时应该酱紫写 CSS：\n1 2 3 4 5 6 /* 其实，在实际开发中，用处不大 */ .element { width: -webkit-fill-available; width: -moz-available; width: stretch; } min-content 与 max-content min-content 即首选最小宽度或者最小内容宽度。\n元素由 content-box、padding-box、border-box 和 margin-box 组成，元素最终占据的尺寸由这 4 个盒子占据的尺寸决定。其中 padding-box、border-box 和 margin-box 的尺寸表现规则不会因为元素的不同而有所不同，但是 content-box 不一样，它随着内容的不同，首选最小宽度也会不同：\n替换元素（按钮、视频和图片等元素）的首选最小宽度是当前元素内容自身的宽度； CJK 文字（中文、日文、韩文）： 一段没有标点的中文文字的首选最小宽度是单个汉字的宽度； 一段中文文字包含避头标点（，。？、！）或避尾标点（前引号、前括号），同时 line-break 的属性值不是 anywhere，首选最小宽度需要包含标点字符的宽度。 非 CJK 文字（英文、数字和标点等）的首选最小宽度是由字符单元（所有连续的英文字母、数字和标点都是一个字符单元，直到遇到中断字符）的宽度决定的； 一个元素最终的首选最小宽度是所有内部子元素中最大的那个首选最小宽度值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;style\u0026gt; button, span { display: inline-block; width: min-content; outline: 1px solid black; } \u0026lt;/style\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;Button\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;大大大小小小\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;AaBbCcDdEe\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;1234567890\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;他于 1999 年在香港科技大学（下称港科大）任职期间创立了固高科技...\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt; Pork belly fatback picanha, capicola t-bone rump ham strip steak brisket. \u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;1-2-34567-8-9-00000000\u0026lt;/span\u0026gt; 在实际开发中是不会使用 min-content 关键字的，但是会非常频繁地遇到 min-content 的表现场景。\nmax-content 表示最大内容宽度；作用是让元素尽可能大，保证图文内容在一行显示，哪怕最终的宽度溢出外部容器元素。\n所有需要使用 max-content 的场景，都能使用 white-space:nowrap 实现一模一样的效果，并且兼容性更好；所以，实际上 max-content 没有任何实用价值。\nposition:sticky 黏性定位效果底层的渲染规则和固定定位没有任何关系，而是相对定位的延伸：\n元素发生偏移的时候，元素的原始位置是保留的； 创建了新的绝对定位包含块，如果有绝对定位的子元素，那这个子元素是相对于当前黏性定位元素的； 支持设置 z-index 来改变元素的层叠顺序； 黏性定位是相对于层级最近的可滚动元素（overflow 不是 visible 的元素）；如果没有可滚动元素，则相对视口定位； 当多个粘性元素发生重叠时，会有 A 元素推开 B 元素的视觉表现，而不是相互堆叠。 黏性定位中有一个流盒的概念，指的是黏性定位元素最近的可滚动元素的尺寸盒子，如果没有可滚动元素，则表示视口盒子。\n黏性定位中还有一个名为黏性约束矩形的概念，指的是黏性定位元素的包含块在文档流中呈现的矩形区域和流盒的 4 个边缘在应用黏性定位元素的 left、top、right 和 bottom 属性的偏移计算值后的新矩形的交集。\n滚动的时候流盒不变，而黏性定位元素的包含块跟着滚动，因此黏性约束矩形随着滚动的进行是实时变化的。假设黏性定位元素只设置了 top，则黏性定位元素碰到黏性约束矩形的顶部时就开始向下移动，直到它完全被包含在黏性约束矩形中。\n如果多个黏性定位元素在同一容器中，则这几个黏性定位元素会产生元素重叠的情况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;style\u0026gt; * { margin: 0; padding: 0; border: none; } body { height: 300vh; } .line { position: fixed; top: 15vh; width: 100vw; border-top: 1px dashed palevioletred; } .container { outline: 1px solid white; margin: 30vh auto 0; width: 60vw; height: 50vh; } p { position: sticky; top: 15vh; border: 1px solid aquamarine; text-align: center; color: aquamarine; font-size: 18px; } p:first-of-type { text-align: left; } p:last-of-type { text-align: right; } \u0026lt;/style\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 如果黏性定位元素分布在不同的容器中，同时这些容器在布局上是上下紧密相连的，则视觉上会表现为新的黏性定位元素挤开原来的黏性定位元素，形成依次占位的效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;style\u0026gt; * { margin: 0; padding: 0; border: none; } body { height: 300vh; } .line { position: fixed; top: 15vh; width: 100vw; border-top: 1px dashed palevioletred; } .container { outline: 1px solid white; margin: 30vh auto 0; width: 60vw; height: 50vh; } p { position: sticky; top: 15vh; border: 1px solid aquamarine; text-align: center; color: aquamarine; font-size: 18px; } section { height: 100px; } section:first-of-type p { text-align: left; } section:last-of-type p { text-align: right; } \u0026lt;/style\u0026gt; \u0026lt;span class=\u0026#34;line\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;section\u0026gt;\u0026lt;p\u0026gt;1\u0026lt;/p\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;\u0026lt;p\u0026gt;2\u0026lt;/p\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;section\u0026gt;\u0026lt;p\u0026gt;3\u0026lt;/p\u0026gt;\u0026lt;/section\u0026gt; \u0026lt;/div\u0026gt; 上一个黏性定位元素被滚走，下一个黏性定位元素正好开始有黏性效果。\nfont-family 全新的通用字体族：\nsystem-ui，系统 UI 字体： 使用系统字体不再需要 font:menu、font:status-bar，因为 menu、status-bar、small-caption 关键字是包含字号的； font-family:system-ui 就可以使得字体设置随着系统字体变动。 emoji，用于 emoji 字符的字体家族： Apple Color Emoji，用在 iOS 和 macOS 中； Segoe UI Emoji，用在 Windows 中； Segoe UI Symbol，Windows 7 中添加的一种新字体，一种 Unicode 编码字体，显示的是单色图案，非彩色图形； Noto Color Emoji，用在 Android 和 Linux 中。 math，用于数学表达式的字体家族： Cambria Math，Windows 中的数学字体； Latin Modern Math，macOS 中的数学字体。 fangsong，中文字体中的仿宋字体家族，一般用于非常正式的公告。 GitHub 的字体设置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;pre\u0026gt; body { /* 这里的字体设置遗漏了 Roboto 字体 Roboto 是为 Android 设计的一款无衬线字体 可以在 Android 上以最佳的西文字体显示 */ font-family: /* 只在 macOS 中有效 system-ui 字体族还没出现之前的一种私有语法 可以让 Firefox 和 Safari 9.1～10.1 使用系统字体 */ -apple-system, /* 只在 macOS 中有效 Chrome 53～55 使用系统字体的一种非标准语法 可以删掉了 */ BlinkMacSystemFont, /* 不支持系统字体的浏览器兜底用的 Windows 从 Vista 开始默认的西文字体族 */ \u0026#39;Segoe UI\u0026#39;, /* 不支持系统字体的浏览器兜底用的 macOS 和 iOS 中很常用的一款无衬线字体 */ Helvetica, /* 不支持系统字体的浏览器兜底用的 全平台都支持的一款无衬线字体 */ Arial, sans-serif, /* emoji 字体 此处同样遗漏了 Android 的 emoji 字体 */ \u0026#39;Apple Color Emoji\u0026#39;, \u0026#39;Segoe UI Emoji\u0026#39;; } \u0026lt;/pre\u0026gt; 最佳 CSS 字体设置实践：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* @font-face 定义的字体只有在被使用的时候才会加载 */ @font-face { font-family: Emoji; src: local(\u0026#39;Apple Color Emoji\u0026#39;), local(\u0026#39;Segoe UI Emoji\u0026#39;), local( \u0026#39;Segoe UI Symbol\u0026#39; ), local(\u0026#39;Noto Color Emoji\u0026#39;); unicode-range: U+1F000-1F644, U+203C-3299; } /* 最佳无衬线字体 */ body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Emoji, Helvetica, Arial, sans-serif; } /* 最佳衬线字体 */ .font-serif { font-family: Georgia, Cambria, \u0026#39;Times New Roman\u0026#39;, Times, serif; } /* 最佳等宽字体 */ .font-mono { font-family: Menlo, Monaco, Consolas, \u0026#39;Liberation Mono\u0026#39;, \u0026#39;Courier New\u0026#39;, monospace; } /* math 通用字体 */ math { font-family: Cambria Math, Latin Modern Math; } font-display 字体显示时间线开始于浏览器尝试下载字体的那一刻，整个时间线分为 3 个时段，每个时段有不同的字体渲染行为：\n字体阻塞时段，如果未加载字体，任何试图使用它的元素都必须以不可见的方式渲染后备字体；如果在此期间字体成功加载，则正常使用它； 字体交换时段，如果未加载字体，任何试图使用它的元素都必须以可见的方式渲染后备字体；如果在此期间字体成功加载，则正常使用它； 字体失败时段，如果未加载字体，则浏览器将其视为加载失败，并使用正常字体进行回退渲染。 font-display 就是围绕字体显示时间线展开的；共有五个属性值：\nauto，字体显示策略由浏览器决定； block，字体阻塞时段较短，字体交换时段无限；适合图标字体场景； swap，字体阻塞时段极短（不超过 100ms），字体交换时段无限；适合用在小段文本同时文本内容对页面非常重要的场景； fallback，字体阻塞时段极短（不超过 100ms），字体交换时段较短；适合用于大段文本同时对字体效果比较看重的场景； optional，字体阻塞时段极短（不超过 100ms），没有字体交换时段；如果字体瞬间被加载（被缓存），则浏览器使用该字体，否则使用回退字体；日常 Web 开发更推荐。 font-display 属性只能用在 @font-face 规则中；如果你的自定义字体是用于字体呈现，就使用 optional，否则使用默认值。\n中断与换行 字符单元默认的中断与换行规则：\nSpace（普通空格）、Enter（回车）和 Tab（制表符）无论怎样组合都会合并为单个普通空格； 文字可以在 CJK 文本、普通空格和短横线连字符处换行，连续英文单词和数字不换行。 word-break:keep-all 可以让 CJK 文本不换行排版，同时又不影响非 CJK 文本的排版行为。\nhyphens 是专为英文场景设计的一个 CSS 属性，可以让英文单词断开换行的时候带上连字符。\n\u0026lt;wbr/\u0026gt; 表示有机会就断开换行（如果宽度足够就不换行）；而 \u0026lt;br/\u0026gt; 则是直接换行显示，无论宽度是否足够。\ntext-decoration text-decoration 是一个缩写属性：\ntext-decoration-line，装饰线类型： none； underline； overline； line-through。 text-decoration-style，装饰线风格： solid； double； dotted； dashed； wavy。 text-decoration-color，装饰线颜色； text-decoration-thickness，装饰线粗细。 text-decoration 最有意思的特性要数装饰线的累加特性了：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; div { text-decoration: overline wavy orangered 1px; } p { text-decoration: underline dotted tomato 2px; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Burgdoggen shank picanha beef ribs capicola pastrami.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Tongue ribs filet shoulder short loin pancetta salami.\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; text-underline-position:(under|left|right|from-font) 可以用来设置下划线的位置。\ntext-underline-offset 也可以用来设置下划线的位置（只对下划线类型的装饰线有效），其偏移量支持数值和百分比值。\ncolor 不是所有人都知道的一些知识：\nHTML 中 color 算法和 CSS 中的 color 算法是不一样的；无法识别的颜色在 HTML 中会渲染成另外一个颜色，而在 CSS 中会忽略这个颜色； 颜色关键字设置的颜色都是实色，不带透明度； 颜色关键字不区分大小写； 所有颜色关键字中，只有两个颜色是以“deep”开头的，分别是深天蓝色 deepskyblue 和深粉色 deeppink； 暗灰色 darkgray 要比灰色 gray 更浅，并不是有“dark”前缀的颜色就更深； transparent 其实是 rgba(0, 0, 0, 0) 的另外一种快捷书写方式； SVG 和 Canvas 中的透明渐变算法与 CSS 的渐变算法不一致。 HSL 颜色很适合用在颜色变化的场合：\nHue，色调，可以是小数： 0 ～ 360deg 大致按照红、橙、黄、绿、青、蓝、紫、红的颜色顺序分布； red = 0deg、green = 120deg、blue = 240deg。 Saturation，饱和度，0% ～ 100%； Lightness，亮度，0% ～ 100%。 background-clip background-clip 支持下面几个属性值：\nborder-box，默认值，背景图像或者背景颜色的显示区域是整个 border-box，边框的下方也会显示背景内容； padding-box，背景图像或者背景颜色的显示区域是整个 padding-box； content-box，背景图像或者背景颜色的显示区域是整个 content-box； text，可以让背景图像按照字符形状进行剪裁。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;style\u0026gt; div { float: left; display: flex; justify-content: center; align-items: center; margin: 8px; padding: 20px; width: 150px; height: 150px; background-color: cornflowerblue; border: 20px dashed darksalmon; outline: 1px solid black; } div:nth-of-type(1) { background-clip: border-box; } div:nth-of-type(2) { background-clip: padding-box; } div:nth-of-type(3) { background-clip: content-box; } div:nth-of-type(4) { -webkit-background-clip: text; background-clip: text; color: transparent; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;background-clip: border-box;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;background-clip: padding-box;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;background-clip: content-box;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;background-clip: text;\u0026lt;/div\u0026gt; box-shadow 多边框效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; .multi-border { margin: 40px auto; width: 60%; height: 80px; border-radius: 10px; background-color: dodgerblue; box-shadow: 0 0 0 4px white, 0 0 0 8px #fc9918, 0 0 0 12px #f14a16, 0 0 0 16px #35589a, 0 0 0 20px #370665, 0 0 0 24px #121212, 0 0 0 28px #30475e, 0 0 0 32px #f05454; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;multi-border\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; transform CSS 中的角度单位：\ndeg，角度，一个完整的圆是 360deg； grad，百分度，一个完整的圆是 400grad； rad，弧度，一个完整的圆是 2πrad； turn，圈数，一个完整的圆是 1turn。 元素 transform 之后的变化：\n创建层叠上下文； 子元素 position:fixed 失效； transform 不为 none 的元素也可以作为绝对定位元素的包含块。 卷角投影效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;style\u0026gt; html { display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #666; transform: scale(1); } .page { position: relative; width: 300px; height: 200px; background-color: #f4f39e; box-shadow: 0 2px 10px 1px rgba(0, 0, 0, 0.2); border-bottom-right-radius: 50% 10px; } .page::before, .page::after { content: \u0026#39;\u0026#39;; position: absolute; width: 90%; height: 30%; z-index: -1; } .page::before { left: 15px; bottom: 12px; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); transform: skew(-15deg) rotate(-5deg); } .page::after { right: 15px; bottom: 25px; box-shadow: 8px 8px 10px rgba(0, 0, 0, 0.4); transform: skew(15deg) rotate(8deg); } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; zoom 的属性值：\n百分比值，50%，表示缩小到原来的一半； 数值，0.5，表示缩小到原来的一半； normal，等同于 1，默认值； reset，表示按 Ctrl− 或 Ctrl+ 进行文档缩放的时候，元素不跟着缩小与放大。 zoom 和 transform:scale 的区别：\nzoom 是一个非标准属性； zoom 缩放的中心坐标是相对于元素的左上角，且不能修改；transform:scale 缩放默认的中心坐标是元素的中心点； zoom 缩放会实时改变元素占据的尺寸空间； zoom 不会创建层叠上下文，不会使子元素 position:fixed 失效，不会改变绝对定位元素的包含块。 min、max 和 clamp min(expression [, expression]) 支持一个或多个表达式，每个表达式之间使用逗号分隔，然后将最小的表达式的值作为返回值；例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 div { width: min(10vw, 5em, 80px); width: min(10px * 10, 10em); width: min(calc(10px * 10), 10em); width: min(10px * 10, var(--width)); } .constr { width: 1024px; max-width: 100%; } .constr { width: min(1024px, 100%); } clamp 的作用是返回一个区间范围的值，clamp(MIN-最小值，VAL-首选值，MAX-最大值)：\n如果 VAL 在 MIN ～ MAX 范围内，则使用 VAL 作为函数返回值； 如果 VAL 大于 MAX，则使用 MAX 作为返回值； 如果 VAL 小于 MIN，则使用 MIN 作为返回值。 渐变 CSS 渐变本质上是一个图像，无法使用 transition 实现过渡效果，也无法使用 animation 实现动画效果。\n渐变角度和渐变方位关系：0deg 表示向上，顺时针旋转是正角度，所以 90deg 表示向右。\n变换 3D 变换相关的三个属性：\ntransform-style ，设置元素的子元素是位于 3D 空间（preserve-3d）中还是平面（flat）中； perspective ，指定观察者与 z=0 平面的距离，使具有三维位置变换的元素产生透视效果； perspective-origin ，指定观察者的位置，用作 perspective 属性的消失点； backface-visibility ，指定当元素背面朝向观察者时是否可见。 DEMO， 旋转的骰子 。\n动画 @keyframes 规则中的 CSS 优先级是最高的；因此，没有必要在 @keyframes 中使用 !important 关键字。\nanimation-direction 可以用来控制动画的方向，其本质上是通过控制 @keyframes 规则中定义的动画关键帧执行的方向来实现的：\nnormal，每个动画循环结束，动画重置到起点重新开始；[0-\u0026gt;100%, 0-\u0026gt;100%, 0-\u0026gt;100%, \u0026hellip;]； alternate，下一轮动画的执行方向和上一轮动画的执行方向相反；[0-\u0026gt;100%, 100%-\u0026gt;0, 0-\u0026gt;100%, \u0026hellip;]； reverse，每一轮动画执行的方向相反；[100%-\u0026gt;0, 100%-\u0026gt;0, 100%-\u0026gt;0, \u0026hellip;]； alternate-reverse，[100%-\u0026gt;0, 0-\u0026gt;100%, 100%-\u0026gt;0,\u0026hellip;]。 animation-fill-mode 动画填充模式，主要用来定义动画在执行时间之外应用的值：\nnone，表示动画开始之前和动画结束之后不会对元素应用 @keyframes 规则中定义的任何样式，可能会有『突变』的糟糕体验； both，让元素的动画在延时等待时保持第一帧的样式，在动画结束后保持最后一帧的样式，适用于绝大多数的开发场景； forwards，表示动画结束后（由 animation-iterationcount 属性决定），元素将应用当前动画结束时的属性值； backwards，表示在动画开始之前，元素将应用当前动画第一轮播放的第一帧的属性值。 animation-timing-function 支持两种缓动函数，cubic-bezier 和 steps；steps 函数用法为 steps(number, position)：\nnumber，指数值，且是整数值，表示把动画分成了多少段； position，可选参数，指关键字属性值，表示动画跳跃执行是在时间段的开始还是结束： start，在时间段的开头处跳跃（直接开始，也就是时间段才开始，就已经执行了一个距离段）； end，默认值，在时间段的结束处跳跃（戛然而止，也就是时间段一结束，当前动画执行就停止）； jump-both，动画开始时和结束时都不发生跳跃，然后中间部分等分跳跃； jump-none，动画开始时和结束时都发生跳跃； jump-start，同 start； jump-end，同 end。 分栏布局 分栏布局相关的 CSS 属性：\ncolumns，column-width 和 column-count 的缩写；最终分栏的数量要么由 column-count 决定，要么由 column-width 决定： columns:18em，这里指代 column-width； columns:2|auto，这里指代 column-count。 column-width，表示每一栏/列的最佳宽度（不支持百分比），是一种期望尺寸，实际渲染宽度多半和指定的宽度是有出入的： 几乎不存在分栏布局的栏目宽度就是 column-width 设置的宽度这样的场景。 column-count，表示理想的分栏数目，最终的分栏数目可能不受 column-count 的控制； column-gap，表示每一栏之间的空白间隙的大小，可以是长度值，也可以是百分比值； column-rule，设置各个分栏的分隔线样式，是 column-rule-color、column-rule-style 和 column-rule-width 的缩写： column-rule-color，分隔线颜色； column-rule-style，分隔线样式； column-rule-width，分隔线粗细。 column-span，表示某一个内容是否跨多栏显示，作用在分栏布局的子元素上： none，表示不横跨多栏，默认值； all，表示横跨所有垂直列。 column-fill，当内容分栏的时候平衡每一栏填充的内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; .container { columns: 100px; column-rule: 3px solid olivedrab; outline: 1px solid black; } .content { border: 3px solid orangered; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; Boudin meatloaf pork belly biltong swine pig flank sirloin. Cow corned beef biltong andouille prosciutto. Salami shoulder turducken filet mignon sausage hamburger flank kielbasa kevin swine. Ham capicola short loin tongue shankle. Pork chuck short ribs, chicken rump pork chop fatback tail bresaola boudin. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 弹性布局 display:flex 发生了什么？\n弹性子项（包括匿名内联元素）都是块级元素； 弹性子项浮动失效； 弹性子项（即使 position:static）支持 z-index，如果 z-index 不为 auto，会创建新的层叠上下文； 弹性子项的 margin 不会合并； 弹性子项的尺寸是经过精确计算的，可以使用 margin:auto 对剩余空间进行分配； 弹性子项如果被设置为绝对定位，则会脱离弹性布局。 匿名内联元素会变为匿名块级元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .container { display: flex; } .content { margin: 30px; float: right; } \u0026lt;/style\u0026gt; \u0026lt;!-- 这里的 2 就是『匿名内联元素』 在弹性容器中，2 变成了『匿名块级元素』 --\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; 2 \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;script\u0026gt; const contentEle = document.querySelector(\u0026#39;.content\u0026#39;); // float 的计算属性值还是为 right，但没有 float 行为 console.log(window.getComputedStyle(contentEle).float); \u0026lt;/script\u0026gt; margin:auto 可以达到和 justify-content:space-between 一样的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .container { display: flex; } .space-between { justify-content: space-between; } .content { outline: 1px solid black; } \u0026lt;/style\u0026gt; \u0026lt;h3\u0026gt;margin: auto\u0026lt;/h3\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34; style=\u0026#34;margin: auto\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;h3\u0026gt;justify-content: space-between\u0026lt;/h3\u0026gt; \u0026lt;section class=\u0026#34;container space-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 绝对定位的子项会脱离弹性布局。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;style\u0026gt; .container { display: flex; } .space-between { justify-content: space-between; } .content { width: 21px; outline: 1px solid black; } .content:first-of-type { position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container space-between\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt; 1 \u0026lt;br /\u0026gt; 1 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; align-items 与 align-self 的区别：\nalign-items 设置在弹性容器上（负责所有子项），align-self 设置在弹性子项上（负责某一子项）； align-items 初始值是 normal，而在弹性布局中，align-items 初始值是 stretch； align-self 初始值是 auto，表示子项的垂直对齐方式由弹性容器上的 align-items 控制。 flex 是 flex-grow、flex-shrink 和 flex-basis 的简写：\nflex-grow ，弹性容器在主轴方向上剩余空间多余时分配规则；默认 0，表示不分配； flex-shrink ，弹性容器在主轴方向上剩余空间不足时分配规则；默认 1，表示分配； flex-basis ，空间分配的基础尺寸；作用在 content-box 上，默认 auto； flex:initial，等同于 flex:0 1 auto，不抢多余空间，可以在空间不足时收缩； flex:auto，等同于 flex:1 1 auto，子项自动拉伸/收缩来填满剩余空间，在容器尺寸不足时会优先最大化内容尺寸； flex:none，等同于 flex:0 0 auto，子项没有弹性，子项表现为最大内容宽度； flex:1，等同于 flex:1 1 0%，子项自动拉伸/收缩来填满剩余空间，在容器尺寸不足时会优先最小化内容尺寸； flex:0，等同于 flex:0 1 0%，子项没有弹性，子项表现为最小内容宽度。 flex:0 和 flex:none 的区别：\nflex:1 和 flex:auto 的区别：\n弹性容器中，子项的最终尺寸是基础尺寸、弹性拉伸/收缩、最大/小尺寸共同作用的结果：\n最终尺寸的计算优先级是：最大/小尺寸\u0026gt;弹性拉伸/收缩\u0026gt;基础尺寸； 基础尺寸由 flex-basis 或 width，以及 box-sizing 共同决定； 当没有设置基础尺寸时，最大内容宽度会顶替基础尺寸的角色； 弹性增长指的是 flex-grow，弹性收缩指的是 flex-shrink； 最大尺寸主要受 max-width 限制；最小尺寸则受最小内容宽度、width 和 min-width 共同影响。 网格布局 网格布局的默认布局和块布局非常类似，就是简单地从上往下依次垂直排列。\n显式网格：在规定容器内显示的网格。 隐式网格：多于设置的单元格数量的 grid 子项，或者是在设定的网格范围之外出现 grid 子项。\n作用于 grid 容器上的 CSS 属性：\ngrid-template-columns，用来指定网格的列的数量和尺寸，支持长度值、百分比值、min/max-content、auto、fr 值、函数值； grid-template-rows，用来指定网格的行的数量和尺寸，支持的数据类型同 grid-template-columns： min-content，一排/列格子中所有最小内容尺寸中最大的那个最小内容尺寸值； max-content，一排/列格子中所有最小内容尺寸中最大的那个最大内容尺寸值； auto，max-content 是固定的尺寸，auto 会受到 justify-content 和 align-content 的影响： 当多列的宽度同时设置为 auto 的时候，这些列的宽度并不相同，而是在 max-content 的基础上增加同样大小的尺寸。 fr（fraction）值，表示自动分配列（有些列的宽度就由页面自动分配）的尺寸划分比例： auto 的尺寸划分是随着内容变化的，内容多则尺寸大，内容少则尺寸小；而 fr 就是纯粹按比例计算，与内容多少无关； 如果所有 fr 值之和大于 1，则按 fr 值的比例划分可自动分配的尺寸； 如果所有 fr 值之和小于 1，最终的尺寸是可自动分配的尺寸和 fr 值的乘积。 repeat()，不直接参与尺寸设置，更像一种简化代码的语法形式； minmax(min, max) ，表示尺寸范围限制在 min ～ max 范围内； fit-content(limit)，尺寸由内容决定，内容越多尺寸越大，但不超过设定的 limit 尺寸。 grid-template-areas，用来指定网格区域的划分，网格区域一定要形成规整的矩形区域；无论是 L 形还是凹的或凸的形状都会认为是无效的属性值； grid-template，前面三种属性的缩写； grid-column-gap，推荐使用 column-gap 替代，垂直间隙； grid-row-gap，推荐使用 row-gap 替代，水平间隙； grid-gap，推荐使用 gap 替代，grid-column-gap 和 grid-row-gap 的缩写； justify-items，用来定义元素在网格中的水平对齐表现： stretch，元素水平尺寸拉伸，填满整个网格的水平空间； start，元素的水平尺寸收缩为内容大小，同时沿着网格线左侧对齐显示； end，元素的水平尺寸收缩为内容大小，同时沿着网格线右侧对齐显示； center，元素的水平尺寸收缩为内容大小，同时在当前网格区域内部水平居中对齐显示。 align-items，用来定义元素在网格中的垂直对齐表现： 和 justify-items 类似，区别就在于方向不同。 place-items:\u0026lt;align-items\u0026gt; \u0026lt;justify-items\u0026gt;?，以上两个属性的简写； justify-content，指定了网格元素整体水平方向上的分布对齐方式； align-content，指定了网格元素整体垂直方向上的分布对齐方式； place-content:\u0026lt;align-content\u0026gt; \u0026lt;justify-content\u0026gt;?，以上两个属性的简写； grid-auto-columns，用来控制隐式网格的尺寸； grid-auto-rows，用来控制隐式网格的尺寸； grid-auto-flow:[row 或者 column]||dense，用来定义子项目元素的自动流动状态，非常类似于弹性布局中的 flex-direction： row，默认值，表示没有指定位置的网格在水平（行）方向上自然排列，这也是为什么网格布局会优先水平排列； cow，表示没有指定位置的网格在垂直（列）方向上自然排列； dense，如果稍后出现的网格比较小，则尝试看看其前面有没有合适的地方放置该网格，使网格尽可能排列紧凑。 grid，是多个 CSS 属性的缩写集合： grid:none，设置所以子属性为初始值； 如果没有隐式网格，且无须改变网格布局的自然流向，则当做 grid-template 来使用； 如果出现隐式网格，或者需要改变网格布局的自然流向，则使用下面两种形式： grid:\u0026lt;grid-template-rows\u0026gt;/[auto-flow \u0026amp;\u0026amp; dense?]\u0026lt;grid-auto-columns\u0026gt;?； grid:[auto-flow \u0026amp;\u0026amp; dense?]\u0026lt;grid-auto-rows\u0026gt;?/\u0026lt;grid-template-columns\u0026gt;。 grid-template-columns/rows 的用法和简写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;style\u0026gt; .container { display: grid; /* grid-template-rows: 25% 100px auto 60px; */ /* grid-template-columns: 80px auto 100px; */ /* grid-template: 25% 100px auto 60px / 80px auto 100px; */ grid: 25% 100px auto 60px / 80px auto 100px; } .content { display: flex; justify-content: center; align-items: center; outline: 1px solid olivedrab; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;9\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;10\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;11\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;12\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; fr 值的计算方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;style\u0026gt; .container1 { display: grid; grid-template-columns: 1.1fr 1.1fr 1.1fr; } .container2 { margin: 30px 0 0; display: grid; grid-template-columns: 0.3fr 0.2fr 0.1fr; } .content { display: flex; justify-content: center; align-items: center; height: 30px; outline: 1px solid olivedrab; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section class=\u0026#34;container2\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; grid-template-areas 的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;style\u0026gt; .container { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); grid-template-areas: \u0026#39;蛙 蛙 蛙\u0026#39; \u0026#39;虾 鱼 鱼\u0026#39; \u0026#39;虾 鱼 鱼\u0026#39; \u0026#39;蟹 蟹 蟹\u0026#39;; gap: 8px; } .content { display: flex; justify-content: center; align-items: center; height: 30px; outline: 1px solid orchid; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蛙\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蛙\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蛙\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;虾\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;鱼\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;鱼\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;虾\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;鱼\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;鱼\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蟹\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蟹\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;蟹\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 隐式网格：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;style\u0026gt; .container { display: grid; grid-template: 1fr 1fr / 1fr 1fr; /* 隐式网格高度为 50px */ grid-auto-rows: 50px; gap: 8px; } .content { display: flex; justify-content: center; align-items: center; outline: 1px solid orchid; } \u0026lt;/style\u0026gt; \u0026lt;section class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;!-- 之后的都属于隐式网格 --\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; grid-auto-flow 类似 flex-direction，控制着网格的排列流向：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;style\u0026gt; .container { display: grid; grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr; gap: 8px; } .row { grid-auto-flow: row; } .column { grid-auto-flow: column; } .content { display: flex; justify-content: center; align-items: center; outline: 1px solid; } .row .content { outline-color: orchid; } .column .content { outline-color: olivedrab; } \u0026lt;/style\u0026gt; \u0026lt;h3\u0026gt;grid-auto-flow: row\u0026lt;/h3\u0026gt; \u0026lt;section class=\u0026#34;container row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;h3\u0026gt;grid-auto-flow: column\u0026lt;/h3\u0026gt; \u0026lt;section class=\u0026#34;container column\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;content\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 作用于 grid 子项上的 CSS 属性：\ngrid-column-start/end，grid 子项所占据的行的起止范围； grid-row-start/end，grid 子项所占据的列的起止范围，参数可以为整数（不为 0）、也可以为网格线名称： 整数，表示起止于第几条网格线，可以是负整数（从右侧开始计数网格线）； 当浏览器找不到网格线时，会自动补全 -start/-end 后缀，继续寻找网格线； span3，表示当前网格会自动跨越 3 个网格； span \u0026lt;name\u0026gt;，表示当前网格会自动扩展，直到选中指定的网格线名称； auto，默认值，默认跨度是 1 个格子。 grid-column，grid-column-start/end 的缩写属性； grid-row，grid-row-start/end 的缩写属性； grid-area，grid-column/row-start/end 四个属性的缩写，有两种属性值： \u0026lt;area-name\u0026gt;，由 grid-template-area 创建的区域名称； \u0026lt;row-start\u0026gt;/\u0026lt;column-start\u0026gt;/\u0026lt;row-end\u0026gt;/\u0026lt;column-end\u0026gt;，占据网格区域的行列起止位置。 justify-self，设置单个网格元素的水平对齐方式； align-self，设置个网格元素的垂直对齐方式； place-self，\u0026lt;align-self\u0026gt; \u0026lt;justify-self\u0026gt;?。 Shapes 布局 Shapes 需要 float 的配合，可以实现不规则的图文环绕效果；其相关的 CSS 属性有 3 个：shape-outside、shape-margin、shape-image-threshold。\nshape-outside 支持的属性值：\nnone，普通矩形环绕； content/padding/border/margin-box，指定文字环绕时，依照哪个盒子的边缘进行计算； 形状函数（circle 圆、ellipse 椭圆、inset 矩形、polygon 多边形）； 图片类型（URL 链接、渐变、函数图像等）。 shape-margin 的作用是控制文字环绕图形时文字与元素边界的距离；因为在 Shapes 布局中，文字环绕有时候是无视 margin 属性的。其有效数值范围是 0 ~ 浮动元素边界，当属性值超过浮动元素边界的时候，布局效果如同普通浮动布局效果，没有不规则的图形环绕效果。\nshape-image-threshold 指图像环绕时候的半透明阈值，默认是 0.0，也就是图像透明度为 0 的区域边界才能被文字环绕；如果属性值是 0.5，则表示透明度小于 0.5 的区域都可以被文字环绕。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;style\u0026gt; .shape { float: left; width: 60px; height: 60px; padding: 20px; margin: 20px; border: 20px solid peru; background-color: cornflowerblue; background-clip: content-box; border-radius: 50%; outline: 1px solid red; } \u0026lt;/style\u0026gt; \u0026lt;section\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34; style=\u0026#34;shape-outside: none\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34; style=\u0026#34;shape-outside: content-box\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34; style=\u0026#34;shape-outside: padding-box\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34; style=\u0026#34;shape-outside: border-box\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;section\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34; style=\u0026#34;shape-outside: margin-box\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; 当 shape-outside 的属性值为图片类型（必须是同域名下）时，浏览器会解析图片的透明和非透明区域；默认情况下，文字会沿着非透明区域的边缘排列：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;style\u0026gt; .shape { float: left; width: 452px; height: 222px; background-color: currentColor; color: red; shape-outside: url(/css-last/whale.png); -webkit-mask: url(/css-last/whale.png) no-repeat; mask: url(/css-last/whale.png) no-repeat; } \u0026lt;/style\u0026gt; \u0026lt;span class=\u0026#34;shape\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;div\u0026gt; Buffalo boudin ham bresaola short ribs jowl leberkas ball tip jerky bacon ribeye swine picanha landjaeger brisket. Kevin shankle spare ribs tenderloin. Kevin tongue tail swine sausage, turkey t-bone picanha. Brisket venison jerky tongue biltong. Drumstick cow pig picanha frankfurter ground round, pork belly brisket rump jowl meatloaf. Andouille bresaola burgdoggen spare ribs hamburger drumstick prosciutto ball tip tri-tip short loin chicken meatloaf swine strip steak flank. \u0026lt;/div\u0026gt; 媒体查询 @media 查询的规则由 4 部分组成：媒体查询修饰符、媒体类型、媒体条件、媒体特征。\n媒体查询修饰符：\nonly，本身没有任何效果，主要是为了兼容过时的浏览器； not，否定整个查询语句。 媒体类型：\nscreen，屏幕输出设备上生效； print，打印（预览）时生效； all，匹配所有设备。 媒体条件：\nnot，否定某个媒体特征； and，同时满足； or，满足之一。 媒体特征：\naspect-ratio，输出设备可视区域的宽度和高度的比例（可能受软键盘的影响）； width，设备的宽度的查询与匹配； height，设备的高度的查询与匹配； orientation，判断设备是横屏还是竖屏（可能受软键盘的影响）： landscape，横屏状态； portrait，竖屏状态。 display-mode，Web 应用的显示模式： fullscreen：全屏显示，没有任何浏览器部件； browser：在浏览器中打开，是浏览器的一个标签页； standalone：如同独立的应用程序，有独立的窗口，有自己的程序启动图标，没有导航元素，但是会有状态栏； minimal-ui：如同独立的应用程序，但有一个用来导航的最小 UI 元素集，具体有什么元素在不同浏览器中是不一样的。 any-hover，是否有任意输入设备可以经过某个元素： none，没有输入装置可以实现悬停效果； hover，可以触发元素的悬停交互效果。 hover，主输入设备是否可以经过某个元素，例如，是否连接了鼠标； any-pointer，是否有任意输入设备可以触控操作，以及如果可以触控操作，精度应为多少： none，没有可用的点击设备； coarse，至少有一个设备的点击不是很精确（例如，手指点击）； fine，有点击很精准的设备（例如，鼠标）。 pointer，主输入设备是否可以触控操作，以及如果可以触控操作，精度应为多少： none，主输入装置点击不可用； coarse，主输入装置点击不精确； fine，主输入装置点击很精准。 prefers-color-scheme，用来检测用户是否使用了深色模式： no-preference，系统没有告知使用的颜色方案； light，系统当前使用了浅色模式； dark，系统当前使用了深色模式。 prefers-reduced-motion，用来检测用户是否配置了没有必要的动画选项（类似于 iOS 中的『减弱动态效果』）： no-preference，用户没有通知系统任何首选项； reduced，用户已通知系统，需要减弱动态效果。 网页快速适配深色模式：\n1 2 3 4 5 6 7 8 9 10 /* 这种『偷懒的技巧』在 Safari 中可能有渲染问题 */ @media (prefers-color-scheme: dark) { body { filter: invert(1) hue-rotate(180deg); } img { /* 对于图片元素，需要进行反向操作 */ filter: invert(1) hue-rotate(180deg); } } 当用户关闭系统动画时，页面可以同步减少动画效果：\n1 2 3 4 5 6 @media (prefers-reduced-motion) { * { animation: none; transition: none; } } image-set image-set 类似于 HTML 中的 srcset 属性，可以根据屏幕的像素密度来显示相应的背景图。\n1 2 3 4 5 6 7 .example { background-image: image-set( url(origin.png) 1x, url(origin-2x.png) 2x, url(origin-print.png) 600dpi ); } 变量与自定义属性 CSS 变量的声明由 CSS 自定义属性及其对应的值组成；CSS 变量的使用是通过变量函数 var() 调用 CSS 自定义属性实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 不支持包含 $、[、]、^、(、)、%、\u0026#34; 等特殊字符的命名 要使用这些特殊字符，需要使用反斜杠转义 */ :root { --primary-color: blue; --俄乌: 10px; /* CJK 文字 */ ---: orange; /* 短横线 */ --1: red; /* 数字 */ --: green; /* 空格 */ } section { background-color: var(--1); border: var(--俄乌) solid var(---); color: var(--primary-color); outline: var(--俄乌) solid var(--); } var() 的第二个参数可以用来设置缺省值，当且仅当第一个参数解析无效时才起作用：\n1 2 3 4 5 6 7 8 9 10 11 12 body { --color: 20px; background-color: black; /* 由于第一个参数 --color 是可以呗正常解析的 所以 red 这个缺省值会被忽略 显然背景色 20px 是不合法的 所以会被解析为初始值 transparent */ background-color: var(--color, red); } CSS 自定义属性是有作用域的，所以全局使用的自定义属性都定义在 :root 伪类中。\nCSS 自定义属性不支持在媒体查询的查询条件中使用，也不支持 content 属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 :root { --maxWidth: 666px; --percent: 60%; } /* 不可以，没用 */ @media (max-width: var(--maxWidth)) { body { font-size: 21px; } } /* 无效 */ body::after { content: var(--percent); } 在 HTML 中的使用：\n1 2 3 \u0026lt;div style=\u0026#34;--color: pink;\u0026#34;\u0026gt; \u0026lt;span style=\u0026#34;outline: 1px solid var(--color);\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 在 JS 中使用（需要借助 style 的 setProperty/getPropertyValue 方法）：\n1 2 3 4 const divEle = document.querySelector(\u0026#39;div\u0026#39;); divEle.style.setProperty(\u0026#39;--color\u0026#39;, \u0026#39;blue\u0026#39;); // 赋值 divEle.style[\u0026#39;--color\u0026#39;] = \u0026#39;blue\u0026#39;; // 无效 window.getComputedStyle(divEle).getPropertyValue(\u0026#39;--color\u0026#39;); // 取值 object-fit 替换元素的内在尺寸适用于外部指定的尺寸，这就导致两个问题：\n外部指定的尺寸和内在尺寸有可能宽高比例不相符； 资源加载完毕之前，内在尺寸是 0；加载完毕之后，可能导致页面重绘。 object-fit 就是为了解决这些问题的（有点像 background-size），其属性值有 5 个：\nfill，默认值，替换内容会填满 content-box，不保持内在比例； contain，替换内容在 content-box 中完整显示，保持内在比例； cover，替换内容会覆盖 content-box，保持内在比例并可能会让替换内容部分区域不可见； none，替换内容显示为原始比例，无视外部尺寸限制；显示区域会大量留白（原始内容尺寸较小）或者被裁剪（原始内容尺寸较大）； scale-down，替换内容尺寸为较大时，表现为 contain；尺寸较小时，表现为 none。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;style\u0026gt; section { display: flex; flex-wrap: wrap; } div { width: 50vw; height: 50vw; box-sizing: border-box; padding: 10px; border: 10px solid palevioletred; outline: 1px solid cadetblue; } img { width: 100%; height: 100%; } \u0026lt;/style\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: fill\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: contain\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: cover\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: none\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: scale-down\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;avatar.png\u0026#34; style=\u0026#34;object-fit: scale-down\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; object-position 是一个使用场景比较少的属性，用于控制替换内容在替换元素中的位置（有点像 background-position）；初始值为 50% 50%，居中效果。\nimage-orientation 可以让浏览器识别图片 Exif 信息中的 Orientation 值来对图片方向进行修正：\nfrom-image，初始值，如果包含 Orientation，则对图片方向进行纠正； none，不对图片方向进行纠正。 filter filter 支持 10 个滤镜函数：\nblur(5px)，模糊，不支持百分比，其参数值可以理解为屏幕上互相融合的像素数量，会有边缘泛白的问题； brightness(2.4)，亮度，支持百分比，参数范围是 0 到无穷大，默认参数为 1； contrast(200%)，对比度，支持百分比，参数范围是 0 到无穷大，默认参数为 1； drop-shadow(x 偏移，y 偏移，模糊大小，色值)，投影； grayscale(50%)，灰度，可以实现去色效果（特殊节日灰掉网页），让彩色值变为灰度值，支持百分比，参数范围是 0 到无穷大，默认参数为 0； hue-rotate(90deg)，色调旋转，保持饱和度和亮度不变； invert(75%)，反相，亮度和色调同时反转，支持百分比，参数范围是 0 到无穷大； opacity(25%)，透明度，效果和 opacity 类似，两种属性同时使用，效果会叠加； saturate(230%)，饱和度，支持百分比，参数范围是 0 到无穷大； sepia(60%)，褐色，支持百分比，参数范围是 0 到无穷大。 以上的滤镜效果是可以叠加的。\nbox-shadow 和 filter:drop-shadow() 的区别：\nfilter:drop-shadow 没有内投影； filter:drop-shadow 没有扩散半径； filter:drop-shadow 不支持投影叠加； filter:drop-shadow 符合真实世界的表现。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; section { display: flex; flex-wrap: wrap; justify-content: center; } div { margin: 8px 0 16px; width: 80vw; height: 50vw; padding: 10px; background-color: transparent; box-sizing: border-box; border: 10px dashed palevioletred; } \u0026lt;/style\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div style=\u0026#34;box-shadow: 5px 5px 8px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;filter: drop-shadow(5px 5px 8px)\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; backdrop-filter 和 filter 语法相似，可以轻松实现毛玻璃效果；他们的区别是，backdrop-filter 是让当前元素所在区域后面的内容应用滤镜效果，需要当前元素是半/完全透明的；filter 是让当前元素自身应用滤镜效果。\n混合模式 CSS 中有 3 个混合模式相关的属性：\nmix-blend-mode，元素与元素之间的混合； isolation，应用于祖先元素，限制 mix-blend-mode： auto，默认值，混合模式隔离与否根据具体情况而定； isolate ，对混合模式进行隔离（通过创建新的层叠上下文）。 background-blend-mode，混合元素背景图案、渐变和颜色。 background-blend-mode 和 mix-blend-mode 支持的混合模式是一致的：\nnormal，正常； multiply ，正片叠底，混合后颜色变暗； screen ，滤色，效果和 multiply 正好相反，混合后颜色变亮； overlay ，叠加，根据下层元素色值和 128 的大小，采用“multiply”或“screen”算法； darken，变暗，将两种颜色的 RGB 通道值依次进行比较，哪个色值小就使用哪个色值； lighten ，变亮，将两种颜色的 RGB 通道值依次进行比较，哪个色值大就使用哪个色值；； color-dodge，颜色变淡，混合区域的对比度降低； color-burn，颜色加深，混合区域的对比度提升； hard-light，强光，亮的地方更亮，暗的地方更暗； soft-light ，柔光，效果同“hard-light”，只是没那么极端； difference ，差值，最终颜色的色值是用较浅颜色的色值减去较深颜色的色值的结果； exclusion ，排除，对比度要比“difference”低一些； hue，色调混合，将颜色混合，使用底层元素的亮度和饱和度，以及上层元素的色调； saturation，饱和度混合，混合后的颜色保留底图的亮度和色调，并使用顶图的饱和度； color ，颜色混合，混合后的颜色保留底图的亮度，并使用顶图的色调和饱和度； luminosity，亮度混合，混合后的颜色保留底图的色调和饱和度，并使用顶图的亮度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; /* 模拟晚上的场景 */ .normal { float: left; width: 400px; height: 300px; background-color: rgba(0, 40, 140, 0.6); background-image: url(normal.jpg); background-size: cover; } .night { background-blend-mode: darken; filter: brightness(80%) grayscale(20%) contract(1.2); } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;normal\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;normal night\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 遮罩效果 mask-image，设置使用遮罩效果的图像：\nnone，默认值，表示无遮罩图片； 图像数据类型，包括 CSS 渐变、url()、image-set()、cross-fade()、element() 等； 遮罩元素类型，主要指 SVG 遮罩元素。 mask-mode（Chrome 不支持），设置遮罩模式：\nmatch-source，默认值，根据资源类型自动采用合适的遮罩模式； luminance，基于亮度判断是否要进行遮罩； alpha，基于透明度判断是否要进行遮罩。 mask-composite，同时使用多张图片进行遮罩时的合成方式：\nadd，默认值，遮罩累加，并集； substract，遮罩相减，多张遮罩图片的重合区域不显示遮罩，遮罩图片越多，遮罩区域越小； intersect，遮罩相交，多张遮罩图片的重合区域才显示遮罩，交集； exclude，遮罩排除，多张遮罩图片的重合区域被当作透明的。 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;style\u0026gt; .mask-image { width: 400px; height: 400px; /* mask-* 属性和 background-* 属性很像 */ -webkit-mask-size: contain; -webkit-mask-repeat: no-repeat; -webkit-mask-position: center center; /* 需要是透明背景的图片 */ -webkit-mask-image: url(\u0026#39;./whale.png\u0026#39;); } \u0026lt;/style\u0026gt; \u0026lt;img src=\u0026#34;husky.jpg\u0026#34; class=\u0026#34;mask-image\u0026#34; alt=\u0026#34;二哈\u0026#34; /\u0026gt; 滚动行为 scroll-behavior 属于交互渐进增强型的属性：\nauto，初始值，不常用； smooth，使滚动行为变得平滑。 overflow-behavior(-x/y) 用于设置元素“滚动到边缘（滚动条触顶/底）”时的行为：\nauto，默认值，内部元素滚动到边缘时触发外部元素滚动； contain，内部元素滚动到边缘时，触发“反弹”效果，滚动行为不会“冒泡”到外部； none，相比于 contain，少了“反弹”效果，差异主要体现在移动端。 overflow-anchor，滚动锚定；当内容突然出现时，浏览器自动改变滚动高度，使的可视区域的内容不被“冲走”，就像滚动被锚定了一样：\nauto，是否“锚定”由浏览器决定； none，禁止“锚定”。 滚动吸附 当元素滚动结束时，自动定位到“指定”位置（当超过一定阈值的时候），有点类似于“ 吸附 ”的效果。\n其中作用在“滚动容器”上的属性有：\nscroll-snap-type，确定定位方式是“水平”还是“垂直”滚动定位： none，默认值，滚动时忽略“指定”位置； x，捕捉“水平”定位点； y，捕捉“垂直”定位点； block，捕捉和块状元素排列一个滚动方向的定位点，默认文档流下指的就是“捕捉垂直定位点”； inline，捕捉和内联元素排列一个滚动方向的定位点，默认文档流下指的就是“捕捉水平定位点”； both，“水平”和“垂直”均捕获； mandatory，强制定位，如果存在有效的定位点位置，则滚动容器必须在滚动结束时进行定位； proximity ，浏览器自己判断要不要定位（当容器窗口尺寸小于子元素尺寸时，不定位；否则，定位）。 scroll-snap-stop，是否允许滚动容器忽略捕获位置，兼容性较差： normal，可以忽略捕获位置； always，不能忽略，必须定位到第一个捕获元素的位置。 scroll-snap-padding(-*)，用来调整定位点的位置。 作用在“滚动定位子元素”上的属性有：\nscroll-snap-align，定义捕获点位置是“上边缘”、“下边缘”、“中间位置”： none，默认值，不定义捕获点位置； start，起始位置对齐，如垂直滚动、子元素和容器同上边缘对齐； end，结束位置对齐，如垂直滚动、子元素和容器同下边缘对齐； center，居中对齐，子元素中心和滚动容器中心一致。 scroll-margin(-*)，用来调整定位点的位置。 滚动条样式 scrollbar-width 用来设置滚动条的宽度，并不支持具体的长度值：\nauto，系统默认滚动条样式； none，不展示滚动条，但是页面可以进行正常滚动； thin，如果有“窄”的滚动条，就使用“窄”的滚动条；没有的话，就采用比默认滚动条“窄”一点（Windows 下为 8px）的滚动条。 scrollbar-color 用来设置滚动条的颜色：\nauto，使用系统默认的滚动条颜色（系统使用的主题决定）； dark/light，深色/浅色滚动条（目前没有浏览器支持）； c1 c2，c1 表示滑块的颜色（::webkit-scrollbar-thumb），c2 表示滚动轨道的颜色（::webkit-scrollbar-track）。 隐藏滚动条（可滚动）：\n1 2 3 4 5 6 7 .scroll-none { scrollbar-width: none; } .scroll-none::-webkit-scrollbar { width: 0; height: 0; } 点击行为 pointer-events: none 虽然可以禁用“鼠标”点击、悬停和拖拽行为，但其并不适合用来实现“禁用”效果：\n不能阻止键盘行为，对应元素仍可以通过键盘被 focus 并 click； 影响“无障碍访问”，对应元素的 title 属性将不起作用。 touch-action 是移动端中与手势触摸密切相关的 CSS，属性值为：\nauto，默认值，表示手势操作完全由浏览器决定； none，表示不进行任何手势相关的行为，不能用手指滚动/缩放网页； manipulation，表示浏览器只允许进行滚动和持续缩放操作（双击缩放不被支持），可以用来解决点击后延时 300ms 的问题； pan-x，表示支持手指水平移来移去的操作； pan-y，表示支持手指垂直移来移去的操作； pan-left，表示支持手指往左移动，移动开始后往右可以恢复的操作； pan-right，表示支持手指往右移动，移动开始后往左可以恢复的操作； pan-up，表示支持手指往上移动，移动开始后往下可以恢复的操作； pan-down，表示支持手指往下移动，移动开始后往上可以恢复的操作； pinch-zoom，表示支持手指缩放页面的操作。 拉伸行为 resize 属性的作用条件：\n不支持内联元素； 块级元素的 overflow 属性计算值不能为 visible。 resize 属性是通过改变元素的 width/height 属性值来实现的，所以可以通过 min/max-width/height 来限制元素的拉伸尺寸。\nresize 的拖拽条样式可以通过 ::webkit-resizer 伪元素进行自定义。\n输入行为 caret-color 可以改变输入框“插入光标”的颜色；其不仅对表单元素有效，对设置了 contenteditable 的普通元素同样有效。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; input, [contenteditable] { padding: 0.8em; border: 1px solid grey; caret-color: red; color: blue; } \u0026lt;/style\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;p contenteditable=\u0026#34;true\u0026#34;\u0026gt;contenteditable\u0026lt;/p\u0026gt; 选择行为 user-select 属性多用于内嵌在 WebView 的页面中，保持和原生应用一致的内容选择体验：\nauto，初始值； text，元素及其子元素的内容可被选中； all，元素中的内容需要被整体选中，可以用来模仿原生选中的效果； contain，在元素内选择，选区被限制在元素之内，暂无浏览器支持； none，元素及其子元素的内容不可选中。 user-select 属性需要注意的点：\n无论属性值是什么，::before 和 ::after 的内容都表现为 none； 没有继承性，那只是初始值 auto 的渲染表现而已。 ::section 伪元素可以改变文字被选中后的颜色和背景色（选区）。\n1 2 3 4 body::section { background: red; color: green; } 打印行为 打印页面时隐藏不必要的信息：\n1 2 3 4 5 6 7 @media print { header, footer, [unnecessary-content] { display: none; } } 打印页面时，默认情况下背景色是不打印的（节约墨水），color-adjust 可以用来控制是否打印背景色：\neconomy，默认值，浏览器可以对元素进行样式上的调整（怎么调整浏览器自己定）； exact，不要浏览器对样式进行调整。 ","date":"2022-02-28T00:00:00Z","image":"https://vikingama.github.io/img/cover/css.png","permalink":"https://vikingama.github.io/p/css-%E6%96%B0%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/","title":"《CSS 新世界》笔记"},{"content":"优先级与选择器 CSS 是有局部作用域的（ShadowDOM）。\nCSS 选择符有五种：\n后代关系（空格） ； 父子关系（\u0026gt;） ； 相邻兄弟关系（+） ； 随后兄弟关系（~） ； 列关系（||） 。 CSS 优先级有六种：\n0 级：通配选择器（*，不包括伪元素）、选择符（空格、\u0026gt;、+、~、||）和逻辑组合伪类； 1 级：标签选择器； 2 级：类选择器、属性选择器和伪类； 3 级：ID 选择器； 4 级：内联样式； 5 级：!important（可以使 JS 无效）。 CSS 选择器优先级与 DOM 位置无关。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;style\u0026gt; /* 选择器的优先级并不考虑 DOM 的位置，所以背景是绿色 */ div p { background: red; } html p { background: green; } /* 提升选择器优先级的方法：重复选择器自身 */ .paragraph.paragraph { font-size: 24px; } /* 提升选择器优先级的方法：使用属性选择器 */ .paragraph[id] { color: red; } .paragraph { color: black; font-size: 12px; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p class=\u0026#34;paragraph\u0026#34; id=\u0026#34;paragraph\u0026#34;\u0026gt; 背景是 green，字体颜色是 red，字体大小是 24px。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 在 HTML 中，标签和属性都是不区分大小写的，而属性值是区分大小写的。于是，在 CSS 中，标签选择器不区分大小写，属性选择器中的属性也不区分大小写，而类选择器和 ID 选择器本质上是属性值，因此要区分大小写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;style\u0026gt; P { font-size: 18px; } [ID] { background: brown; } .PARAGRAPH { /* 没生效 */ color: aqua; } [data-my=\u0026#39;papa\u0026#39;] { /* 没生效，因为属性值大小写敏感 */ text-align: right; } [data-my=\u0026#39;papa\u0026#39; i] { /* 生效了，i 会让浏览器忽略属性值大小写 */ text-decoration: line-through; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p class=\u0026#34;paragraph\u0026#34; id=\u0026#34;paragraph\u0026#34; data-my=\u0026#34;PaPa\u0026#34;\u0026gt; 背景是 brown，字体颜色是 black，字体大小是 18px，文字左对齐，有删除线。 \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; CSS 选择器最佳实践：\n不要使用 ID 选择器，优先级太高，使得样式覆盖变得困难； 样式重置可以使用标签选择器或属性选择器； 不要嵌套选择器： 渲染性能差，CSS 是从右向左匹配渲染的（.box \u0026gt; div 是先匹配所有的 div 再匹配 box 类名的）； 选择器性能排序：ID 选择器\u0026gt;类选择器\u0026gt;标签选择器\u0026gt;通配选择器\u0026gt;属性选择器\u0026gt;伪类选择器； 每多嵌套一层选择器就会多一层匹配和计算； 优先级混乱，嵌套越多，优先级计算越复杂； 样式布局脆弱，过多的层级会和 HTML 层级结构进行绑定，不好维护。 命名建议使用小写，使用英文或缩写，专有名词可以使用拼音； 命名设置统一前缀，强化品牌的同时避免样式冲突； 对于组合命名，可以使用短横线或下划线。 对 JS 中的后代选择器可能存在的错误认识：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;div id=\u0026#34;divEle\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loney\u0026#34;\u0026gt;单身如我\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;outer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;inner\u0026#34;\u0026gt;内外开花\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const divsOne = document.querySelectorAll(\u0026#39;#divEle div div\u0026#39;); // 查找 ID 为 divEle 的元素的子元素，选择同时满足 div div 选择器的 DOM 元素 const divsTwo = document.querySelector(\u0026#39;#divEle\u0026#39;).querySelectorAll(\u0026#39;div div\u0026#39;); // querySelectorAll 是全局属性的 const divsThree = document.querySelectorAll(\u0026#39;div div\u0026#39;); const divsFour = document .querySelector(\u0026#39;#divEle\u0026#39;) .querySelectorAll(\u0026#39;:scope div div\u0026#39;); // 使用 :scope 伪类查找 console.log(divsOne); // NodeList [div.inner] console.log(divsTwo); // NodeList(3) [div.loney, div.outer, div.inner] console.log(divsThree); // NodeList(3) [div.loney, div.outer, div.inner] console.log(divsFour); // NodeList [div.inner] \u0026lt;/script\u0026gt; 相邻/随后兄弟选择器会忽略文本节点和注释节点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;style\u0026gt; div { background: red; } p { background: green; } div + p { text-decoration: line-through; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;Hamburger brisket strip steak pastrami bresaola tenderloin.\u0026lt;/div\u0026gt; \u0026lt;!-- Bacon kevin pork loin jerky fatback strip steak. --\u0026gt; Pork bacon chicken shankle, pastrami sirloin chislic. \u0026lt;p\u0026gt;Pastrami beef ribs shank pork belly sirloin boudin.\u0026lt;/p\u0026gt; 为什么没有前面兄弟选择器？\n受制于 DOM 渲染规则；如果 CSS 支持了前面兄弟选择器或者父元素选择器，那就必须要等页面所有子元素加载完毕才能渲染 HTML 文档。网页呈现速度必然会大大减慢，浏览器会出现长时间的白板，这会造成不好的体验。\n属性选择器 八种属性选择器：\n[attr]，只要包含指定的属性就匹配； [attr=\u0026ldquo;val\u0026rdquo;]，属性值完全匹配选择器； [attr~=\u0026ldquo;val\u0026rdquo;]，属性值单词完全匹配选择器； [attr|=\u0026ldquo;val\u0026rdquo;]，属性值起始片段完全匹配选择器（val、val-*）； [attr^=\u0026ldquo;val\u0026rdquo;]，属性值以字符 val 开头的元素； [attr$=\u0026ldquo;val\u0026rdquo;]，属性值以字符 val 结尾的元素； [attr*=\u0026ldquo;val\u0026rdquo;]，属性值包含字符 val 的元素； [attr=\u0026ldquo;val\u0026rdquo; i]，以上几种均适用，匹配时忽略属性值大小写。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;p data-id class=\u0026#34;a\u0026#34;\u0026gt;Bacon kevin pork loin jerky fatback strip steak.\u0026lt;/p\u0026gt; \u0026lt;p data-id=\u0026#34;one\u0026#34; class=\u0026#34;b\u0026#34;\u0026gt;Bacon kevin pork loin jerky fatback strip steak.\u0026lt;/p\u0026gt; \u0026lt;p data-id=\u0026#34;one two\u0026#34; class=\u0026#34;c\u0026#34;\u0026gt; Bacon kevin pork loin jerky fatback strip steak. \u0026lt;/p\u0026gt; \u0026lt;p data-id=\u0026#34;one-two three\u0026#34; class=\u0026#34;d\u0026#34;\u0026gt; Bacon kevin pork loin jerky fatback strip steak. \u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; console.log(document.querySelectorAll(\u0026#39;[data-id]\u0026#39;)); // NodeList(4) [p.a, p.b, p.c, p.d] console.log(document.querySelectorAll(\u0026#34;[data-id=\u0026#39;one\u0026#39;]\u0026#34;)); // NodeList [p.b] console.log(document.querySelectorAll(\u0026#34;[data-id~=\u0026#39;one\u0026#39;]\u0026#34;)); // NodeList(2) [p.b, p.c] console.log(document.querySelectorAll(\u0026#34;[data-id|=\u0026#39;one\u0026#39;]\u0026#34;)); // NodeList(2) [p.b, p.d] \u0026lt;/script\u0026gt; 基于属性选择器的过滤技术：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;输入城市名称\u0026#34; id=\u0026#34;inputEle\u0026#34; /\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li data-search=\u0026#34;重庆市chongqing\u0026#34;\u0026gt;重庆市\u0026lt;/li\u0026gt; \u0026lt;li data-search=\u0026#34;哈尔滨市haerbing\u0026#34;\u0026gt;哈尔滨市\u0026lt;/li\u0026gt; \u0026lt;li data-search=\u0026#34;长春市changchun\u0026#34;\u0026gt;长春市\u0026lt;/li\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; const inputEle = document.getElementById(\u0026#39;inputEle\u0026#39;); const styleEle = document.createElement(\u0026#39;style\u0026#39;); document.head.appendChild(styleEle); inputEle.addEventListener(\u0026#39;input\u0026#39;, e =\u0026gt; { const value = e.target.value; styleEle.innerHTML = value ? `[data-search]:not([data-search*=${value}]){display:none;}` : \u0026#39;\u0026#39;; }); \u0026lt;/script\u0026gt; DEMO 在 这里 。\n伪类 :focus 默认只能匹配特定的元素：\n设置了 contenteditable 属性的普通元素； 设置了 tabindex 属性的普通元素 非 disabled 状态的表单元素； 包含 href 属性的 a 元素； area、summary 元素。 :focus 只有在当前元素处于聚焦状态的时候才匹配，而 :focus-within 在当前元素或者是当前元素的任意子元素处于聚焦状态的时候都会匹配。换句话说，子元素聚焦，可以让父级元素的样式发生变化。:focus-within 的行为本质上是一种“父选择器”行为，子元素的状态会影响父元素的样式。\n:focus-visible 可以让我们知道元素的聚焦行为到底是鼠标触发还是键盘触发；如果希望去除鼠标点击时候的 outline，而保留键盘访问时候的 outline，只要一条 CSS 规则就可以了：\n1 2 3 :focus:not(:focus-visible) { outline: 0; } a 标签的伪类要遵守『爱恨原则』，定义的顺序必须是 :link→:visited→:hover→:active：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; /* 与 a{} 的区别是：a:link 只会匹配具有 href 属性的 a 元素 */ a:link { background-color: aqua; } /* :visited 仅支持很少的 CSS 属性（大多和颜色相关且不支持透明色） */ a:visited { background-color: blueviolet; } a:hover { background-color: chartreuse; } a:active { background-color: darkcyan; } \u0026lt;/style\u0026gt; \u0026lt;a href=\u0026#34;https://baidu.com/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; :placeholder-shown 表示当输入框的 placeholder 内容显示的时候，匹配该输入框；通过此伪类可以实现比较有意思的 交互 。\n:checked 与 [checked] 的区别：\n:checked 只能匹配标准表单元素，不能匹配普通元素； [checked] 可以与设置了 checked 属性的任意元素匹配； [checked] 不会响应 JS 对元素属性的修改； :checked 可以匹配从祖先元素那里继承过来的状态。 可以对输入值进行验证的伪类：\n:valid 与 :invalid； :in-range 与 :out-of-range； :required 与 :optional； :user-invalid； :blank。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;style\u0026gt; /* 只要表单元素没有设置 required，都会匹配此伪类 */ :optional { width: 300px; } /* 页面加载就会生效，即使用户没进行任何操作，所以不太友好 */ .input-valid:valid, .input-range:in-range { border: 2px solid green; } .input-valid:invalid, .input-range:out-of-range { border: 2px solid red; } \u0026lt;/style\u0026gt; \u0026lt;input class=\u0026#34;input-valid\u0026#34; type=\u0026#34;text\u0026#34; pattern=\u0026#34;\\w{4,6}\u0026#34; placeholder=\u0026#34;请输入验证码\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;input-range\u0026#34; type=\u0026#34;number\u0026#34; min=\u0026#34;10\u0026#34; max=\u0026#34;100\u0026#34; placeholder=\u0026#34;请输入数字\u0026#34; /\u0026gt; \u0026lt;input class=\u0026#34;input-range\u0026#34; type=\u0026#34;range\u0026#34; min=\u0026#34;10\u0026#34; max=\u0026#34;100\u0026#34; /\u0026gt; :root 表示的就是 html 元素，只是 :root 优先级更高。对应的，在 ShadowDOM 中使用 :host 伪类。\n:empty 的使用：\n不会匹配含有注释/空格的空元素（毕竟注释和空格都算是节点）； 不会匹配没有闭合的闭合元素； ::before/::after 不会影响匹配； 可以非常方便的隐藏空节点； 结合伪元素，可以在空元素内做一些用户提示。 否定伪类 :not()：\n本身的优先级为 0，最终选择器优先级是由括号里的表达式决定的，:not(p) 的优先级等同于标签选择器的优先级； :not() 可以级联，例如，input:not(:disabled):not(:read-only)； 不支持多个表达式，也不支持选择符，例如，:not(li, dd) 是无效的。 :fullscreen 伪类用来匹配全屏元素；通过调用 element.requestFullScreen 可以让元素全屏显示，通过调用 document.cancelFullScreen 可以取消全屏。\n:lang() 用来匹配指定语言环境下的元素。\n","date":"2022-01-20T00:00:00Z","image":"https://vikingama.github.io/img/cover/css.png","permalink":"https://vikingama.github.io/p/css-%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/","title":"《CSS 选择器世界》笔记"},{"content":"导入方式 在 19/20 版本，默认导出可能不可用。\n1 2 import * as React from \u0026#39;react\u0026#39;; import * as ReactDOM from \u0026#39;react-dom\u0026#39;; 组件 props 类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 type CommonType = {}; type ComponentProps = { count: number; message: string; disabled: boolean; status: \u0026#39;success\u0026#39; | \u0026#39;waiting\u0026#39; | \u0026#39;error\u0026#39;; objAttr: {}; objAttrArr: { id: string; title: string; }[]; dict1: { [key: string]: CommonType; }; dict2: Record\u0026lt;string, CommonType\u0026gt;; // 同 dict1 onSth: Function; onChange(): void; onClick: () =\u0026gt; void; onSubmit(event: React.FormEvent\u0026lt;HTMLFormElement\u0026gt;): void; onContextMenu: (event: React.MouseEvent\u0026lt;HTMLDivElement\u0026gt;) =\u0026gt; void; optional?: unknown; }; /** * 获取元素的 props 类型： * React.HTMLAttributes\u0026lt;HTMLDivElement\u0026gt; * React.HTMLProps\u0026lt;HTMLDivElement\u0026gt; * 获取组件的 props 类型： * React.ComponentProps\u0026lt;typeof App\u0026gt; * React.ComponentPropsWithRef\u0026lt;typeof App\u0026gt; * React.ComponentPropsWithoutRef\u0026lt;typeof App\u0026gt; */ type MyButtonProps = React.HTMLAttributes\u0026lt;HTMLButtonElement\u0026gt; \u0026amp; { type: \u0026#39;button\u0026#39; | \u0026#39;submit\u0026#39; | \u0026#39;reset\u0026#39; | undefined; }; const MyButtonWithForwardRef = React.forwardRef\u0026lt; HTMLButtonElement, MyButtonProps \u0026gt;((props, ref) =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;button ref={ref} {...props}\u0026gt; 按钮 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; )); export declare interface OtherProps { /** * JSX.Element React.createElement 的返回值类型 * React.ReactNode 组件的返回值类型 */ children1: JSX.Element; // 没考虑数组 children2: JSX.Element | JSX.Element[]; // 没考虑字符串 children3: React.ReactChildren; // 更像是一个方法而不是类型 children4: React.ReactChild[]; // 稍好，考虑到了数组子元素 children5: React.ReactNode; // 兼顾到了所有边界情况 renderChildren: () =\u0026gt; React.ReactNode; style?: React.CSSProperties; onChange?: React.ChangeEventHandler\u0026lt;HTMLInputElement\u0026gt;; onSubmit?: React.FormEventHandler\u0026lt;HTMLFormElement\u0026gt;; props1: React.ComponentPropsWithoutRef\u0026lt;\u0026#39;button\u0026#39;\u0026gt;; props2: React.ComponentPropsWithRef\u0026lt;typeof MyButtonWithForwardRef\u0026gt;; // 通过 typeof 获取组件类型 } type 还是 interface：\n在定义库或者第三方环境类型时，使用 interface，因为它方便扩展； 在定义组件的 props 和 state 类型时，使用 type，因为它更具有约束性； 在定义联合类型时，type 非常有用；在描述数据结构 implement 或 extends 类型时，interface 更好。 函数组件 1 2 3 4 5 6 7 type Props = { message: string; }; // 不推荐 (https://github.com/facebook/create-react-app/pull/8177) const MessageOne: React.FC\u0026lt;Props\u0026gt; = ({ message }) =\u0026gt; \u0026lt;div\u0026gt;{message}\u0026lt;/div\u0026gt;; // 推荐 const MessageTwo = ({ message }: Props) =\u0026gt; \u0026lt;div\u0026gt;{message}\u0026lt;/div\u0026gt;; 不推荐 React.FC 的原因是：\n对组件的 props.children 进行了定义，即使组件不渲染 props.children； FC 之前还有 SFC、VFC，谁知道还会不会改名字； 对『组件命名空间模式』支持的不够好。 类组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 type MainProps = { // readonly 没必要加上，因为 React.Component\u0026lt;P,S\u0026gt; 会将他们标记为 immutable readonly age: number; message: string; }; type MainState = { count: number; }; class Main extends React.Component\u0026lt;MainProps, MainState\u0026gt; { year!: number; // 非空断言 // 为了更好的类型推断 state: MainState = { count: 1 }; handleIncrement = (num: number = 1) =\u0026gt; { this.setState(state =\u0026gt; ({ count: state.count + num })); }; static getDerivedStateFromProps( nextProps: MainProps, prevState: MainState ): Partial\u0026lt;MainState\u0026gt; | undefined | null { // ... return null; } componentDidMount() { this.year = this.props.age * 10; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{this.props.message}\u0026lt;/span\u0026gt; \u0026lt;span onClick={() =\u0026gt; this.handleIncrement()}\u0026gt;{this.state.count}\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;{this.year}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } } Hook 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 // useState export function StateExample() { /** * show 被推断为 boolean * setShow 被推断为 React.Dispatch\u0026lt;React.SetStateAction\u0026lt;boolean\u0026gt;\u0026gt; */ const [show, setShow] = React.useState(false); /** * user 被推断为 User | null * setUser 被推断为 React.Dispatch\u0026lt;React.SetStateAction\u0026lt;User | null\u0026gt;\u0026gt; */ type User = {}; const [user, setUser] = React.useState\u0026lt;User | null\u0026gt;(null); return null; } // useReducer const initialState = { count: 0 }; type ActionType = | { type: \u0026#39;add\u0026#39;; payload: number } | { type: \u0026#39;dec\u0026#39;; payload: number }; function reducer(state: typeof initialState, action: ActionType) { switch (action.type) { case \u0026#39;add\u0026#39;: return { count: state.count + action.payload }; case \u0026#39;dec\u0026#39;: return { count: state.count - action.payload }; default: return { count: state.count }; } } export function ReducerExample() { /** * state 被推断为 {count: number} * dispatch 被推断为 React.Dispatch\u0026lt;ActionType\u0026gt; */ const [state, dispatch] = React.useReducer(reducer, initialState); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{state.count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;add\u0026#39;, payload: 1 })}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch({ type: \u0026#39;dec\u0026#39;, payload: 1 })}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } // useRef type timerType = ReturnType\u0026lt;typeof setTimeout\u0026gt; | null; // 获取 setTimeout 的返回值 export function DelayShow({ delay = 3000 }: { delay?: number }) { const timer = React.useRef\u0026lt;timerType\u0026gt;(null); const [show, setShow] = useState(false); useEffect(() =\u0026gt; { setShow(false); timer.current = setTimeout(() =\u0026gt; { setShow(true); }, delay); return () =\u0026gt; { if (timer.current) { clearTimeout(timer.current); } }; }, [delay]); return show ? \u0026lt;span\u0026gt;TikTok\u0026lt;/span\u0026gt; : null; } export const DOMRef: React.FC = ({ children }) =\u0026gt; { const divRef = React.useRef\u0026lt;HTMLDivElement\u0026gt;(null); useLayoutEffect(() =\u0026gt; { console.log(divRef.current); }, []); return \u0026lt;div ref={divRef}\u0026gt;{children}\u0026lt;/div\u0026gt;; }; // useContext type ThemeType = { theme: string }; export const Theme = React.createContext\u0026lt;ThemeType\u0026gt;({ theme: \u0026#39;dark\u0026#39; }); export function ConsumerExample() { const value = React.useContext\u0026lt;ThemeType\u0026gt;(Theme); return \u0026lt;span\u0026gt;{value.theme}\u0026lt;/span\u0026gt;; } 事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 const EventExhibit = ({ children }: { children: React.ReactChildren }) =\u0026gt; { return ( \u0026lt;button onClick={event =\u0026gt; { /* event 被自动推断为 React.MouseEvent\u0026lt;HTMLButtonElement, MouseEvent\u0026gt; */ console.log(event); }} \u0026gt; {children} \u0026lt;/button\u0026gt; ); }; const InputExhibit = () =\u0026gt; { const [info, setInfo] = React.useState({ name: \u0026#39;\u0026#39;, age: \u0026#39;\u0026#39; }); // 一种是对『事件对象』添加类型 const handleNameChange = (e: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;): void =\u0026gt; { setInfo({ ...info, name: e.target.value }); }; // 一种是对『事件处理函数』添加类型 const handleAgeChange: React.ChangeEventHandler\u0026lt;HTMLInputElement\u0026gt; = e =\u0026gt; { setInfo({ ...info, age: e.target.value }); }; return ( \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={info.name} onChange={handleNameChange} /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={info.age} onChange={handleAgeChange} /\u0026gt; \u0026lt;/div\u0026gt; ); }; const FormEvent = () =\u0026gt; { // React.FormEvent 也可以 const handleSubmit = (e: React.SyntheticEvent): void =\u0026gt; { e.preventDefault(); const target = e.target as typeof e.target \u0026amp; { email: { value: string }; password: { value: string }; }; const email = target.email.value; const password = target.password.value; console.log(email, password); }; return ( \u0026lt;form onSubmit={handleSubmit}\u0026gt; \u0026lt;label htmlFor=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label htmlFor=\u0026#34;password\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; /\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;提交\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; Portals 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const modelEle = document.querySelector(\u0026#39;#modelEle\u0026#39;) as HTMLElement; const Model: React.FC = ({ children }) =\u0026gt; { const el = React.useRef(document.createElement(\u0026#39;div\u0026#39;)); useEffect(() =\u0026gt; { modelEle.appendChild(el.current); return () =\u0026gt; { modelEle.removeChild(el.current); }; }, []); return ReactDOM.createPortal(children, el.current); }; const UseModel = () =\u0026gt; { const [show, setShow] = React.useState(false); return ( \u0026lt;div\u0026gt; \u0026lt;div id=\u0026#34;modelEle\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {show \u0026amp;\u0026amp; ( \u0026lt;Model\u0026gt; \u0026lt;div\u0026gt;{/* ... */}\u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow(false)}\u0026gt;关闭\u0026lt;/button\u0026gt; \u0026lt;/Model\u0026gt; )} \u0026lt;button onClick={() =\u0026gt; setShow(true)}\u0026gt;打开\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 错误边界 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type ErrorProps = { children: React.ReactNode; }; type ErrorState = { hasError: boolean; }; class ErrorBoundary extends React.Component\u0026lt;ErrorProps, ErrorState\u0026gt; { state: ErrorState = { hasError: false }; static getDerivedStateFromError(error: Error) { return { hasError: true }; } componentDidCatch(error: Error, stack: React.ErrorInfo) { console.error(error); console.error(stack); } render() { if (this.state.hasError) { return \u0026lt;div\u0026gt;Error Occuried...\u0026lt;/div\u0026gt;; } return this.props.children; } } 参考 TypeScript + React: Why I don\u0026rsquo;t Use React.FC Remove React.FC from Typescript Template TypeScript + React: Component Patterns React TypeScript Cheatsheet ","date":"2022-01-17T00:00:00Z","image":"https://vikingama.github.io/img/cover/typescript.png","permalink":"https://vikingama.github.io/p/ts-%E5%9C%A8-react-%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/","title":"TS 在 React 中的简单应用"},{"content":"Vue.use(Router) Vue.use 会调用 Router 的静态 install 方法：\n保存 Vue 构造函数，方便其他组件调用 Vue 的工具函数； 在每个 Vue 实例中混入钩子： 定义 _routerRoot、_router、_route（getter/setter）； 调用 Router 实例的 init 方法； 注册路由实例。 在 Vue 原型上挂载 $router、$route； 注册 router-view 和 router-link 组件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 export let _Vue; // 别的地方有用到 _Vue.extend export function install(Vue) { // 防止重复 install if (install.installed) return; install.installed = true; // 保存 Vue _Vue = Vue; const isDef = v =\u0026gt; v !== undefined; const registerInstance = (vm, callVal) =\u0026gt; { let i = vm.$options._parentVnode; if ( isDef(i) \u0026amp;\u0026amp; isDef((i = i.data)) \u0026amp;\u0026amp; isDef((i = i.registerRouteInstance)) ) { /** * 调用 vm.$options._parentVnode.data.registerRouteInstance * data.registerRouteInstance 存在于 router-view 中 */ i(vm, callVal); } }; // 混入钩子（确保每个 vm 都能访问到路由） Vue.mixin({ beforeCreate() { // new Vue({router, ...})，挂载根实例，如果是根 vm if (isDef(this.$options.router)) { // _routerRoot 指向根组件实例 this._routerRoot = this; // 传入的 new Router({mode, routes, ...}) this._router = this.$options.router; /** * 调用 _router 的 init 方法，将 this 保存到数组里 * 监听 history，有变化会更新所有 this 里的 route */ this._router.init(this); /** * defineReactive(obj, key, val, customSetter, shallow) * 将 this._route 转化为 getter/setter，render 被调用时 * router.view 会访问 this._route，触发 getter * 当 this._route 更新后，setter 调用 * router.view 渲染匹配的组件 */ Vue.util.defineReactive(this, \u0026#39;_route\u0026#39;, this._router.history.current); } else { // 如果不是根组件，向上（从父级）查找 _routerRoot this._routerRoot = (this.$parent \u0026amp;\u0026amp; this.$parent._routerRoot) || this; } registerInstance(this, this); }, destroyed() { registerInstance(this); } }); /** * 直接在原型链上添加 $router/$route，都指向 _routerRoot 上对应的属性 * vm.$router = this._routerRoot._router = new Router({mode, routes, ...}) * vm.$route = this._routerRoot._route */ Object.defineProperty(Vue.prototype, \u0026#39;$router\u0026#39;, { get() { // 都指向 new VueRouter({...}) return this._routerRoot._router; } }); Object.defineProperty(Vue.prototype, \u0026#39;$route\u0026#39;, { get() { // 都指向 this._router.history.current return this._routerRoot._route; } }); // 全局注册 router-view 和 router-link 组件 Vue.component(\u0026#39;router-view\u0026#39;, View); Vue.component(\u0026#39;router-link\u0026#39;, Link); const strats = Vue.config.optionMergeStrategies; strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created; } VueRouter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 export default class VueRouter { static install: () =\u0026gt; void; static version: string; app: any; apps: Array\u0026lt;any\u0026gt;; ready: boolean; readyCbs: Array\u0026lt;Function\u0026gt;; options: RouterOptions; mode: string; history: HashHistory | HTML5History | AbstractHistory; matcher: Matcher; fallback: boolean; beforeHooks: Array\u0026lt;?NavigationGuard\u0026gt;; resolveHooks: Array\u0026lt;?NavigationGuard\u0026gt;; afterHooks: Array\u0026lt;?AfterNavigationHook\u0026gt;; constructor(options: RouterOptions = {}) { this.app = null; this.apps = []; this.options = options; this.beforeHooks = []; this.resolveHooks = []; this.afterHooks = []; this.matcher = createMatcher(options.routes || [], this); // 默认 hash 模式 let mode = options.mode || \u0026#39;hash\u0026#39;; this.fallback = // 不支持 history，退回 hash mode === \u0026#39;history\u0026#39; \u0026amp;\u0026amp; !supportsPushState \u0026amp;\u0026amp; options.fallback !== false; if (this.fallback) { mode = \u0026#39;hash\u0026#39;; } // 非浏览器环境使用 abstract 模式 if (!inBrowser) { mode = \u0026#39;abstract\u0026#39;; } this.mode = mode; // options.base 就是\u0026#34;基路径\u0026#34; switch (mode) { case \u0026#39;history\u0026#39;: /** * 处理滚动行为 * 监听 popstate 并调用 transitionTo */ this.history = new HTML5History(this, options.base); break; case \u0026#39;hash\u0026#39;: /** * 处理 URL 格式 * 监听 hashchange 并调用 transitionTo */ this.history = new HashHistory(this, options.base, this.fallback); break; case \u0026#39;abstract\u0026#39;: this.history = new AbstractHistory(this, options.base); break; default: } } match(raw: RawLocation, current?: Route, redirectedFrom?: Location): Route { return this.matcher.match(raw, current, redirectedFrom); } get currentRoute(): ?Route { return this.history \u0026amp;\u0026amp; this.history.current; } // 每个组件的 beforeCreate 会调用 init 方法，将当前实例传进来 init(app: any) { // 向 this.apps 添加当前 Vue 实例 this.apps.push(app); // 不要重复 init if (this.app) { return; } // _router.app = vm this.app = app; const history = this.history; if (history instanceof HTML5History) { /** * getCurrentLocation 就是截取掉\u0026#34;基路径\u0026#34;后的路径 * url：https://router.vuejs.org/zh/api/?abc=123#hahaha，base: /zh * getCurrentLocation =\u0026gt; /api/?abc=123#hahaha */ history.transitionTo(history.getCurrentLocation()); } else if (history instanceof HashHistory) { // 绑定 hashchange 事件 const setupHashListener = () =\u0026gt; { history.setupListeners(); }; // 跳转一次页面，触发一次 hashchange history.transitionTo( /** * getCurrentLocation 就是截取掉 # 后边的值 * url：https://router.vuejs.org/zh/api/?abc=123#hahaha，base: /zh * getCurrentLocation =\u0026gt; hahaha */ history.getCurrentLocation(), setupHashListener, setupHashListener ); } /** * 路由改变的时候，所有 Vue 实例里的 _route 都要改变 * history 的 updateRoute 会调用 listen 里的回调 * _route 已经是“响应式”，会触发组件更新 */ history.listen(route =\u0026gt; { this.apps.forEach(app =\u0026gt; { app._route = route; }); }); } beforeEach(fn: Function): Function { return registerHook(this.beforeHooks, fn); } beforeResolve(fn: Function): Function { return registerHook(this.resolveHooks, fn); } afterEach(fn: Function): Function { return registerHook(this.afterHooks, fn); } onReady(cb: Function, errorCb?: Function) { this.history.onReady(cb, errorCb); } onError(errorCb: Function) { this.history.onError(errorCb); } push(location: RawLocation, onComplete?: Function, onAbort?: Function) { this.history.push(location, onComplete, onAbort); } replace(location: RawLocation, onComplete?: Function, onAbort?: Function) { this.history.replace(location, onComplete, onAbort); } go(n: number) { this.history.go(n); } back() { this.go(-1); } forward() { this.go(1); } getMatchedComponents(to?: RawLocation | Route): Array\u0026lt;any\u0026gt; { const route: any = to ? to.matched ? to : this.resolve(to).route : this.currentRoute; if (!route) { return []; } return [].concat.apply( [], route.matched.map(m =\u0026gt; { return Object.keys(m.components).map(key =\u0026gt; { return m.components[key]; }); }) ); } resolve( to: RawLocation, current?: Route, append?: boolean ): { location: Location; route: Route; href: string; normalizedTo: Location; resolved: Route; } { const location = normalizeLocation( to, current || this.history.current, append, this ); const route = this.match(location, current); const fullPath = route.redirectedFrom || route.fullPath; const base = this.history.base; const href = createHref(base, fullPath, this.mode); return { location, route, href, normalizedTo: location, resolved: route }; } addRoutes(routes: Array\u0026lt;RouteConfig\u0026gt;) { this.matcher.addRoutes(routes); if (this.history.current !== START) { this.history.transitionTo(this.history.getCurrentLocation()); } } } BaseHistory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 export class History { base: string; cb: (r: Route) =\u0026gt; void; current: Route; errorCbs: Array\u0026lt;Function\u0026gt;; pending: ?Route; ready: boolean; readyCbs: Array\u0026lt;Function\u0026gt;; readyErrorCbs: Array\u0026lt;Function\u0026gt;; router: Router; /** * 需要子类去实现的方法： * +ensureURL: (push?: boolean) =\u0026gt; void; * +getCurrentLocation: () =\u0026gt; string; * +go: (n: number) =\u0026gt; void; * +push: (loc: RawLocation) =\u0026gt; void; * +replace: (loc: RawLocation) =\u0026gt; void; */ constructor(router: Router, base: ?string) { this.base = normalizeBase(base); this.current = START; this.errorCbs = []; this.pending = null; this.ready = false; this.readyCbs = []; this.readyErrorCbs = []; this.router = router; } listen(cb: Function) { // 给 this.cb 赋值，会在 updateRoute 调用 this.cb this.cb = cb; } onReady(cb: Function, errorCb: ?Function) { if (this.ready) { cb(); } else { this.readyCbs.push(cb); if (errorCb) { this.readyErrorCbs.push(errorCb); } } } onError(errorCb: Function) { this.errorCbs.push(errorCb); } // 用于路由切换 transitionTo( location: RawLocation, onComplete?: Function, onAbort?: Function ) { // 匹配目标 location 的 route const route = this.router.match(location, this.current); // 确认切换（异步） this.confirmTransition( route, // onComplete () =\u0026gt; { this.updateRoute(route); // 更新 route onComplete \u0026amp;\u0026amp; onComplete(route); this.ensureURL(); if (!this.ready) { this.ready = true; this.readyCbs.forEach(cb =\u0026gt; { cb(route); }); } }, // onAbort err =\u0026gt; { if (onAbort) { onAbort(err); } if (err \u0026amp;\u0026amp; !this.ready) { this.ready = true; this.readyErrorCbs.forEach(cb =\u0026gt; { cb(err); }); } } ); } confirmTransition(route: Route, onComplete: Function, onAbort?: Function) { const current = this.current; // 导航取消的时候调用 const abort = err =\u0026gt; { if (isError(err)) { if (this.errorCbs.length) { this.errorCbs.forEach(cb =\u0026gt; { cb(err); }); } else { console.error(err); } } onAbort \u0026amp;\u0026amp; onAbort(err); }; if ( // 如果 route 和 current 是相同路径（path、hash、query、params 一样） isSameRoute(route, current) \u0026amp;\u0026amp; // 并且匹配的长度一致 route.matched.length === current.matched.length ) { // 就没必要跳转 this.ensureURL(); return abort(); } // 找出 currentRecord 和 nextRecord 中的相同与不同 const { updated, // 相同但需要更新的 deactivated, // currentRecord 独有的 activated // nextRecord 独有的 } = resolveQueue( this.current.matched, // currentRecord 数组 route.matched // nextRecord 数组 ); /** * 导航被触发 * 在失活的组件里调用 beforeRouteLeave 守卫 * 调用全局的 beforeEach 守卫 * 在重用的组件里调用 beforeRouteUpdate 守卫 * 在路由配置里调用 beforeEnter * 解析异步路由组件 * 在被激活的组件里调用 beforeRouteEnter * 调用全局的 beforeResolve 守卫 * 导航被确认 * 调用全局的 afterEach 钩子 * 触发 DOM 更新 * 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入 */ const queue: Array\u0026lt;?NavigationGuard\u0026gt; = [].concat( // 组件内部的 beforeRouteLeave extractLeaveGuards(deactivated), // 全局 beforeEach this.router.beforeHooks, // 组件内部的 beforeRouteUpdate extractUpdateHooks(updated), // routes 路由表里写的 beforeEnter activated.map(m =\u0026gt; m.beforeEnter), // 解析异步路由组件，会等待异步组件的加载，加载完成之后再导航 resolveAsyncComponents(activated) ); this.pending = route; const iterator = (hook: NavigationGuard, next) =\u0026gt; { // next 被调用之后，会去拿数组里的下一个钩子函数 if (this.pending !== route) { return abort(); } try { // 有点 to、from、next 那味儿了 hook(route, current, (to: any) =\u0026gt; { if (to === false || isError(to)) { // next(false) -\u0026gt; 停止导航 this.ensureURL(true); abort(to); } else if ( typeof to === \u0026#39;string\u0026#39; || (typeof to === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; (typeof to.path === \u0026#39;string\u0026#39; || typeof to.name === \u0026#39;string\u0026#39;)) ) { // next(\u0026#39;/\u0026#39;) 或 next({ path: \u0026#39;/\u0026#39; }) -\u0026gt; 重定向 abort(); if (typeof to === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; to.replace) { this.replace(to); } else { this.push(to); } } else { next(to); } }); } catch (e) { abort(e); } }; runQueue( queue, // 保存了要执行的钩子函数 iterator, // queue 里的钩子会被一个一个的拿到 iterator 里执行 () =\u0026gt; { // queue 里的钩子被全部调用完成之后，会执行此函数 const postEnterCbs = []; const isValid = () =\u0026gt; this.current === route; // 获取组件里 beforeRouteEnter 钩子 const enterGuards = extractEnterGuards( activated, postEnterCbs, isValid ); // 拼接上全局 beforeResolve 钩子 const queue = enterGuards.concat(this.router.resolveHooks); runQueue(queue, iterator, () =\u0026gt; { // 新的 queue 里的钩子被全部调用完成之后，会执行此函数 if (this.pending !== route) { return abort(); } this.pending = null; onComplete(route); if (this.router.app) { // 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入 this.router.app.$nextTick(() =\u0026gt; { postEnterCbs.forEach(cb =\u0026gt; { cb(); }); }); } }); } ); } updateRoute(route: Route) { const prev = this.current; this.current = route; // 调用 this.cb（init 的时候，由 history.listen 赋值） this.cb \u0026amp;\u0026amp; this.cb(route); this.router.afterHooks.forEach(hook =\u0026gt; { hook \u0026amp;\u0026amp; hook(route, prev); }); } } export function runQueue( queue: Array\u0026lt;?NavigationGuard\u0026gt;, fn: Function, cb: Function ) { const step = index =\u0026gt; { if (index \u0026gt;= queue.length) { cb(); } else { if (queue[index]) { fn(queue[index], () =\u0026gt; { step(index + 1); }); } else { step(index + 1); } } }; step(0); } HTML5History 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 export class HTML5History extends History { constructor(router: Router, base: ?string) { super(router, base); const expectScroll = router.options.scrollBehavior; if (expectScroll) { // popstate 时，保存滚动位置 setupScroll(); } /** * 调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件 * popstate 事件只会在浏览器后退按钮或调用 history.back() 方法时触发 * 即，在同一文档的两个历史记录条目之间导航会触发该事件 * 重新调用 transitionTo 完成页面切换 */ window.addEventListener(\u0026#39;popstate\u0026#39;, e =\u0026gt; { const current = this.current; this.transitionTo(getLocation(this.base), route =\u0026gt; { if (expectScroll) { /** * handleScroll(router, to, from, isPop) * 调用 getScrollPosition 获取滚动位置（保存在 history 的 state 里） * 调用 router.options.scrollBehavior(to, from, position) 判断是否需要滚动 * 调用 window.scrollTo 进行滚动 */ handleScroll(router, route, current, true); } }); }); } go(n: number) { window.history.go(n); } push(location: RawLocation, onComplete?: Function, onAbort?: Function) { const { current: fromRoute } = this; this.transitionTo( location, route =\u0026gt; { pushState(cleanPath(this.base + route.fullPath)); handleScroll(this.router, route, fromRoute, false); onComplete \u0026amp;\u0026amp; onComplete(route); }, onAbort ); } replace(location: RawLocation, onComplete?: Function, onAbort?: Function) { const { current: fromRoute } = this; this.transitionTo( location, route =\u0026gt; { replaceState(cleanPath(this.base + route.fullPath)); handleScroll(this.router, route, fromRoute, false); onComplete \u0026amp;\u0026amp; onComplete(route); }, onAbort ); } ensureURL(push?: boolean) { if (getLocation(this.base) !== this.current.fullPath) { const current = cleanPath(this.base + this.current.fullPath); push ? pushState(current) : replaceState(current); } } getCurrentLocation(): string { return getLocation(this.base); } } HashHistory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 export class HashHistory extends History { constructor(router: Router, base: ?string, fallback: boolean) { super(router, base); /** * checkFallback 会把 HTML5History 格式的链接转换为 HashHistory 格式的链接 * 然后 location.replace 掉 * url：https://router.vuejs.org/zh/api/?abc=123#hahaha，base: /zh * checkFallback =\u0026gt; https://router.vuejs.org/zh/#/api/?abc=123#hahaha */ if (fallback \u0026amp;\u0026amp; checkFallback(this.base)) { return; } // /zh#/api/?abc=123#hahaha replace 成为 /zh/#/api/?abc=123#hahaha ensureSlash(); // 保证 # 前边有 / } // 延迟到应用挂载，防止事件过早触发 setupListeners() { window.addEventListener(\u0026#39;hashchange\u0026#39;, () =\u0026gt; { if (!ensureSlash()) { return; } // 获取 hash 并跳转 this.transitionTo(getHash(), route =\u0026gt; { replaceHash(route.fullPath); }); }); } push(location: RawLocation, onComplete?: Function, onAbort?: Function) { this.transitionTo( location, route =\u0026gt; { // 赋值 window.location.hash pushHash(route.fullPath); onComplete \u0026amp;\u0026amp; onComplete(route); }, onAbort ); } replace(location: RawLocation, onComplete?: Function, onAbort?: Function) { this.transitionTo( location, route =\u0026gt; { // 调用 window.location.replace replaceHash(route.fullPath); onComplete \u0026amp;\u0026amp; onComplete(route); }, onAbort ); } go(n: number) { window.history.go(n); } ensureURL(push?: boolean) { const current = this.current.fullPath; if (getHash() !== current) { push ? pushHash(current) : replaceHash(current); } } getCurrentLocation() { return getHash(); } } matcher 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 export function createMatcher( routes: Array\u0026lt;RouteConfig\u0026gt;, // options.routes router: VueRouter // VueRouter 实例 ): Matcher { // 把传入的路由表转换为路由映射表 const { pathList, pathMap, nameMap } = createRouteMap(routes); // addRoutes 就是把新来的 routes 添加到 pathList, pathMap, nameMap 里 function addRoutes(routes) { createRouteMap(routes, pathList, pathMap, nameMap); } // 根据 RawLocation 和 currentRoute 返回一个 route function match( raw: RawLocation, // url 或者 Location 对象 currentRoute?: Route, redirectedFrom?: Location ): Route { const location = normalizeLocation(raw, currentRoute, false, router); const { name } = location; if (name) { const record = nameMap[name]; // 获取 name 对应的 record if (!record) return _createRoute(null, location); const paramNames = record.regex.keys .filter(key =\u0026gt; !key.optional) .map(key =\u0026gt; key.name); if (typeof location.params !== \u0026#39;object\u0026#39;) { location.params = {}; } if (currentRoute \u0026amp;\u0026amp; typeof currentRoute.params === \u0026#39;object\u0026#39;) { for (const key in currentRoute.params) { if (!(key in location.params) \u0026amp;\u0026amp; paramNames.indexOf(key) \u0026gt; -1) { location.params[key] = currentRoute.params[key]; } } } if (record) { location.path = fillParams( record.path, location.params, `named route \u0026#34;${name}\u0026#34;` ); return _createRoute(record, location, redirectedFrom); } } else if (location.path) { location.params = {}; for (let i = 0; i \u0026lt; pathList.length; i++) { const path = pathList[i]; const record = pathMap[path]; if (matchRoute(record.regex, location.path, location.params)) { return _createRoute(record, location, redirectedFrom); } } } return _createRoute(null, location); } // ... return { match, addRoutes }; } route-map 传入 option.routes（开发者写的路由表）返回一个数组两个对象：\n所有路由的 path 组成的数组； path 到 record 的映射关系； name 到 record 的映射关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 // 对路由表（routes）进行数据结构的转换 export function createRouteMap( routes: Array\u0026lt;RouteConfig\u0026gt;, oldPathList?: Array\u0026lt;string\u0026gt;, // addRoutes 才用得上 oldPathMap?: Dictionary\u0026lt;RouteRecord\u0026gt;, // addRoutes 才用得上 oldNameMap?: Dictionary\u0026lt;RouteRecord\u0026gt; // addRoutes 才用得上 ) { // 用来控制路径匹配优先级 const pathList: Array\u0026lt;string\u0026gt; = oldPathList || []; const pathMap: Dictionary\u0026lt;RouteRecord\u0026gt; = oldPathMap || Object.create(null); const nameMap: Dictionary\u0026lt;RouteRecord\u0026gt; = oldNameMap || Object.create(null); routes.forEach(route =\u0026gt; { addRouteRecord(pathList, pathMap, nameMap, route); }); // 确保 path 为通配符的路由一直在结尾 for (let i = 0, l = pathList.length; i \u0026lt; l; i++) { if (pathList[i] === \u0026#39;*\u0026#39;) { pathList.push(pathList.splice(i, 1)[0]); l--; i--; } } return { pathList, // routePath[] pathMap, // {path: record, ...} nameMap // {name: rocord, ...} }; } function addRouteRecord( pathList: Array\u0026lt;string\u0026gt;, pathMap: Dictionary\u0026lt;RouteRecord\u0026gt;, nameMap: Dictionary\u0026lt;RouteRecord\u0026gt;, route: RouteConfig, parent?: RouteRecord, matchAs?: string ) { const { path, name } = route; // 去除 path 最后的 /，并拼接上 parent.path const normalizedPath = normalizePath(path, parent); const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {}; if (typeof route.caseSensitive === \u0026#39;boolean\u0026#39;) { pathToRegexpOptions.sensitive = route.caseSensitive; } // 根据传入的 route 生成一个 record const record: RouteRecord = { path: normalizedPath, // 规范化之后的 path，带上父级路由的那种 regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), // 将 path 解析成正则表达式 // 一条 path 可以对应多个 components，通过 router-view 的 name 属性来判断渲染出口 components: route.components || { default: route.component }, instances: {}, name, parent, // ParentRouteRecord matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || {}, props: route.props == null ? {} : route.components ? route.props : { default: route.props } }; if (route.children) { console.warn( \u0026#39;如果 route 有 name，没有重定向，有一个默认的子路由，如果通过 name 进行导航，默认的子路由不会渲染\u0026#39; ); route.children.forEach(child =\u0026gt; { const childMatchAs = matchAs ? cleanPath(`${matchAs}/${child.path}`) : undefined; // record 作为 children 的 parent，重新调用 addRouteRecord addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs); }); } // 如果路由有别名，同样会生成一条 record if (route.alias !== undefined) { const aliases = Array.isArray(route.alias) ? route.alias : [route.alias]; aliases.forEach(alias =\u0026gt; { const aliasRoute = { path: alias, children: route.children }; addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || \u0026#39;/\u0026#39; // matchAs ); }); } if (!pathMap[record.path]) { pathList.push(record.path); pathMap[record.path] = record; } if (name) { if (!nameMap[name]) { nameMap[name] = record; } } } router-link 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 export default { name: \u0026#39;router-link\u0026#39;, props: { to: { type: [String, Object], required: true }, // router-link 默认就是 a 标签 tag: { type: String, default: \u0026#39;a\u0026#39; }, exact: Boolean, append: Boolean, replace: Boolean, activeClass: String, exactActiveClass: String, event: { type: [String, Array], default: \u0026#39;click\u0026#39; } }, render(h: Function) { const router = this.$router; const current = this.$route; const { location, route, href } = router.resolve( this.to, current, this.append ); const classes = {}; const globalActiveClass = router.options.linkActiveClass; const globalExactActiveClass = router.options.linkExactActiveClass; // 不同状态的类名处理 const activeClassFallback = globalActiveClass == null ? \u0026#39;router-link-active\u0026#39; : globalActiveClass; const exactActiveClassFallback = globalExactActiveClass == null ? \u0026#39;router-link-exact-active\u0026#39; : globalExactActiveClass; const activeClass = this.activeClass == null ? activeClassFallback : this.activeClass; const exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass; const compareTarget = location.path ? createRoute(null, location, null, router) : route; classes[exactActiveClass] = isSameRoute(current, compareTarget); classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget); const handler = e =\u0026gt; { /** * 按下 meta、alt、ctrl、shift 时不起作用 * 调用 preventDefault 时不起作用 * target=_blank 时不起作用 * 右键点击时不起作用 */ if (guardEvent(e)) { // 调用 replace 和 push if (this.replace) { router.replace(location); } else { router.push(location); } } }; const on = { click: guardEvent }; if (Array.isArray(this.event)) { this.event.forEach(e =\u0026gt; { // 如果绑定了多个事件处理，也仅绑定在 click 上 on[e] = handler; }); } else { on[this.event] = handler; } const data: any = { class: classes }; // 创建 a 链接之后，会在 a 链接上绑定 href 属性和 click 事件 if (this.tag === \u0026#39;a\u0026#39;) { data.on = on; data.attrs = { href }; } else { // 找到子元素中的 a 标签，在上面加 listener 和 href const a = findAnchor(this.$slots.default); if (a) { // 将 a 标签上已有的属性和 on/href 进行合并 a.isStatic = false; const extend = _Vue.util.extend; const aData = (a.data = extend({}, a.data)); aData.on = on; const aAttrs = (a.data.attrs = extend({}, a.data.attrs)); aAttrs.href = href; } else { // 没 a 标签，那就把 listener 加到自己身上 data.on = on; } } return h(this.tag, data, this.$slots.default); } }; router-view 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 export default { name: \u0026#39;router-view\u0026#39;, functional: true, props: { name: { type: String, default: \u0026#39;default\u0026#39; } }, render(_, { props, children, parent, data }) { data.routerView = true; // 借用父级的 h 函数，酱紫 router-view 渲染的组件可以解析具名插槽 const h = parent.$createElement; // 当同一层级同时有多个 router-view 存在时，会通过 name 属性来确定渲染哪个组件 const name = props.name; const route = parent.$route; const cache = parent._routerViewCache || (parent._routerViewCache = {}); // 当前 router-view 所处的层级（嵌套深度，上层还有几个 router-view），顺便检查当前是否 active let depth = 0; let inactive = false; /** * this._routerRoot = this.$parent._routerRoot * 非根组件的 _routerRoot 指向父级 _routerRoot */ while (parent \u0026amp;\u0026amp; parent._routerRoot !== parent) { // 如果父级组件中有一层 routerView，depth++ if (parent.$vnode \u0026amp;\u0026amp; parent.$vnode.data.routerView) { depth++; } // 如果父级没有被激活，当前组件也不应激活，和 keep-active 组件有关 if (parent._inactive) { inactive = true; } parent = parent.$parent; } data.routerViewDepth = depth; // 如果是 inactive 状态，渲染前一个视图 if (inactive) { return h(cache[name], data, children); } // 当前 route 下，对应层级有没有要渲染的组件 const matched = route.matched[depth]; // 没有匹配上，就渲染空节点 if (!matched) { cache[name] = null; return h(); } // 获取匹配到的组件 const component = (cache[name] = matched.components[name]); // data 上保存了一个函数，被实例注入的生命周期钩子调用 data.registerRouteInstance = (vm, val) =\u0026gt; { const current = matched.instances[name]; if ((val \u0026amp;\u0026amp; current !== vm) || (!val \u0026amp;\u0026amp; current === vm)) { matched.instances[name] = val; } }; (data.hook || (data.hook = {})).prepatch = (_, vnode) =\u0026gt; { matched.instances[name] = vnode.componentInstance; }; // 解析 props data.props = resolveProps(route, matched.props \u0026amp;\u0026amp; matched.props[name]); // 调用 h 函数，渲染匹配到的组件 return h(component, data, children); } }; 总之，VueRouter 在初始化的时候，会向组件 mixin 一些钩子函数；在 beforeCreate 中，会借助 Vue.util.defineReactive API 将 vm._route 转换为 getter/setter；又因为 router-view 在调用 h 函数渲染组件的时候，会访问 vm._route.matched，router-view 所在实例的 renderWatcher 形成对 vm._route 的依赖。所以，每当 vm._route 变化，router-view 会自动匹配自己要渲染的组件。\nrouter-link 默认会渲染出一个绑定了事件的 a 标签，用户点击时，会调用 transitionTo 进行导航；transitionTo 会计算出最新的 route，调用 History API 更新 URL，调用路由钩子，更新 vm._route，触发 router-view 更新。\n至于 popstate 事件，主要用来处理浏览器的行为（history.pushState/replaceState 并不会触发 popstate）并调用 transitionTo 更新页面。\n","date":"2022-01-06T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/vuerouter-2.x-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/","title":"VueRouter 2.x 源码学习"},{"content":"文档流 文档流是指 CSS 中引导元素排列和定位的一条看不见的“水流”。\nCSS 的基石是 HTML，所以 HTML 默认的表现符合“流”，可以通过破坏“流”来实现特殊布局。\n文档流的流向是可以改变的（column、display、float、position\u0026hellip;），这种改变可以让 CSS 的展现更为丰富；因此，“文档流从左往右自上而下”这种说法是不严谨的。\n流体布局指的是利用元素“流”的特性实现的各类布局效果；因为“流”本身具有自适应特性，所以“流体布局”往往都是具有自适应性的。\n流动性是一种 margin/border/padding 和 content 自动分配水平空间的机制；如果手动设置宽度，就完全就不像“水流”那样完全利用容器空间，即所谓的流动性丢失。\n块级元素 块级元素和 display:block 不是一个概念。例如，li 默认的 display 值是 list-item，table 默认的 display 值是 table，但是它们均是“块级元素”，因为它们都符合块级元素的基本特征；也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。\n由于“块级元素”具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动带来的影响（IE 中的伪元素不支持 display:list-item；这是不用 display:list-item 清除浮动的主因，兼容性不好）。\n内外盒子（臆想） 每个元素都两个盒子，外在盒子和内在盒子。外在盒子负责元素是可以一行显示，还是只能换行显示；内在盒子负责宽高、内容呈现什么的。\ndisplay:block 元素的盒子实际由外在的“块级盒子”和内在的“块级容器盒子”组成；display:inline-block 元素则由外在的“内联盒子”和内在的“块级容器盒子”组成；display:inline 元素则内外均是“内联盒子”。\n替换元素 通过修改某个属性值呈现的内容就可以被替换的元素就称为替换元素；因此，img、object、video、iframe 或者 textarea 和 input 都是典型的替换元素：\n内容可替换； 内容外观不受页面上 CSS 的影响（样式表现在 CSS 作用域之外）； 有自己的默认尺寸； 在很多 CSS 属性上有自己的一套表现规则（例如：vertical-align）； 伪元素的 content 属性生成的内容都是替换元素： 使用 content 生成的文本是无法选中、无法复制的，如同设置了 user-select:none 一般； 不影响 :empty 选择器的使用； content 动态生成的值无法获取。 使用 content 中的换行符，实现“加载中”动画。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;style\u0026gt; dot { display: inline-block; height: 1em; line-height: 1; text-align: left; vertical-align: -0.25em; overflow: hidden; } dot::before { display: block; /* 三个点、两个点、一个点；是因为 IE9 不支持 animation，可以不影响显示效果 */ content: \u0026#39;...\\A..\\A.\u0026#39;; /* 如何处理元素中的空白：pre（连续的空白符会被保留；在遇到换行符或者 \u0026lt;br\u0026gt; 元素时才会换行） */ white-space: pre; animation: dot 3s infinite step-start both; } /* 整个效果的原理就是：伪元素不断上下移动 */ @keyframes dot { 33% { transform: translateY(-2em); } 66% { transform: translateY(-1em); } } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 使用 dot 自定义元素，可以在 IE8 上实现优雅降级--\u0026gt; 正在加载中 \u0026lt;dot\u0026gt;...\u0026lt;/dot\u0026gt; \u0026lt;/body\u0026gt; 元素尺寸 元素偏移尺寸：offsetWidth/offsetHeight，元素的 border-box 尺寸； 元素可视尺寸：clientWidth/clientHeight，元素的 padding-box 尺寸； 元素外部尺寸：元素的 margin-box 尺寸，有可能为负数。 min/max-width 与 min/max-height min-* 的初始值是 none，max-* 的初始值是 auto； 如果 width \u0026gt; max-width，width 的值会被 max-width 的值覆盖（即使 width 的权重是 !important）； 如果 min-width \u0026gt; max-width，min-width 会覆盖 max-width 的值； 对于任意高度元素的展开收起动画，不妨试试 max-height（height:auto 不会触发过渡动画）。 margin margin 与 padding 百分比值无论是水平方向还是垂直方向都是相对于宽度计算的； 块级元素（不包括浮动和绝对定位元素）的上下外边距（margin-top/bottom）有时会合并为单个外边距； 第一个/最后一个子元素与父元素； 上下排列的兄弟元素； 空的块级元素。 margin 的合并只发生在和当前文档流方向的相垂直的方向上（默认文档流是水平流，可用 writing-mode 改写）； 阻止 margin 合并的方法：触发 BFC、设置 border、设置 padding、设置 height。 line-height line-height 的定义就是两基线的间距，vertical-align 的默认值就是基线（字母 x 的下边缘线）; x-height 指的是小写字母 x 的高度，术语描述就是基线和等分线（midline，也称作中线）之间的距离； vertical-align:middle 跟上面的中线不是一个意思，middle 指的是基线往上 1/2 x-height 高度（字母 x 交叉点那个位置）； vertical-align:middle 并不是绝对的垂直居中对齐，我们平常看到的 middle 效果只是一种近似效果； ex 是 CSS 中的一个相对单位（相对于字体和字号），指的是小写字母 x 的高度；没错，就是指 x-height（1ch 表示一个阿拉伯数字 0 的宽度）。 默认空 div 高度是 0，一旦里面写上几个文字，div 高度就有了；不少人会认为 div 高度是由里面的文字撑开的，也就是 font-size 决定的；但本质上是由 line-height 全权决定的，尽管某些场景确实与 font-size 大小有关。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; .line-height-zero { outline: 1px solid red; line-height: 0; font-size: 16px; } .font-size-zero { outline: 1px solid red; line-height: 16px; font-size: 0; } .font-size-relative { outline: 1px solid red; line-height: 16px; font-size: 32px; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;第一个：\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;line-height-zero\u0026#34;\u0026gt;line-height: 0;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;第二个：\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;font-size-zero\u0026#34;\u0026gt;font-size: 0;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;第三个：\u0026lt;/p\u0026gt; \u0026lt;div class=\u0026#34;font-size-relative\u0026#34;\u0026gt;font-size-relative\u0026lt;/div\u0026gt; 对于非替换元素的纯内联元素，其可视高度完全由 line-height 决定；注意这里的措辞“完全”，什么 padding、border 属性对可视高度是没有任何影响的。\n对于文本这样的纯内联元素，line-height 就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。比方说，line-height 设为 16px，则一行文字高度是 16px，两行就是 32px，三行就是 48px；所有浏览器渲染解析都是这个值，1 像素都不差。\n在 CSS 中，行距的上下等分机制（line-height=height 时可以实现近似垂直居中的效果），行距分散在文字的上方和下方（Adobe InDesign 的“行距”是加在文字上方的），行距=(line-height)-(font-size)。\nline-height 的属性值：\nnormal，和 font-family 相关联的一个变量，具体解析值还和系统、浏览器有关； 数值（1.5），解析值是和当前 font-size 相乘后的值，所有子元素继承的是 1.5 这个值； 百分比（150%），解析值是和当前 font-size 相乘后的值，所有子元素继承的是解析值； 长度值（21px），所有子元素继承的是解析值（21px）； 计算行高值时，所有浏览器都是向上取整的。 vertical-align 只能作用在 display 计算值为 inline、inline-block，inline-table 或 table-cell 的元素上；块级、浮动、绝对定位元素上无效。\nvertical-align 的属性值分为以下几类：\n线类：baseline（默认值，字符 x 的下边缘、替换元素的下边缘）、top、middle、bottom； 文本类：text-top（盒子顶部和父级内容区域的顶部对齐）、text-bottom（盒子底部和父级内容区域的底部对齐）； 上标下标类：sub（sub 元素默认的 vertical-align 属性值）、super（sup 元素默认的 vertical-align 属性值）； 数值百分比类：20px、20%（相对于 line-height 的解析值）：根据计算值的不同，相对于基线往上（正值）或往下（负值）偏移。 对于一个 inline-block 元素，如果里面没有内联元素，或者 overflow 不是 visible，则该元素的 baseline 就是其 margin 底边缘；否则其 baseline 就是元素里面最后一行内联元素的基线。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;style\u0026gt; span { display: inline-block; width: 120px; height: 120px; background: red; text-decoration: underline; } span:last-of-type { margin-bottom: 120px; } \u0026lt;/style\u0026gt; \u0026lt;span alt=\u0026#34;没有内联元素\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span alt=\u0026#34;最后一行内联元素的基线\u0026#34;\u0026gt; span \u0026lt;br /\u0026gt; span \u0026lt;/span\u0026gt; \u0026lt;span alt=\u0026#34;margin 底边缘\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; float float 的特性：\n块状化并格式化上下文，元素一旦 float 的属性值不为 none，则其 display 计算值就是 block 或者 table； 破坏文档流，使父元素高度塌陷（这是标准不是 bug，浮动本来就是为了破坏文档流实现文字环绕效果）； 没有任何 margin 合并。 1 2 3 4 5 var span = document.createElement(\u0026#39;span\u0026#39;); document.body.appendChild(span); console.log(\u0026#39;1. \u0026#39; + window.getComputedStyle(span).display); span.style.cssFloat = \u0026#39;left\u0026#39;; // 设置元素左浮动 console.log(\u0026#39;2. \u0026#39; + window.getComputedStyle(span).display); 浮动锚点是 float 元素所在的“流”中的一个点，这个点本身并不浮动，就表现而言更像一个没有 margin、border 和 padding 的空的内联元素；浮动参考指的是浮动元素对齐参考的实体。在 CSS 世界中，float 元素的“浮动参考”是“行框盒子”，也就是 float 元素在当前“行框盒子”内定位；每一行内联元素都有一个“行框盒子”。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style\u0026gt; div { background: red; } div \u0026gt; a { float: right; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; 更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多更多 \u0026lt;a href=\u0026#34;https://baidu.com\u0026#34;\u0026gt;更多\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 因此，这里设置了 float:right 的 a 元素是相对于最后一行的“行框盒子”对齐的。\n“浮动锚点”的作用就是产生“行框盒子”，因为“浮动锚点”表现如同一个空的内联元素，有内联元素自然就有“行框盒子”；于是，float 元素对齐的参考实体“行框盒子”对于块状元素也同样适用了，只不过这个“行框盒子”由于没有任何内容，所以无尺寸，看不见也摸不着罢了。\n块级格式化上下文 如果一个元素具有 BFC，内部子元素再怎么翻江倒海，都不会影响外部的元素。所以，BFC 元素是不可能发生 margin 重叠的，因为 margin 重叠是会影响外面的元素的；BFC 元素也可以用来清除浮动的影响，因为如果不清除，子元素浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 BFC 元素的子元素不会影响外部元素的设定。\n创建块级格式化上下文：\n根元素，html； 浮动元素，float 不为 none，（left、right、inline-start、inline-end）； 绝对/固定定位元素，position 为 absolute/fixed； 匿名表格单元格元素，display 为 table、table-row、table-row-group、table-header-group、table-footer-group、inline-table； 表格单元格，display 为 table-cell； 表格标题，display 为 table-caption； 行内块元素，display 为 inline-block； 弹性元素，display 为 flex 或 inline-flex； 网格元素，display 为 grid 或 inline-grid； 多列容器，column-count 或 column-width 不为 auto； overflow 不为 visible 的块元素（hidden、scroll、auto、overlay）； display 为 flow-root 的元素； contain 为 layout、content 或 paint 的元素； column-span 为 all 的元素。 BFC 的结界特性最重要的用途其实不是去 margin 重叠或者是清除 float 影响，而是实现更健壮、更智能的自适应布局。普通流体元素在设置了 overflow:hidden 后，会自动填满容器中除了浮动元素以外的剩余空间，形成自适应布局效果，而且这种自适应布局要比纯流体自适应更加智能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; img { float: left; width: 180px; margin: 0 8px 0 0; } p { margin: 0; overflow: hidden; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;/images/avatar.png\u0026#34; /\u0026gt; \u0026lt;p\u0026gt; Bacon ipsum dolor amet chislic beef ribs ball tip strip steak. Kevin alcatra tri-tip, sirloin ball tip prosciutto turducken venison pork loin corned beef short ribs pork chop cupim. Biltong capicola kevin, flank picanha sirloin jowl salami frankfurter burgdoggen buffalo rump. \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; overflow overflow 原本的作用指定了块容器元素的内容溢出时是否需要裁剪，“BFC”只是其衍生出来的特性，“剪裁”才是其本职工作；当子元素内容超出容器宽度高度限制的时候，剪裁的边界是 border-box 的内边缘，而非 padding-box 的内边缘。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; div { overflow: hidden; height: 310px; padding: 20px; border: 20px solid red; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;/images/avatar.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 对于 Webkit 浏览器，可以通过以下选择器修改滚动条样式：\n::-webkit-scrollbar，整个滚动条； ::-webkit-scrollbar-button，滚动条上的按钮（上下箭头）； ::-webkit-scrollbar-thumb，滚动条上的滚动滑块； ::-webkit-scrollbar-track，滚动条轨道； ::-webkit-scrollbar-track-piece，滚动条没有滑块的轨道部分； ::-webkit-scrollbar-corner，当同时有垂直滚动条和水平滚动条时交汇的部分； ::-webkit-resizer，某些元素的 corner 部分的部分样式（例，textarea 的可拖动按钮）。 文本溢出省略：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;style\u0026gt; div { outline: 1px solid red; text-overflow: ellipsis; white-space: nowrap; overflow: hidden; } section { margin-top: 8px; overflow: hidden; display: -webkit-box; word-break: break-all; outline: 1px solid red; /* 原始弹性布局草案的一个属性，已经被最新的标准替代 */ -webkit-box-orient: vertical; /* 可以把块容器中的内容限制为指定的行数 */ -webkit-line-clamp: 3; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; Rump chuck boudin ground round cow short ribs pastrami. Porchetta cow kevin short loin, beef bacon corned beef ball tip filet mignon swine ham. Chislic ham hock prosciutto beef leberkas pancetta picanha drumstick boudin meatball t-bone flank strip steak hamburger. Short ribs cow kielbasa spare ribs, tongue meatloaf pig bacon filet mignon ground round shankle. \u0026lt;/div\u0026gt; \u0026lt;section\u0026gt; Rump chuck boudin ground round cow short ribs pastrami. Porchetta cow kevin short loin, beef bacon corned beef ball tip filet mignon swine ham. Chislic ham hock prosciutto beef leberkas pancetta picanha drumstick boudin meatball t-bone flank strip steak hamburger. Short ribs cow kielbasa spare ribs, tongue meatloaf pig bacon filet mignon ground round shankle. \u0026lt;/section\u0026gt; absolute 一个元素的尺寸和位置经常受其包含块（containing block）的影响（比如说，width:50%，那到底是哪个“元素”宽度的一半呢？注意，这里的这个“元素”实际上就是指的“包含块”）；大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，确定一个元素的包含块的过程完全依赖于这个元素的 position 属性：\n根元素（html）所在的包含块被称为初始包含块，他的尺寸是视口 viewport； 如果 position:static/relative/sticky，包含块由它的最近的祖先块元素（比如说，inline-block、block 或 list-item 元素）的内容区的边缘组成； 如果 position:absolute，包含块就是由它的最近的 position 不是 static（也就是值为 fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成； 如果 position:fixed，包含块是视口 viewport。 没有设置 left/top/right/bottom 的绝对定位称为无依赖绝对定位；无依赖绝对定位本质上就是“相对定位”，仅仅是不占据 CSS 流的尺寸空间而已（一个不占据任何空间的相对定位元素）。一个无依赖绝对定位的元素，并且其祖先元素全部都是非定位元素，那么他的位置还是当前位置，不是在浏览器左上方；虽然说元素 position:absolute 后的 display 计算值都是块状的，但是其定位的位置和没有设置 position:absolute 时候的位置相关。absolute 是非常独立的 CSS 属性值，其样式和行为表现不依赖其他任何 CSS 属性就可以完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;style\u0026gt; h3 { margin: 0; padding: 0; } span, p { position: absolute; outline: 1px solid red; } \u0026lt;/style\u0026gt; \u0026lt;h3\u0026gt; 标题： \u0026lt;span\u0026gt;span-element\u0026lt;/span\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;h3\u0026gt; 标题： \u0026lt;p\u0026gt;p-element\u0026lt;/p\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;script\u0026gt; const spanEle = document.querySelector(\u0026#39;span\u0026#39;); const pEle = document.querySelector(\u0026#39;p\u0026#39;); console.log(window.getComputedStyle(spanEle).display); // block console.log(window.getComputedStyle(pEle).display); // block \u0026lt;/script\u0026gt; text-align 可以改变无依赖绝对定位元素的位置，原因是：\ndiv 内部，img 之前存在幽灵空白节点，受 text-align:center 影响而水平居中显示； 无依赖绝对定位的 img 本来的位置就应该在幽灵空白节点右边，而且不占空间。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;style\u0026gt; div { text-align: center; outline: 1px solid red; /* 如果 overflow 容器不是定位元素 同时 absolute 元素和 overflow 容器之间也没有定位元素 则 overflow 无法对 absolute 元素进行剪裁，也不会出现滚动条 position: relative; 加上这个，img 就会被裁剪 overflow: hidden; */ } img { position: absolute; width: 180px; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;/images/avatar.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 当 absolute 遇到 left/top/right/bottom 属性的时候，absolute 元素才真正变成绝对定位元素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;style\u0026gt; div { position: relative; outline: 1px solid red; } p { position: absolute; margin: 0; padding: 0; } p:nth-of-type(1) { top: 8px; left: 0; outline: 1px solid blue; } p:nth-of-type(2) { top: 38px; left: 0; right: 0; outline: 1px solid green; } p:nth-of-type(3) { top: 68px; right: 0; outline: 1px solid orange; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 层叠规则 层叠上下文（stacking context），是 HTML 中的一个三维的概念；如果一个元素含有层叠上下文，我们可以理解为这个元素在 z 轴（垂直于显示器）上就“高人一等”。\n层叠水平（stacking level），决定了同一个层叠上下文中元素在 z 轴上的显示顺序。\n层叠顺序（stacking order），表示元素发生层叠时有着特定的垂直显示顺序。\nbackground/border 为装饰属性，浮动和块状元素一般用作布局，而内联元素都是内容。\n当元素发生层叠的时候，其覆盖关系遵循下面两条准则：\n谁大谁上，当具有明显的层叠水平标识的时候，如生效的 z-index 属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个； 后来居上，当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。 层叠上下文元素有如下特性：\n层叠上下文的层叠水平要比普通元素高； 层叠上下文可以阻断元素的混合模式； 层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受制于“外部的层叠上下文”； 每个层叠上下文和兄弟元素独立，也就是说，当进行层叠变化或渲染的时候，只需要考虑后代元素； 每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。 根层叠上下文指的是页面根元素，可以看成是 \u0026lt;html\u0026gt;元素。因此，页面中所有的元素一定处于至少一个“层叠结界”中。\n对于 position:relative/absolute 以及 Firefox/IE 下含有 position:fixed 声明的定位元素，当其 z-index 值不是 auto 的时候，会创建层叠上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;div style=\u0026#34;position: relative; z-index: auto\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;position: absolute; z-index: 2\u0026#34; src=\u0026#34;./cat.jpg\u0026#34; class=\u0026#34;cat\u0026#34; alt=\u0026#34;猫\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;position: relative; z-index: auto\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;position: absolute; z-index: 1\u0026#34; src=\u0026#34;./car.jpg\u0026#34; class=\u0026#34;car\u0026#34; alt=\u0026#34;车\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;div style=\u0026#34;position: relative; z-index: 0\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;position: absolute; z-index: 2\u0026#34; src=\u0026#34;./cat.jpg\u0026#34; class=\u0026#34;cat\u0026#34; alt=\u0026#34;猫\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div style=\u0026#34;position: relative; z-index: 0\u0026#34;\u0026gt; \u0026lt;img style=\u0026#34;position: absolute; z-index: 1\u0026#34; src=\u0026#34;./car.jpg\u0026#34; class=\u0026#34;car\u0026#34; alt=\u0026#34;车\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 层叠上下文的创建：\nflex 布局元素（display:flex/inline-flex），同时 z-index 值不是 auto； 元素的 opacity 值不是 1； 元素的 transform 值不是 none； 元素的 mix-blend-mode 值不是 normal； 元素的 filter 值不是 none； 元素的 isolation 值是 isolate； 元素的 will-change 属性值为上面 2 ～ 6 的任意一个（如 will-change:opacity）； 元素的 -webkit-overflow-scrolling 值是 touch。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;style\u0026gt; div { background-color: cornflowerblue; width: 270px; height: 270px; /* opacity: 0.99; */ } div img { position: relative; right: -50%; height: 100%; z-index: -1; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;img src=\u0026#34;./cat.jpg\u0026#34; alt=\u0026#34;猫\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; z-index 负值可以隐藏元素，只需要层叠上下文内的某一个父元素加个背景色就可以。它与 clip 隐藏相比的一个优势是，元素无须绝对定位，设置 position:relative 也可以隐藏；另一个优势是，它对原来的布局以及元素的行为没有任何影响，而 clip 隐藏会导致控件 focus 的焦点发生细微的变化，在特定条件下是有体验问题的。它的不足之处就是不具有普遍适用性，需要其他元素配合进行隐藏。\nfont font-size 的关键字属性分为两类：\n相对尺寸关键字：相对于当前元素计算： large：\u0026lt;big/\u0026gt; 元素的默认 font-size 属性值； small：\u0026lt;small/\u0026gt; 元素的默认 font-size 属性值。 绝对尺寸关键字：与当前元素 font-size 无关，仅仅受浏览器设置的字号影响： xx-large：和 \u0026lt;h1/\u0026gt; 元素的计算值一样； x-large：和 \u0026lt;h2/\u0026gt; 元素的计算值一样； large：和 \u0026lt;h3/\u0026gt; 元素的计算值近似（偏差在一个像素以内）； medium：font-size 的初始值，和 \u0026lt;h4/\u0026gt; 元素的计算值一样； small：和 \u0026lt;h5/\u0026gt; 元素的计算值近似； x-small：和 \u0026lt;h6/\u0026gt; 元素的计算值近似； xx-small：无对应的 HTML 元素。 由于浏览器限制，并不是所有小于 12px 的 font-size 都会被当作 12px 处理；有一个值例外，那就是 0，如果 font-size:0，那么文字会直接被隐藏掉，并且只能是 font-size:0，哪怕设置成 font-size:0.0000001px，都还是会被当作 12px 处理的。\nfont-family 默认值由操作系统和浏览器共同决定，例如 Windows 和 macOS 下的 Chrome 默认字体不一样，Windows 下的 Chrome 和 Firefox 默认字体也不一样；font-family 支持两类属性值，一类是“字体名”，一类是“字体族”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 body { /* 不用区分大小写 */ font-family: simsun; } section { /* 如果字体名包含空格，需要使用引号包起来 */ font-family: \u0026#39;Microsoft Yahei\u0026#39;; } span { /* 如果有多个字体设定，从左往右依次寻找本地是否有对应的字体即可 */ font-family: \u0026#39;PingFang SC\u0026#39;, \u0026#39;Microsoft Yahei\u0026#39;; } i { /* 通用字体族分很多类 */ font-family: serif; /* 衬线字体 */ font-family: sans-serif; /* 无衬线字体 */ font-family: monospace; /* 等宽字体 */ font-family: cursive; /* 手写字体，例如中文楷体 */ font-family: fantasy; /* 奇幻字体，用来装饰，字形和原本字符可以没有关系，例如，自定义图标 */ font-family: system-ui; /* 系统 UI 字体 */ } 衬线字体，通俗讲就是笔画开始、结束的地方有额外装饰而且笔画的粗细会有所不同的字体。比如：宋体、Times New Roman、Georgia 等。无衬线字体没有这些额外的装饰，而且笔画的粗细差不多，比如：雅黑、Arial、Verdana、Tahoma、Helivetica 等。在大多数浏览器下，写在 serif 和 sans-serif 后面的所有字体都会被忽略。\n所谓等宽字体，一般是针对英文字体而言的。东亚字体应该都是等宽的，就是每个字符在同等 font-size 下占据的宽度是一样的。但是英文字体就不一定了。\n微软正黑体是一款全面支持 ClearType 技术的 TrueType 无衬线字体，用于繁体中文系统；对于微软雅黑和微软正黑，这两套字体都同时包含了比较完整的简体和繁体汉字，但这两套字形在正式场合是不能混淆使用的。\n平常所说的“宋体”，指的都是“中易宋体”，英文名称 SimSun。macOS 内置的“宋体 - 简”和我们平常所说的“宋体”并不是同一个字体，其英文名称是“Songti SC”，字形表现也有差异。\nfont-weight 如果使用数值作为属性值，必须是 100-900 的整百数，没有 x50 这种东西；font-weight:400 等同于 font-weight:normal；font-weight:700 等同于 font-weight:bold。浏览器支持 100-900 的整百数，没有效果是因为系统缺乏对应粗细的字体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;style\u0026gt; p { font-family: \u0026#39;MiSans\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 100;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 200;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 300;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 400;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 500;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 600;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 700;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 800;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;font-weight: 900;\u0026#34;\u0026gt;轻如鸿毛，重如泰山\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; font-style 的三个属性值中 italic 和 oblique 这两个关键字都表示“斜体”的意思，差别在于：italic 是使用当前字体的斜体字体，而 oblique 只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为 oblique，也就是单纯形状倾斜。\n让各个系统使用各自引以为傲的字体（让网页的字体跟系统走），三种声明都可以：\n1 2 3 4 5 6 7 8 9 10 11 12 html { font: menu; } html { font: small-caption; } html { font: status-bar; } body { font-size: 16px; } 凡是使用自定义字体的，差不多都是下面这种格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;pre alt=\u0026#34;传统版本\u0026#34;\u0026gt; @font-face { font-family: ICON; /* eot 是 IE 的私有格式，兼容模式的 IE 不认识『?』，所以才有了这一行多余的 src */ src: url(\u0026#39;icon.eot\u0026#39;) format(\u0026#39;eot\u0026#39;); /* #iefix 没什么用，有用的是『?』，防止 IE 对地址的错误解析 */ src: url(\u0026#39;icon.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* woff2 比 woff 体积更小，Web 开发首选，仅 Chrome 和 Firefox 支持比较好 */ url(\u0026#39;icon.woff2\u0026#39;) format(\u0026#34;woff2\u0026#34;), /* woff（WebOpenFontFormat）是专门为 Web 开发的字体，Android 4.4 开始支持 */ url(\u0026#39;icon.woff\u0026#39;) format(\u0026#34;woff\u0026#34;), /* ttf 为操作系统字体，缺点是体积大 */ url(\u0026#39;icon.ttf\u0026#39;) format(\u0026#34;typetrue\u0026#34;), /* svg 格式是为了兼容 iOS 4.1 以及之前的版本 */ url(\u0026#39;icon.svg#icon\u0026#39;) format(\u0026#39;svg\u0026#39;); /* format 是用来帮助浏览器识别字体格式的，最好不要省略 */ font-weight: normal; /* 多余，用来实现响应式字体，不同字重的情况下使用不同字体 */ font-style: normal; /* 多余，用来实现响应式字体，不同样式的情况下使用不同字体 */ } \u0026lt;/pre\u0026gt; \u0026lt;pre alt=\u0026#34;精简版本\u0026#34;\u0026gt; @font-face { font-family: ICON; src: url(\u0026#39;icon.eot\u0026#39;); src: local(\u0026#39;☺\u0026#39;), /* local 使用系统安装字体，url 使用外部字体，IE6-8 不认识 */ url(\u0026#39;icon.woff2\u0026#39;) format(\u0026#34;woff2\u0026#34;), url(\u0026#39;icon.woff\u0026#39;) format(\u0026#34;woff\u0026#34;), url(\u0026#39;icon.ttf\u0026#39;) format(\u0026#34;typetrue\u0026#34;); } \u0026lt;/pre\u0026gt; \u0026lt;pre\u0026gt; @font-face { font-family: quote; src: local(\u0026#39;SimSun\u0026#39;); /* 用来指定哪些字符使用 SimSun 字体 */ unicode-range: U+201c, U+201d; } .font { /* 效果就是，引号使用 SimSun 字体，其他文字使用 Microsoft Yahei 字体 */ font-family: quote, \u0026#39;Microsoft Yahei\u0026#39;; } \u0026lt;/pre\u0026gt; text-indent text-indent 可以在标签受限的情况下，实现特殊的布局效果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;style\u0026gt; p { padding-left: 25px; text-indent: -21px; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;Q: Bacon ipsum dolor amet ribeye tongue pancetta picanha?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; A: Pastrami turducken chislic sirloin prosciutto. Pancetta alcatra strip steak cupim, jerky venison drumstick pig tail porchetta bacon short ribs hamburger jowl biltong. Kevin short ribs pig frankfurter tongue buffalo. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Q: Pork loin drumstick ball tip burgdoggen pork chop filet?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; A: Turducken ham hock rump, shankle shank pork chop capicola. Shankle sausage short loin ground round pork loin. Strip steak salami chislic, cow hamburger bacon kevin beef shank ground round prosciutto flank pastrami. \u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Q: Strip steak fatback andouille pork chop salami jerky?\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt; A: Tri-tip shank shoulder bresaola. Rump kielbasa shankle, sirloin bresaola filet mignon ground round meatball tail. Prosciutto porchetta strip steak drumstick jowl corned beef pork chop cupim turkey biltong pancetta swine. \u0026lt;/p\u0026gt; text-indent 应该注意几点：\ntext-indent 仅对第一行内联盒子内容有效； 非替换元素以外的 display 计算值为 inline 的内联元素设置 text-indent 值无效；如果计算值是 inline-block/inline-table 则会生效。因此，如果父级块状元素设置了 text-indent 属性值，子 inline-block/inline-table 需要设置 text-indent:0 重置； \u0026lt;input/\u0026gt; 标签按钮 text-indent 值无效； \u0026lt;button/\u0026gt; 标签按钮 text-indent 值有效，但是存在兼容性差异，IE 理解为单标签，百分比值按照容器计算，而 Chrome/Firefox 标签内还有其他 ShadowDOM 元素，因此百分比值是按照自身的尺寸计算的； \u0026lt;input/\u0026gt; 和 \u0026lt;textarea/\u0026gt; 输入框的 text-indent 在低版本 IE 下有兼容问题。 letter-spacing letter-spacing 具有一下特征：\n继承性； 默认值是 normal 而不是 0，虽然说正常情况下，normal 的计算值就是 0，但在有些场景下，letter-spacing 会调整 normal 的计算值以实现更好的版面布局； 支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列（非 IE）； 和 text-indent 属性一样，无论值多大或多小，第一行一定会保留至少一个字符。在默认的左对齐情况下，无论值如何设置，第一个字符的位置一定是纹丝不动的； 支持小数值，即使 0.1px 也是支持的，但并不总能看到效果，这与屏幕的像素密度有关。对普通的桌面显示器，设备像素比是 1，最小渲染单位是 1px，因此，需要至少连续 10 个字符，才能看到 0.1px 产生的 1px 间距变化，如果是 9 个字符，则不会有效果，这很可能会让人误以为 letter-spacing 不支持非常小的数值，实际上是支持的； 暂不支持百分比值。 word-spacing word-spacing 和 letter-spacing 名称类似，其特性也有很多共通之处：\n都具有继承性； 默认值都是 normal 而不是 0；通常情况下，两者表现并无差异； 都支持负值，都可以让字符重叠，但是对于 inline-block 和 inline-table 元素却存在兼容性差异，Chrome 下可以重叠，IE/Firefox 下则再大的负值也不会重叠，因此不适合使用 word-spacing 来清除空白间隙； 都支持小数值，如 word-spacing:0.5px； 间隔算法都会受到 text-align:justify 两端对齐的影响； letter-spacing 作用于所有字符，word-spacing 仅作用于空格字符（即可以是键盘敲出来的空格 Space/Tab，也可以是换行符产生的空格）。 word-break:break-all 与 word-wrap:break-word word-break 的属性如下：\nnormal，使用默认的换行规则； break-all，允许任意非 CJK（Chinese/Japanese/Korean）文本间的单词断行； keep-all，CJK 只能在半角空格或连字符处换行；非 CJK 文本的行为实际上和 normal。 word-wrap 的属性如下：\nnormal，正常的换行规则； break-word，一行单词中实在没有其他靠谱的换行点的时候换行。 1 2 3 4 5 6 7 8 \u0026lt;p style=\u0026#34;word-break: break-all;\u0026#34;\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;word-wrap: break-word;\u0026#34;\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/p\u0026gt; white-space white-space 声明了如何处理元素内的空白字符，这类空白字符包括 Space、Enter、Tab 产生的空白。因此，white-space 可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值包括下面这些：\nnormal，合并空白字符（多个空格变成一个）和换行符（多个连续换行合并成一个，并当作一个普通空格处理）； pre，不合并空白字符，内容只在有换行符的地方换行； nowrap，合并空白字符，但不允许文本环绕，元素的宽度此时表现为“最大可用宽度”，换行符和一些空格全部合并，文本一行显示； pre-wrap，不合并空白字符，内容只在有换行符的地方换行，允许文本环绕（一行文字内容超出容器宽度时，会自动从下一行开始显示）； pre-line，合并空白字符，内容只在有换行符的地方换行，允许文本环绕。 text-align:justify 在默认设置下，text-align:justify 要想有两端对齐的效果，需要满足两点：\n有分隔点，如空格； 要超过一行，不足一行，不会两端对齐； text-align-last:justify，兼容性不是很好（Safari/IE）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;style\u0026gt; .justify { /* 如果不酱紫，容器下方会多出一行 */ font-size: 0; } .justify::after { content: \u0026#39;\u0026#39;; display: inline-block; width: 100%; } .justify \u0026gt; span { font-size: 16px; } \u0026lt;/style\u0026gt; \u0026lt;p style=\u0026#34;text-align: initial;\u0026#34;\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;text-align: justify;\u0026#34;\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;text-align: justify; text-align-last: justify;\u0026#34;\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;text-align: justify;\u0026#34; class=\u0026#34;justify\u0026#34; alt=\u0026#34;这种方法需要额外的元素辅助\u0026#34; \u0026gt; \u0026lt;span\u0026gt; 如果您在阅读过程中有任何疑问或者发现表述不严谨的地方，欢迎去官方论坛 http://bbs.cssworld.cn 进行反馈与交流。 \u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; ::first-letter 与 ::first-line ::first-letter/::first-line 生效的前提：\n不是所有的字符都能单独作为 ::first-letter 伪元素存在的；常见的标点符号、各类括号和引号都不行（::first-line 不适用）； 可以作为 ::first-letter 伪元素的字符：数字、字母、中文、$、运算符、空格等（::first-line 不适用）； 元素的 display 计算值必须是：block、inline-block、list-item、table-cell、table-caption； ::first-letter 伪元素是作为子元素存在的，或者说应当被看作是子元素，CSS 权重更高； 应用在 ::first-letter 伪元素上的 CSS 只有一部分规则有效。 display、opacity、visibility HTML 中有很多标签和属性天然 display:none，如 \u0026lt;style/\u0026gt;、\u0026lt;script/\u0026gt;、\u0026lt;dialog/\u0026gt;、[type=\u0026ldquo;hidden\u0026rdquo;] 元素。如果这些标签在 \u0026lt;body/\u0026gt; 元素中，设置 display:block 是可以让内联 CSS 和 JS 代码直接在页面中显示的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;body\u0026gt; \u0026lt;style style=\u0026#34;display: block; border: 1px solid red;\u0026#34; alt=\u0026#34;必须在 body 中\u0026#34;\u0026gt; p { padding: 8px; background-color: darkcyan; margin: 0 0 48px; border: 1px solid transparent; } .justify { font-size: 0; } .justify::after { content: \u0026#39;\u0026#39;; display: inline-block; /* vertical-align: bottom; */ width: 100%; } .justify \u0026gt; span { font-size: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script style=\u0026#34;display: block; border: 1px solid blue;\u0026#34; alt=\u0026#34;必须在 body 中\u0026#34;\u0026gt; console.log(\u0026#39;really?\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; cursor cursor:none 可以隐藏用户鼠标光标，全屏看视频时，可以判断用户行为，自动隐藏鼠标。\ncursor:context-menu 适用于自定义上下文菜单的情形，例如，邮箱、网盘等。\ncursor:default 常搭配 user-select:none 属性使用，表示当前内容不可选。\ncursor:cell 可以让光标变为 Excel 里的样式。\ndirection direction 设计的本意是为了兼顾阿拉伯语、希伯来语等从右往左的语言，他有两个属性值：\nltr，默认值，从左往右； rtl，从右往左。 direction 可以轻易的改变元素的水平呈现顺序；例如，桌面弹窗的确认按钮在左，移动端弹窗的确认按钮在右，就可以简单的通过媒体查询实现。\n","date":"2022-01-02T00:00:00Z","image":"https://vikingama.github.io/img/cover/css.png","permalink":"https://vikingama.github.io/p/css-%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/","title":"《CSS 世界》笔记"},{"content":"看完这篇文章，你将掌握：\ncomponentDidCatch 原理； Suspense 原理； 异步组件原理。 不可能的事 我的函数组件中里可以随便写，很多同学看到这句话的时候，脑海里应该浮现的四个字是：怎么可能？因为我们印象中的函数组件，是不能直接使用异步的，而且必须返回一段 JSX 代码。\n那么今天我将打破这个规定，在我们认为是组件的函数里做一些意想不到的事情。接下来跟着我的思路往下看吧。\n首先先来看一下 JSX，在 JSX 中 \u0026lt;div/\u0026gt; 代表 DOM 元素，而 \u0026lt;Index/\u0026gt; 代表组件，Index 本质是函数组件或类组件。\n透过现象看本质，JSX 为 ReactElement 的表象，JSX 语法糖会被 Babel 编译成 ReactElement 对象，那么上述中：\n\u0026lt;div/\u0026gt; 不是真正的 DOM 元素，是 type 属性为 div 的 element 对象； \u0026lt;Index/\u0026gt; 是 type 属性为类或者组件本身的 element 对象。 言归正传，那么以函数组件为参考，Index 已经约定俗成为这个样子：\n1 2 3 4 5 6 7 8 9 10 11 12 function Index() { /** * 不能直接的进行异步操作 * return 一段 JSX 代码 */ return ( \u0026lt;div\u0026gt; Beef ribs pork chop cow corned beef pastrami salami shoulder fatback porchetta alcatra. \u0026lt;/div\u0026gt; ); } 如果不严格按照这个格式写，通过 \u0026lt;Index/\u0026gt; 形式挂载，就会报错。看如下的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 不是严格的组件形式 function Index() { return { name: \u0026#39;《React 进阶实践指南》\u0026#39; }; } // 正常挂载 Index 组件 class App extends React.Component { render() { return ( \u0026lt;div\u0026gt; hello world, let us learn React! \u0026lt;Index /\u0026gt; \u0026lt;/div\u0026gt; ); } } 我们通过报错信息，不难发现原因，children 类型错误，children 应该是一个 ReactElement 对象；但是 Index 返回的却是一个普通的对象。\n既然不能是普通的对象，那么如果 Index 里面更不可能有异步操作了；比如，如下这种情况：\n1 2 3 4 5 6 7 function Index() { return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ name: \u0026#39;《React 进阶实践指南》\u0026#39; }); }, 1000); }); } 同样也会报上面的错误，所以在一个标准的 React 组件规范下：\n必须返回 JSX 对象结构，不能返回普通对象； render 执行过程中，不能出现异步操作。 不可能的事变为可能 那么如何破局，将不可能的事情变得可能。首先要解决的问题是报错问题，只要不报错，App 就能正常渲染。不难发现产生的错误时机都是在 render 过程中。那么就可以用 React 提供的两个渲染错误边界的生命周期 componentDidCatch 和 getDerivedStateFromError。\n因为我们要在捕获渲染错误之后做一些骚操作，所以这里选 componentDidCatch。接下来我们用 componentDidCatch 改造一下 App：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class App extends React.component { state = { isError: false }; componentDidCatch(e) { this.setState({ isError: true }); } render() { return ( \u0026lt;div\u0026gt; hello world, let us learn React! {!this.state.isError \u0026amp;\u0026amp; \u0026lt;Index /\u0026gt;} \u0026lt;/div\u0026gt; ); } } 用 componentDidCatch 捕获异常，渲染异常；虽然还是报错，但是至少页面可以正常渲染了。现在做的事情还不够，以 Index 返回一个正常对象为例，我们想要挂载这个组件，还要获取 Index 返回的数据，那么怎么办呢？\n突然想到 componentDidCatch 能够捕获到渲染异常，那么它的内部就应该像 try\u0026hellip;catch 一样，通过 catch 捕获异常。类似下面这种：\n1 2 3 4 5 6 try { // 尝试渲染 } catch (e) { // 渲染失败，执行 componentDidCatch(e) componentDidCatch(e); } 那么如果在 Index 中抛出的错误，是不是也可以在 componentDidCatch 接收到？于是说干就干。我们把 Index 由 return 变成 throw，然后在 componentDidCatch 打印错误 error。\n1 2 3 4 5 function Index() { throw { name: \u0026#39;《React 进阶实践指南》\u0026#39; }; } 通过 componentDidCatch 捕获错误；此时的 e 就是 Index 组件 throw 的对象；接下来用子组件抛出的对象渲染。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class App extends React.Component { state = { isError: false, childThrowMsg: {} }; componentDidCatch(e) { // error: {name: \u0026#39;《React 进阶实践指南》\u0026#39;} console.log(\u0026#39;error:\u0026#39;, e); this.setState({ isError: true, childThrowMsg: e }); } render() { return ( \u0026lt;div\u0026gt; hello world, let us learn React! {!this.state.isError ? ( \u0026lt;Index /\u0026gt; ) : ( \u0026lt;div\u0026gt;{this.state.childThrowMsg.name}\u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } } 捕获到 Index 抛出的异常对象，用异常对象里面的数据重新渲染；大功告成，子组件 throw 错误，父组件 componentDidCatch 接受并渲染，这波操作是不是有点\u0026hellip;\n但是 throw 的所有对象，都会被正常捕获吗？于是我们把第二个 Index 抛出的 Promise 对象用 componentDidCatch 捕获。看看会是什么吧？\n如上所示，Promise 对象没有被正常捕获，捕获的是异常的提示信息。在异常提示中，可以找到 Suspense 的字样。那么 throw Promise 和 Suspense 之间肯定存在着关联，换句话说就是 Suspense 能够捕获到 Promise 对象。而这个错误警告，就是 React 内部发出找不到上层的 Suspense 组件的错误。\n到此为止，可以总结出：\ncomponentDidCatch 通过 try\u0026hellip;catch 捕获到异常；如果我们在渲染过程中，throw 出来的普通对象，也会被捕获到。但是 Promise 对象，会被 React 底层第二次抛出异常； Suspense 内部可以接受 throw 出来的 Promise 对象，那么内部有一个 componentDidCatch 专门负责异常捕获。 鬼畜版，我的组件可以写异步 即然直接 throw Promise 会在 React 底层被拦截，那么如何在组件内部实现正常编写异步操作的功能呢？既然 React 会拦截组件抛出的 Promise 对象，那么如果把 Promise 对象包装一层呢？于是我们把 Index 内容做修改。\n1 2 3 4 5 6 7 8 9 function Index() { throw { current: new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ name: \u0026#39;《React 进阶实践指南》\u0026#39; }); }, 1000); }) }; } 如上，这回不再直接抛出 Promise，而是在 Promise 的外面在包裹一层对象。接下来打印错误看一下。\n可以看到，能够直接接收到 Promise 啦，接下来我们执行 Promise 对象，模拟异步请求，用请求之后的数据进行渲染。于是修改 App 组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class App extends React.Component { state = { isError: false, childThrowMsg: {} }; componentDidCatch(e) { const errorPromise = e.current; Promise.resolve(errorPromise).then(res =\u0026gt; { this.setState({ isError: true, childThrowMsg: res }); }); } render() { return ( \u0026lt;div\u0026gt; hello world, let us learn React! {!this.state.isError ? ( \u0026lt;Index /\u0026gt; ) : ( \u0026lt;div\u0026gt;{this.state.childThrowMsg.name}\u0026lt;/div\u0026gt; )} \u0026lt;/div\u0026gt; ); } } 在 componentDidCatch 的参数 e 中获取 Promise，Promise.resolve 执行 Promise 获取数据并渲染；数据正常渲染了，但是面临一个新的问题：目前的 Index 不是一个真正意义上的组件，而是一个函数；所以接下来，改造 Index 使其变成正常的组件，通过获取异步的数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Index({ isResolve = false, data }) { const [likeNumber, setLikeNumber] = React.useState(0); if (isResolve) { return ( \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;名称：{data.name}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;点赞：{likeNumber}\u0026lt;/p\u0026gt; \u0026lt;button onClick={() =\u0026gt; setLikeNumber(likeNumber + 1)}\u0026gt;点赞\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } else { throw { current: new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { // resolve 的数据会通过 data 传进来 resolve({ name: \u0026#39;《React 进阶实践指南》\u0026#39; }); }, 1000); }) }; } } Index 中通过 isResolve 判断组件是否加载完成；第一次的时候 isResolve 为 false，所以 throw Promise。\n父组件 App 中接受 Promise，得到数据，改变 isResolve 状态；二次渲染，那么第二次 Index 就会正常渲染了。看一下 App 如何写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class App extends React.Component { state = { isResolve: false, data: {} }; componentDidCatch(e) { const errorPromise = e.current; Promise.resolve(errorPromise).then(res =\u0026gt; { this.setState({ isResolve: true, data: res }); }); } /** * 绕了一大圈，通过 componentDidCatch 捕获 Index 的 Promise 的值 * 然后，将捕获到的值，通过 props 再回传给 Index 进行渲染 */ render() { const { isResolve, data } = this.state; return ( \u0026lt;div\u0026gt; hello world, let us learn React! \u0026lt;Index data={data} isResolve={isResolve} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 通过 componentDidCatch 捕获错误，然后进行第二次渲染。\n飞翔版，实现一个简单 Suspense Suspense 是什么？Suspense 英文翻译『悬停』。在 React 中 Suspense 是什么呢？那么正常情况下组件渲染是一气呵成的，在 Suspense 模式下的组件渲染就变成了可以先悬停下来。\n首先解释为什么悬停？Suspense 在 React 生态中的位置，重点体现在以下方面：\ncodeSplitting（代码分割）：哪个组件加载，就加载哪个组件的代码；听上去挺拗口，可确实打实的解决了主文件体积过大的问题，间接优化了项目的首屏加载时间，我们知道过浏览器加载资源也是耗时的，这些时间给用户造成的影响就是白屏效果； spinner 解耦：正常情况下，页面展示是需要前后端交互的，数据加载过程不期望看到：无数据状态 -\u0026gt; 闪现数据的场景，更期望的是一种 spinner 数据加载状态 -\u0026gt; 加载完成展示页面状态； renderData：整个 render 过程都是同步执行一气呵成的，那样就会：组件 render -\u0026gt; 请求数据 -\u0026gt; 组件 reRender；但是在 Suspense 异步组件情况下允许调用 render -\u0026gt; 发现异步请求 -\u0026gt; 悬停，等待异步请求完毕 -\u0026gt; 再次渲染展示数据。这样无疑减少了一次渲染。 1 2 \u0026lt;List1 /\u0026gt; \u0026lt;List2 /\u0026gt; List1 和 List2 都使用服务端请求数据，那么在加载数据过程中，需要 Spin 效果去优雅的展示 UI，所以需要一个 Spin 组件；但是 Spin 组件需要放入 List1 和 List2 的内部，就造成耦合关系。现在通过 Suspense 来接耦 Spin，在业务代码中这么写道：\n1 2 3 4 \u0026lt;Suspense fallback={\u0026lt;Spin /\u0026gt;}\u0026gt; \u0026lt;List1 /\u0026gt; \u0026lt;List2 /\u0026gt; \u0026lt;/Suspense\u0026gt; 上面理解了 Suspense 初衷，接下来分析一波原理；首先通过上文中，已经交代了 Suspense 原理，如何悬停，很简单粗暴，直接抛出一个异常。\n异常是什么，一个 Promise，这个 Promise 也分为二种情况：\n第一种就是异步请求数据，这个 Promise 内部封装了请求方法，请求数据用于渲染； 第二种就是异步加载组件，配合 Webpack 提供的 require API，实现代码分割。 悬停后再次 render。\n在 Suspense 悬停后，如果想要恢复渲染，那么 reRender 一下就可以了。\n如上详细介绍了 Suspense。接下来到了实践环节，我们去尝试实现一个 Suspense，首先声明一下这个 Suspense 并不是 React 提供的 Suspense，这里只是模拟了一下它的大致实现细节。\n本质上，Suspense 落地的瓶颈也是对请求函数的封装，Suspense 主要接收 Promise，并 resolve 它；那么对于成功的状态回传到异步组件中，对于开发者来说是未知的，对于 Promise 和状态传递的函数 createFetcher，应该满足如下的条件：\n通过 createFetcher 封装请求函数；请求函数 getData 返回一个 Promise，这个 Promise 的使命就是完成数据交互； 一个模拟的异步组件，内部使用 createFetcher 创建的请求函数，请求数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const fetch = createFetcher(function getData() { return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve({ name: \u0026#39;《React 进阶实践指南》\u0026#39;, author: \u0026#39;alien\u0026#39; }); }, 1000); }); }); function Text() { const data = fetch(); return ( \u0026lt;div\u0026gt; name: {data.name} author:{data.author} \u0026lt;/div\u0026gt; ); } 接下来就是 createFetcher 函数的编写：\n这里要注意的是 fn 就是 getData，getDataPromise 就是 getData 返回的 Promise； 返回一个函数 fetch，在 Text 内部执行；第一次组件渲染，由于 status=pending 所以抛出异常 fetcher 给 Suspense，渲染中止； Suspense 会在内部 componentDidCatch 处理这个 fetcher，执行 getDataPromise.then，这个时候 status 已经是 resolve 状态，数据也能正常返回了； 接下来 Suspense 再次渲染组件，此时就能正常的获取数据了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function createFetcher(fn) { const fetcher = { status: \u0026#39;pending\u0026#39;, result: null, p: null }; return function () { const getDataPromise = fn(); fetcher.p = getDataPromise; getDataPromise.then(result =\u0026gt; { /* 成功获取数据 */ fetcher.result = result; fetcher.status = \u0026#39;resolve\u0026#39;; }); if (fetcher.status === \u0026#39;pending\u0026#39;) { /* 第一次执行中断渲染 */ throw fetcher; } /* 第二次执行 */ if (fetcher.status === \u0026#39;resolve\u0026#39;) return fetcher.result; }; } 既然有了 createFetcher 函数，接下来就要模拟上游组件 Suspense。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MySuspense extends React.Component { state = { isResolve: true }; componentDidCatch(fetcher) { const p = fetcher.p; this.setState({ isResolve: false }); Promise.resolve(p).then(() =\u0026gt; { this.setState({ isResolve: true }); }); } render() { const { fallback, children } = this.props; const { isResolve } = this.state; return isResolve ? children : fallback; } } 我们编写的 Suspense 起名字叫 MySuspense；MySuspense 内部 componentDidCatch 通过 Promise.resolve 捕获 Promise 成功的状态。成功后，取缔 fallback 效果。\n大功告成，接下来就是体验环节了。我们尝试一下 MySuspense 效果。\n1 2 3 4 5 6 7 function Index() { return ( \u0026lt;MySuspense fallback={\u0026lt;div\u0026gt;loading...\u0026lt;/div\u0026gt;}\u0026gt; \u0026lt;Text /\u0026gt; \u0026lt;/MySuspense\u0026gt; ); } 虽然实现了效果，但是和真正的 Suspense 还差的很远；首先暴露出的问题就是数据可变的问题。上述编写的 MySuspense 数据只加载一次，但是通常情况下，数据交互是存在变数的，数据也是可变的。\n衍生版，实现一个错误异常处理组件 言归正传，我们不会在函数组件中做如上的骚操作，也不会自己去编写 createFetcher 和 Suspense。但是有一个场景还是蛮实用的，那就是对渲染错误的处理，以及 UI 的降级，这种情况通常出现在服务端数据的不确定的场景下，比如我们通过服务端的数据 data 进行渲染，像如下场景：\n1 \u0026lt;div\u0026gt;{data.name}\u0026lt;/div\u0026gt; 如果 data 是一个对象，那么会正常渲染；但是如果 data 是 null，那么就会报错；如果不加渲染错误边界，那么一个小问题会导致整个页面都渲染不出来。\n那么对于如上情况，如果每一个页面组件，都加上 componentDidCatch 这样捕获错误，降级 UI 的方式，那么代码过于冗余，难以复用，无法把降级的 UI 从业务组件中解耦出来。\n所以可以统一写一个 RenderControlError 组件，目的就是在组件的出现异常的情况，统一展示降级的 UI；也确保了整个前端应用不会奔溃，同样也让服务端的数据格式容错率大大提升。接下来看一下具体实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RenderControlError extends React.Component { state = { isError: false }; componentDidCatch() { this.setState({ isError: true }); } render() { return !this.state.isError ? ( this.props.children ) : ( \u0026lt;div style={styles.errorBox}\u0026gt; \u0026lt;img url={require(\u0026#39;../../assets/img/error.png\u0026#39;)} style={styles.erroImage} /\u0026gt; \u0026lt;span style={styles.errorText}\u0026gt;出现错误\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } } 如果 children 出错，那么降级 UI。\n1 2 3 \u0026lt;RenderControlError\u0026gt; \u0026lt;Index /\u0026gt; \u0026lt;/RenderControlError\u0026gt; 本文通过一些脑洞大开，奇葩的操作，让大家明白了 Suspense、componentDidCatch 等原理。我相信不久之后，随着 React 18 发布，Suspense 将崭露头角，未来可期。\n参考 我在函数组件中可以随便写，最通俗异步组件原理 ","date":"2021-12-31T00:00:00Z","image":"https://vikingama.github.io/img/cover/react.png","permalink":"https://vikingama.github.io/p/%E8%BD%AC%E6%88%91%E5%9C%A8%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%8F%AF%E4%BB%A5%E9%9A%8F%E4%BE%BF%E5%86%99%E6%9C%80%E9%80%9A%E4%BF%97%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%E5%8E%9F%E7%90%86/","title":"「转」我在函数组件中可以随便写，最通俗异步组件原理"},{"content":"首先，需要有一个滚动容器 div 来放置滚动列表 ul；按照通常的渲染方式，ul 里会有大量（成千上万）的列表元素 li；当对某一个 li 进行 DOM 操作时（比如，一些股票软件会通过高亮的方式实时渲染此支股票的涨跌），需要先遍历所有 li，找到要进行操作的元素，再进行 DOM 操作。此时，页面可能会因为 DOM 树过于庞大而占用大量内存，页面渲染可能卡顿。而虚拟滚动要做的，就是在保证用户正常交互体验的同时尽可能少的渲染 DOM，提升页面的响应速度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } body { height: 100vh; display: flex; justify-content: center; align-items: center; } .container { height: 80vh; width: 80vw; overflow-y: scroll; outline: 1px solid orange; } .list { box-sizing: border-box; } .list li { width: 100%; height: 36px; outline: 1px solid red; text-align: center; line-height: 36px; } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;ul class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;!-- \u0026lt;li\u0026gt;...\u0026lt;/li\u0026gt; --\u0026gt; \u0026lt;!-- ... --\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 具体逻辑如下：\n首先计算用户可以看到的元素数量； 根据滚动条高度，计算从那个数据开始渲染； 滚动时需要动态计算需要填充的 padding 和数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 const listData = Array.from({ length: 3600 }, (v, i) =\u0026gt; `第 ${i + 1} 条数据`); // 假数据 const containerEle = document.querySelector(\u0026#39;.container\u0026#39;); // 滚动容器 const listEle = document.querySelector(\u0026#39;.list\u0026#39;); // 滚动列表 class VirtualScroll { /** * containerEle 滚动容器 * listEle 滚动列表 * listData 列表数据 * itemHeight 元素高度 */ constructor(containerEle, listEle, listData, itemHeight = 36) { this.containerEle = containerEle; this.listEle = listEle; this.listData = listData; this.itemHeight = itemHeight; this.viewMax = 0; // 可视元素个数 this.renderIndex = 0; // 渲染起始位置 this.renderData = []; // 渲染数据 this.init(); } // 初始化 init() { this.containerEle.scrollTop = 0; this.viewMax = Math.floor(this.containerEle.clientHeight / this.itemHeight) + 1; this.fillRenderData(); this.renderDOM(); this.modifyListElePadding(); this.containerEle.removeEventListener(\u0026#39;scroll\u0026#39;, this.handleScroll); this.containerEle.addEventListener(\u0026#39;scroll\u0026#39;, this.handleScroll); } // 填充渲染数据 fillRenderData() { // 仅需要渲染比 this.viewMax 稍多的元素即可（这里取了两倍），不然滚动起来会露馅儿 this.renderData = this.listData.slice( this.renderIndex, this.renderIndex + this.viewMax * 2 ); } // 渲染 DOM renderDOM() { const fragment = document.createDocumentFragment(); this.renderData.forEach(item =\u0026gt; { const liEle = document.createElement(\u0026#39;li\u0026#39;); liEle.textContent = item; fragment.appendChild(liEle); }); this.listEle.innerHTML = \u0026#39;\u0026#39;; // 渲染前先清空旧的 this.listEle.appendChild(fragment); } // 修改填充高度 modifyListElePadding() { // ul 里除了 li，还需要设置 padding（top/bottom）将 ul 高度撑起来，否则滚动条会露馅儿 const listElePadding = this.itemHeight * (this.listData.length - this.renderData.length); // 总 padding（top + bottom） const listElePaddingTop = this.itemHeight * this.renderIndex; const listElePaddingBottom = listElePadding - listElePaddingTop; this.listEle.style.padding = `${listElePaddingTop}px 0 ${listElePaddingBottom}px`; } // 处理滚动行为 handleScroll = e =\u0026gt; { const scrollTop = e.currentTarget.scrollTop || 0; // 获取滚动高度 this.renderIndex = Math.floor(scrollTop / this.itemHeight); // 根据滚动高度设置渲染起始位置 // 重新进行 DOM 填充即可 this.fillRenderData(); this.renderDOM(); this.modifyListElePadding(); }; } new VirtualScroll(containerEle, listEle, listData); DEMO 在 这里 。\n","date":"2021-12-02T00:00:00Z","image":"https://vikingama.github.io/img/cover/interaction.png","permalink":"https://vikingama.github.io/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8/","title":"如何实现虚拟滚动？"},{"content":"响应式原理 2.x Dep 用来存放/管理订阅者（watcher）的对象；每个 Dep 实例都存在于对象每个属性对应的 getter/setter 所在的闭包里并且都有唯一的 id。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 export default class Dep { static target; constructor() { this.id = uid++; this.subs = []; // 存放着 watchers（订阅者） } addSub(sub) { this.subs.push(sub); // 将 watcher 添加到列表（一般由 watcher 调用） } removeSub(sub) { remove(this.subs, sub); // 从列表移除 watcher } depend() { if (Dep.target) { /** * 进行依赖收集时，Dep.target 会指向待被收集的 watcher * dep.depend 调用 watcher 的 addDep 方法 * watcher.addDep 会调用 dep.addSub * 把对方“记录”下来 */ Dep.target.addDep(this); } } notify() { // 循环“订阅者列表”，触发 watcher.update，告诉它们“数据变了” const subs = this.subs.slice(); for (let i = 0, l = subs.length; i \u0026lt; l; i++) { subs[i].update(); } } } /** * 用来指向某个正在被求值/调用的 watcher/副作用函数 * 某个时间点，仅有一个 watcher 可以被求值 */ Dep.target = null; /** * 更新粒度是组件级的，每个组件的 render 相当于一个 watcher * 组件嵌套成树就映射为 render 的调用栈，保存在“栈”里 */ const targetStack = []; // 收集依赖之前调用 export function pushTarget(target: ?Watcher) { targetStack.push(target); Dep.target = target; } // 收集依赖完成调用 export function popTarget() { targetStack.pop(); // 回退到上一个 Dep.target，因为上一个 target 已经出栈了 Dep.target = targetStack[targetStack.length - 1]; } Watcher 实例被称作需要被收集起来的依赖者或者订阅者，它依赖/观察/订阅了数据变动（在依赖收集期间，或者 watcher 被调用期间，访问了数据的 getter）；数据的 getter 被触发时，watcher 会被收集起来（Dep.target 被收集起来）；数据的 setter 被调用时，dep.notify 会触发 watcher.update，即 watcher 得到了通知，需要重新执行：\n在 mountComponent 中会 new Watcher(\u0026hellip;) 作为组件的 renderWatcher；同时在组件 update 时，会调用 watcher.before 来触发 beforeUpdate 钩子； 每个 vm.$watch 或者 watchOptions 都会 new Watcher(\u0026hellip;)； 组件的 computedOptions 也会 new Watcher(\u0026hellip;)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 export default class Watcher { /** * 每个响应式数据都有自己的 Dep 实例（存在于闭包中）来管理依赖于自己的 watcher * 每当访问数据，会触发数据的 getter，将 Dep.target 添加到 dep.subs 列表 * 每当数据变化，会触发数据的 setter，遍历 dep.subs 调用 watcher.update * 每个 watcher 都维护了一份 dep 列表，通过 watch.addDep 收集的 * 当 watcher 销毁时，需要调用 dep.removeSub * 告诉 dep 数据再发生变化，别通知我了 */ constructor( vm, // 组件实例 expOrFn, // a.b.c || () =\u0026gt; a.b.c cb, // 副作用回调函数 options, // computed || deep || lazy isRenderWatcher // 是否是 renderWatcher ) { this.vm = vm; if (isRenderWatcher) { // 如果是 renderWatcher，就保存在 vm._watcher 属性上 vm._watcher = this; } // vm._watchers 是一个数组，保存着组件的 renderWatcher、computedWatchers 和 watchWatchers vm._watchers.push(this); if (options) { this.before = options.before; // watcher.run 执行之前先要执行的逻辑 this.deep = !!options.deep; // deep: true || false this.lazy = !!options.lazy; // 是否是 computedWatcher this.sync = !!options.sync; // immediate: true || false this.user = !!options.user; // 是否是 watchWatcher } else { this.deep = this.user = this.lazy = this.sync = false; } this.active = true; // watcher 是否存活，teardown 之后被置为 false this.cb = cb; // 保存回调 this.dirty = this.lazy; // computedGetter 被触发时，会判断数据『是否\u0026#34;脏\u0026#34;了』，脏了的话，就会重新求最新值 this.id = ++uid; // 唯一的标识，批处理用的 /** * 为什么会有 deps、newDeps、depIds、newDepIds？ * 假设 vm.$watch(() =\u0026gt; vm.a ? vm.b : vm.c, () =\u0026gt; {...}) * 上一次收集的依赖和这一次收集的依赖可能不一样（取决于 vm.a 的值） * 当 vm.a 为 true 时，收集的依赖为 vm.a、vm.b * 当 vm.a 为 false 时，收集的依赖为 vm.a、vm.c */ this.deps = []; this.depIds = new Set(); this.newDeps = []; this.newDepIds = new Set(); this.expression = expOrFn.toString(); // 为了方便报错提示 /** * 解析 expOrFn 为 getter，有两种形式： * 1. 属性路径：a.b.c 指向的数据会被 watcher 订阅 * 2. 函数：function () { * 函数里访问的所有数据会被 watcher 订阅 * 任何数据变化都会通知 watcher * } */ if (typeof expOrFn === \u0026#39;function\u0026#39;) { this.getter = expOrFn; } else { /** * 将点语法转换为函数调用： * a.b.c 转换为 () =\u0026gt; a.b.c */ this.getter = parsePath(expOrFn); if (!this.getter) { this.getter = noop; } } /** * 如果不是 computedWatcher，则在实例化的过程中调用 get 对 expOrFn 进行求值 * 1. 先运行一次，完成依赖收集 * 2. 作为 prevValue */ this.value = this.lazy ? undefined : this.get(); } // 求值并重新出发依赖收集 get() { /** * 将 Dep.target 设置为当前 watcher * 并将当前 watcher 推进 targetStack * 当前 watcher 被添加到对应的依赖列表 */ let value; pushTarget(this); const vm = this.vm; try { // 求值的过程中，当前 watcher 被收集起来 value = this.getter.call(vm, vm); } catch (e) { if (this.user) { // 对 watchOption 进行报错 handleError(`getter for watcher \u0026#34;${this.expression}\u0026#34;`); } else { throw e; } } finally { /** * 如果要深层监听数据变化的话 * 递归的触发每个属性的 getter */ if (this.deep) { traverse(value); } // 恢复上一个 Dep.target 的值 popTarget(); // 清理依赖 this.cleanupDeps(); } return value; } // 保存 dep 并调用 dep.addSub(watcher) addDep(dep) { const id = dep.id; if (!this.newDepIds.has(id)) { this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) { dep.addSub(this); } } } teardown() { if (this.active) { // 将自己从组件的 _watchers 里移除 if (!this.vm._isBeingDestroyed) { remove(this.vm._watchers, this); } let i = this.deps.length; while (i--) { // 告诉所有“收集了 this 作为订阅者”的 dep this.deps[i].removeSub(this); } // 完成销毁 this.active = false; } } /** * 如果副作用中出现 a ? b : c 条件访问时，能够清除上次的依赖关系 * cleanupDeps 应该在每次运行副作用之前调用 */ cleanupDeps() { let i = this.deps.length; while (i--) { const dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) { dep.removeSub(this); } } let tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0; } // 调用 watcher.addDep(dep) depend() { let i = this.deps.length; while (i--) { this.deps[i].depend(); } } // 依赖变化，会调用 update（dep.notify 调用的），执行副作用 update() { if (this.lazy) { /** * 如果是 computed，将 watcher 标记为“脏”的 * 当访问 computed 的值时，会在 computedGetter 里调用 watcher.evaluate 求值 */ this.dirty = true; } else if (this.sync) { // 立即调用 run 方法，重新求值并执行回调，一般用来在组件初始化阶段执行一次 cb this.run(); } else { // 把 watcher 加入异步队列 queueWatcher(this); } } /** * watcher 接收到通知后，如果实例没被销毁 * 重新访问 getter 获取最新值 * 如果数据和之前的不一样 * 或者数据是对象或数组 * 或者开启了深层监听 * 说明数据变化了 * 需要执行回调 */ run() { if (this.active) { const value = this.get(); // 重新求值作为最新的值，并对比前后值；数据变化才会执行 cb if (value !== this.value || isObject(value) || this.deep) { const oldValue = this.value; this.value = value; // 将新/旧值都传给回调 this.cb.call(this.vm, value, oldValue); } } } // 给 computed 惰性求值用的 evaluate() { this.value = this.get(); this.dirty = false; // 求值完了之后，会标记为『干净』 } } defineReactive 通过调用 Object.defineProperty 将 o[k（可配置属性）] 转化为 getter/setter（访问器）的形式，并在闭包内实例化了一个 Dep，用于保存收集的 watcher：\n初始化依赖注入时，会调用 defineReactive(vm, key, (resolveInject(vm.$options.inject, vm))[key])； 初始化渲染函数时，会调用 defineReactive(vm, \u0026lsquo;$attrs/$listeners\u0026rsquo;, \u0026hellip;)； 初始化 props 时，会调用 defineReactive(props, key, value)； 作为 Vue.util.defineReactive 工具函数使用； 每次调用 vm.$set 都会调用 defineReactive； new Observer() 会调用 defineReactive。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // 将 obj[key] 转换为 getter/setters 形式 export function defineReactive(obj, key, val, customSetter, shallow) { const property = Object.getOwnPropertyDescriptor(obj, key); // 属性不可配置 if (property \u0026amp;\u0026amp; property.configurable === false) { return; } /** * Vue 的响应式 + 依赖收集，会有很多闭包产生 * React 也会在内存中渲染一个完整的 WIP 树 * 不知道使用 Vue/React 开发的网站 * 内存占用情况会不会很糟糕 */ const dep = new Dep(); // 如果之前设置过 getter/setter，先将他们保存下来 const getter = property \u0026amp;\u0026amp; property.get; const setter = property \u0026amp;\u0026amp; property.set; if ((!getter || setter) \u0026amp;\u0026amp; arguments.length === 2) { val = obj[key]; } // 如果要深层转换并且 val 是复杂数据的话，递归调用 observe let childOb = !shallow \u0026amp;\u0026amp; observe(val); // val.__ob__ || undefined Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { /** * watcher 的 getter 被调用之前会执行 pushTarget * 将 Dep.target 设置为 watcher，并把自身 push 到 targetStack * 调用 dep.depend，进而调用 watcher.addDep 方法 * 最终，watcher 被收集到 dep.subs 里，dep 被 push 到 watcher.dep 里 */ const value = getter ? getter.call(obj) : val; if (Dep.target) { dep.depend(); if (childOb) { // 子项的 dep 也要收集 Dep.target childOb.dep.depend(); // 有多个依赖项目 if (Array.isArray(value)) { dependArray(value); } } } // 返回给 watcher 的返回值 return value; }, set: function reactiveSetter(newVal) { const value = getter ? getter.call(obj) : val; // 对 newVal 和 value 进行浅比较，没变化就返回 if (newVal === value || (newVal !== newVal \u0026amp;\u0026amp; value !== value)) { return; } if (customSetter) { // 自定义 setter（比如，computed 可以自定义 setter） customSetter(); } // 只读属性，直接返回 if (getter \u0026amp;\u0026amp; !setter) return; if (setter) { setter.call(obj, newVal); } else { val = newVal; } childOb = !shallow \u0026amp;\u0026amp; observe(newVal); /** * dep.notify 会循环 dep.subs，调用每个 watcher.update * watcher 接到通知，会根据“配置”执行相应动作 */ dep.notify(); } }); } // 收集数组元素上的依赖关系，因为无法对数组元素的访问做拦截 function dependArray(value) { for (let e, i = 0, l = value.length; i \u0026lt; l; i++) { e = value[i]; e \u0026amp;\u0026amp; e.__ob__ \u0026amp;\u0026amp; e.__ob__.dep.depend(); if (Array.isArray(e)) { // 递归调用 dependArray(e); } } } observe(value) 会返回一个 Observer 实例（对 value 的观察者），这个实例挂载在 value.__ob__ 上，而且是单例的；同时，观察者对象的 value 指向被观察对象，形成循环引用；observe(value) 会通过判断 value 类型，将其转化为响应式对象/数组：\n作为 Vue.observable 工具函数使用（返回的对象是响应式的，可直接用于 Vue 渲染）； 在初始化组件状态时，会调用 observe(vm.$options.data)； 需要深层响应的场景，会递归调用 observe。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 // 为“值”创建观察者实例的工厂函数 export function observe(value, asRootData) { // value 不能是 VNode，只能对对象进行 observe if (!isObject(value) || value instanceof VNode) { return; } let ob; if (hasOwn(value, \u0026#39;__ob__\u0026#39;) \u0026amp;\u0026amp; value.__ob__ instanceof Observer) { // 观察者实例保存在 __ob__ 属性上 ob = value.__ob__; } else if ( shouldObserve \u0026amp;\u0026amp; (Array.isArray(value) || isPlainObject(value)) \u0026amp;\u0026amp; Object.isExtensible(value) \u0026amp;\u0026amp; !value._isVue ) { ob = new Observer(value); } if (asRootData \u0026amp;\u0026amp; ob) { ob.vmCount++; } return ob; } /** * 对数组部分方法进行遮蔽（不涉及 Array.prototype 的修改） * 这也表明了为什么 arr[i] = j、arr.length = 0 不会触发更新 */ const arrayProto = Array.prototype; export const arrayMethods = Object.create(arrayProto); [\u0026#39;push\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;shift\u0026#39;, \u0026#39;unshift\u0026#39;, \u0026#39;splice\u0026#39;, \u0026#39;sort\u0026#39;, \u0026#39;reverse\u0026#39;].forEach( function (method) { // 将原来的方法保存在闭包里 const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) { // 缓存正常操作的结果 const result = original.apply(this, args); const ob = this.__ob__; let inserted; // 获取新插入的数据 switch (method) { case \u0026#39;push\u0026#39;: case \u0026#39;unshift\u0026#39;: inserted = args; break; case \u0026#39;splice\u0026#39;: inserted = args.slice(2); break; } // 先单独对新插入的数据进行“观察” if (inserted) ob.observeArray(inserted); // 通知“订阅者” ob.dep.notify(); return result; }); } ); // 对传入的 value 进行 defineReactive 转化 export class Observer { constructor(value) { // 保存订阅了 value 本身的 watcher this.dep = new Dep(); this.value = value; // 将此对象作为 rootData 的 Vue 实例数量 this.vmCount = 0; // 将 observer 保存到 __ob__ 属性上 def(value, \u0026#39;__ob__\u0026#39;, this); if (Array.isArray(value)) { // 对于数组，重写原型链上的数组操作方法 value.__proto__ = arrayMethods; // 并对数组的子元素依次调用 observe this.observeArray(value); } else { // 对于对象，遍历 value，将其可枚举属性转换为 getter/setter 形式 this.walk(value); } } walk(obj) { const keys = Object.keys(obj); for (let i = 0; i \u0026lt; keys.length; i++) { defineReactive(obj, keys[i]); } } observeArray(items) { for (let i = 0, l = items.length; i \u0026lt; l; i++) { observe(items[i]); } } } 在 beforeMount 和 mounted 钩子之间（mountComponent），会初始化组件 watcher（renderWatcher）；renderWatcher 保存在 vm._watcher（一个组件仅有一个 renderWatcher），同时还保存在 vm._watchers 数组里（存放着组件涉及到的所有 watcher，比如 computed、watch 等）。renderWatcher 的 getter 为 updateComponent，当调用 vm._render 时，会触发所有在渲染函数中用到的数据的 getter（会执行 updateComponent.call(vm, vm)）。函数访问到的数据的 getter 会把 renderWatcher 添加到自己的 dep.subs 列表中；当数据变化，响应式数据 setter 被触发，dep.notify 将调用 watcher.update，将执行 queueWatcher 把 watcher 添加到更新队列，更新队列会在合适的时候调用 watcher.run 触发页面更新（生成 VNode，再 patch 到 DOM，过程中会经历 diff）。\n响应式原理 3.x createReactiveObject 用来将普通对象（Object、Array、Map、Set、WeakMap、WeakSet）通过 Proxy + handlers 代理为响应式数据：\nreactive 对应的 handler：mutableHandlers, mutableCollectionHandlers； shallowReactive 对应的 handler：shallowReactiveHandlers, shallowCollectionHandlers； readonly 对应的 handler：readonlyHandlers, readonlyCollectionHandlers； shallowReadonly 对应的 handler：shallowReadonlyHandlers, readonlyCollectionHandlers。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 export const reactiveMap = new WeakMap\u0026lt;Target, any\u0026gt;(); export const readonlyMap = new WeakMap\u0026lt;Target, any\u0026gt;(); function createReactiveObject( target: Target, isReadonly: boolean, baseHandlers: ProxyHandler\u0026lt;any\u0026gt;, collectionHandlers: ProxyHandler\u0026lt;any\u0026gt; ) { // 只有 Object、Array、Map、Set、WeakMap、WeakSet 才可以转换为响应式数据 if (!isObject(target)) { return target; } // target 已经不是原始数据，直接返回 if (target.__v_raw \u0026amp;\u0026amp; !(isReadonly \u0026amp;\u0026amp; target.__v_isReactive)) { return target; } const proxyMap = isReadonly ? readonlyMap : reactiveMap; /** * 每次调用 createReactiveObject 都会创建一个新的代理对象 * 如果 target 对应的代理对象已经存在？就不需要重新创建 */ const existingProxy = proxyMap.get(target); if (existingProxy) { return existingProxy; } if (target.__v_skip || !Object.isExtensible(target)) { return target; } const toRawType = v =\u0026gt; Object.prototype.toString.call(v).slice(8, -1); if (targetTypeMap(toRawType(value)) === TargetType.INVALID) { return target; } /** * Proxy 只能拦截对象的基本（单一）操作：get、set、apply... * 而不能拦截对象的复合操作，例如：object.fn()；包含了两个操作：读取 get 和调用 apply * 任何 Proxy 可以拦截的操作，Reflect 里都能找到对应的同名函数，提供了这些操作的默认行为 */ const proxy = new Proxy( target, /** * Object、Array 使用 baseHandlers * Map、Set、WeakMap、WeakSet 使用 collectionHandlers */ targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ); // 将创建的代理对象记录下来，防止重复创建 proxyMap.set(target, proxy); return proxy; } reactive 通过调用 createReactiveObject 来创建原始对象的响应式副本，这种转换是深层的，reactive 会影响所有嵌套属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 export function reactive(target) { // readonly 数据直接返回 if (target \u0026amp;\u0026amp; target.__v_isReadonly) { return target; } // 使用 Proxy 对 target 进行处理 return createReactiveObject( target, false, /** * baseHandlers * track: get、has、ownKeys * trigger: set、deleteProperty */ { get(target, key, receiver) { if (key === \u0026#39;__v_isReactive\u0026#39;) { return true; } else if (key === \u0026#39;__v_isReadonly\u0026#39;) { return false; } else if (key === \u0026#39;__v_raw\u0026#39; \u0026amp;\u0026amp; receiver === reactiveMap.get(target)) { // 无论是 readonly 还是 reactive，访问 __v_raw 都能得到原始数据 return target; } const targetIsArray = isArray(target); // 如果 target 是数组，并且对 target 的操作 key 存在于 arrayInstrumentations 中，就劫持操作 if (targetIsArray \u0026amp;\u0026amp; hasOwn(arrayInstrumentations, key)) { /** * arrayInstrumentations 包含了对数组方法的劫持： * __proto__ * [Symbol.iterator] * concat * entries * every * ... */ return Reflect.get(arrayInstrumentations, key, receiver); } /** * 使用 Reflect 而不是使用 target[key] 是因为： * 我们只希望副作用和“代理对象”产生关联，而不是和 target（原始对象） * 这里的 receiver 指向了代理对象 proxy，指的是访问“谁”的 key（this 是“谁”） */ const res = Reflect.get(target, key, receiver); /** * 如果 key 是内建 Symbol 或者是 __proto__/__v_isRef，不需要依赖收集，直接返回 * 因为 for...of 只需要和数组 length 和 index 之间建立联系就好 * 不需要追踪 [Symbol.iterator] 的变化 */ if ( isSymbol(key) ? builtInSymbols.has(key) : key === `__proto__` || key === `__v_isRef` ) { return res; } // 追踪依赖 track(target, \u0026#39;get\u0026#39;, key); // 通过 res.__v_isRef 进行判断 if (isRef(res)) { // 如果 target 是一个数组且 key 是一个整数，就不应该把 res 自动展开 const shouldUnwrap = !(targetIsArray \u0026amp;\u0026amp; isIntegerKey(key)); // 自动展开 return shouldUnwrap ? res.value : res; } if (isObject(res)) { // 如果 res 是 Object，对 res 调用 reactive return reactive(res); } return res; }, set(target, key, value, receiver) { const oldValue = target[key]; value = toRaw(value); // 如果 target 不是数组，旧值为 ref，新值不为 ref if (!isArray(target) \u0026amp;\u0026amp; isRef(oldValue) \u0026amp;\u0026amp; !isRef(value)) { // 更新旧值的 value oldValue.value = value; return true; } const hadKey = isArray(target) \u0026amp;\u0026amp; isIntegerKey(key) ? // 通过数组下标直接更新，并且 key 是否小于数组长度 Number(key) \u0026lt; target.length : // 否则使用 hasOwnProperty 判断 hasOwn(target, key); const result = Reflect.set(target, key, value, receiver); /** * 如果 child 继承自 parent，bar 属性只存在于 parent 上 * 对 child.bar 修改，会同时影响 child 和 parent 的依赖收集 * target 是 receiver 的原始对象时，才触发副作用，排除原型链的影响 * 才能避免依赖被重复收集（parent 和 child 的 proxy 都收集同一个依赖于 child.bar 的副作用） */ if (target === toRaw(receiver)) { /** * hadKey 用来区分 set 操作是修改了已有属性还是新增了新的属性 * 因为新增属性需要触发“迭代器”的副作用执行 * 而更新属性值不需要触发“迭代器” */ if (!hadKey) { // key 不存在（Array 同理，会触发数组 length 的变化），add 行为 trigger(target, \u0026#39;add\u0026#39;, key, value); } else if (hasChanged(value, oldValue)) { // key 存在，并且值有变化，set 行为 trigger(target, \u0026#39;set\u0026#39;, key, value, oldValue); } } return result; }, // 对应 in 操作符 has(target, key) { const result = Reflect.has(target, key); if (!isSymbol(key) || !builtInSymbols.has(key)) { track(target, \u0026#39;has\u0026#39;, key); } return result; }, // 对应 delete 操作符 deleteProperty(target, key) { const hadKey = hasOwn(target, key); const oldValue = (target as any)[key]; /** * 不同于 delete 操作返回“删除 key 对应的 value” * Reflect.deleteProperty 返回一个 boolean */ const result = Reflect.deleteProperty(target, key); if (result \u0026amp;\u0026amp; hadKey) { /** * key 本就存在，且删除成功之后，才能触发 delete 副作用 * 这个操作同样会影响“迭代器” */ trigger(target, \u0026#39;delete\u0026#39;, key, undefined, oldValue); } return result; }, /** * 通过 ownKeys + ITERATE_KEY 拦截 for...in * ownKeys 是用来遍历所有 key 的 * 所以这里拿不到具体的 key * 用 ITERATE_KEY 指代 */ ownKeys(target) { /** * 对迭代访问进行依赖收集 * 如果是对数组进行遍历，需要考虑数组元素个数的变化（length 的变化） */ track(target, \u0026#39;iterate\u0026#39;, isArray(target) ? \u0026#39;length\u0026#39; : ITERATE_KEY); return Reflect.ownKeys(target); } }, // collectionHandlers for Map、Set、WeakMap、WeakSet mutableInstrumentations ); } mutableInstrumentations 用来对 Map|Set 的部分方法进行拦截。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 const mutableInstrumentations: Record\u0026lt;string, Function\u0026gt; = { get(this: MapTypes, key: unknown) { return get(this, key); }, get size() { return size(this as unknown as IterableCollections); }, add, clear, delete: deleteEntry, has, set, forEach: createForEach(false, false), keys: createIterableMethod(\u0026#39;keys\u0026#39;, false, false), values: createIterableMethod(\u0026#39;values\u0026#39;, false, false), entries: createIterableMethod(\u0026#39;entries\u0026#39;, false, false), [Symbol.iterator]: createIterableMethod(Symbol.iterator, false, false) }; function get( target: MapTypes, key: unknown, isReadonly = false, isShallow = false ) { target = (target as any)[ReactiveFlags.RAW]; const rawTarget = toRaw(target); // 获取原始对象 const rawKey = toRaw(key); // 获取原始 key if (key !== rawKey) { !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.GET, key); } !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.GET, rawKey); const { has } = getProto(rawTarget); const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive; if (has.call(rawTarget, key)) { return wrap(target.get(key)); } else if (has.call(rawTarget, rawKey)) { return wrap(target.get(rawKey)); } else if (target !== rawTarget) { target.get(key); } } function size(target: IterableCollections, isReadonly = false) { target = (target as any)[ReactiveFlags.RAW]; !isReadonly \u0026amp;\u0026amp; track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY); /** * 需要将第三个参数（this 对象）指向 target，而不是 receiver * 因为 size 是一个访问器属性，响应式对象上没有实现 [[SetData]] * 所以，需要借用原始数据的 [[SetData]] 返回 size 值 */ return Reflect.get(target, \u0026#39;size\u0026#39;, target); } function has(this: CollectionTypes, key: unknown, isReadonly = false): boolean { const target = (this as any)[ReactiveFlags.RAW]; const rawTarget = toRaw(target); const rawKey = toRaw(key); if (key !== rawKey) { !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.HAS, key); } !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.HAS, rawKey); return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey); } function add(this: SetTypes, value: unknown) { value = toRaw(value); const target = toRaw(this); const proto = getProto(target); const hadKey = proto.has.call(target, value); if (!hadKey) { // 只有在值不存在的情况下，添加 key 并触发响应 target.add(value); // 这里需要对原始对象进行操作 trigger(target, TriggerOpTypes.ADD, value, value); } return this; } function set(this: MapTypes, key: unknown, value: unknown) { /** * 不要将代理对象设置到原始对象上，所以需要拿到 value 的原始值 * 否则，会污染原始数据 */ value = toRaw(value); const target = toRaw(this); const { has, get } = getProto(target); let hadKey = has.call(target, key); if (!hadKey) { key = toRaw(key); hadKey = has.call(target, key); } const oldValue = get.call(target, key); // 获取旧值 target.set(key, value); // 设置新值 if (!hadKey) { // 触发新增 trigger(target, TriggerOpTypes.ADD, key, value); } else if (hasChanged(value, oldValue)) { // 新旧值不相等，触发 SET trigger(target, TriggerOpTypes.SET, key, value, oldValue); } return this; } function deleteEntry(this: CollectionTypes, key: unknown) { const target = toRaw(this); const { has, get } = getProto(target); let hadKey = has.call(target, key); if (!hadKey) { key = toRaw(key); // key 也可能为一个代理对象 hadKey = has.call(target, key); } const oldValue = get ? get.call(target, key) : undefined; const result = target.delete(key); // 通过原始对象 delete if (hadKey) { // 只有要删除的元素存在，才触发副作用 trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue); } return result; } function clear(this: IterableCollections) { const target = toRaw(this); const hadItems = target.size !== 0; const oldTarget = undefined; const result = target.clear(); if (hadItems) { trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget); } return result; } function createForEach(isReadonly: boolean, isShallow: boolean) { // 遍历操作只和值的数量有关 return function forEach( this: IterableCollections, callback: Function, thisArg?: unknown ) { const observed = this as any; const target = observed[ReactiveFlags.RAW]; const rawTarget = toRaw(target); // 还是在 target 上调用 forEach const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive; !isReadonly \u0026amp;\u0026amp; track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY); // 和 ITERATE_KEY 建立联系 return target.forEach((value: unknown, key: unknown) =\u0026gt; { // 需要将 value 和 key 包装为响应式数据 return callback.call(thisArg, wrap(value), wrap(key), observed); }); }; } // keys, values, entries, [Symbol.iterator] function createIterableMethod( method: string | symbol, isReadonly: boolean, isShallow: boolean ) { return function ( this: IterableCollections, ...args: unknown[] ): Iterable \u0026amp; Iterator { const target = (this as any)[ReactiveFlags.RAW]; const rawTarget = toRaw(target); // 获取原始数据 const targetIsMap = isMap(rawTarget); // 原始数据是不是 Map const isPair = method === \u0026#39;entries\u0026#39; || (method === Symbol.iterator \u0026amp;\u0026amp; targetIsMap); // [key, value] const isKeyOnly = method === \u0026#39;keys\u0026#39; \u0026amp;\u0026amp; targetIsMap; // 只对 Map 的 key 进行了遍历 const innerIterator = target[method](...args); // 获取原始迭代器 const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive; !isReadonly \u0026amp;\u0026amp; /** * 这里多出一个 MAP_KEY_ITERATE_KEY 的原因是： * 如果副作用函数中，只对 Map 遍历了 key 值，而没有 value 值 * 而外部仅修改了已存在 key 的 value 值时，副作用不应该被重新运行 */ track( rawTarget, TrackOpTypes.ITERATE, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY ); return { // 迭代器协议（一个对象实现了 next 方法） next() { const { value, done } = innerIterator.next(); // 调用原始迭代器 return done ? { value, done } : { // 将 value 转换为代理对象 value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value), done }; }, // 可迭代协议（一个对象实现了 Symbol.iterator 方法，entries 用到） [Symbol.iterator]() { return this; } }; }; } arrayInstrumentations 用来对数组的部分方法进行拦截。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 使用 Reflect.get(arrayInstrumentations, key, receiver); const arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations(); function createArrayInstrumentations() { const instrumentations: Record\u0026lt;string, Function\u0026gt; = {}; // 数组查询操作 ([\u0026#39;includes\u0026#39;, \u0026#39;indexOf\u0026#39;, \u0026#39;lastIndexOf\u0026#39;] as const).forEach(key =\u0026gt; { // 形参里的 this 只是 TS 声明函数 this 类型的一种写法 instrumentations[key] = function (this: unknown[], ...args: unknown[]) { const arr = toRaw(this) as any; // this 指代“代理对象”，arr 为“原始对象” for (let i = 0, l = this.length; i \u0026lt; l; i++) { track(arr, TrackOpTypes.GET, i + \u0026#39;\u0026#39;); } const res = arr[key](...args); // 在原始对象上调用方法 key 并获取结果 res // res 为 falsey，表示在 arr 里没有找到对应元素 if (res === -1 || res === false) { /** * 没找到，说明 args 里存在“代理对象”，就用 toRaw 将 args 里的数据转化为原始数据 * 如果不做处理，就会有以下问题： * const tempObj = {}; * const tempReactiveArr = reactive([tempObj]); * tempReactiveArr.includes(tempObj) // 不做特殊处理，就会得到 false；应该为 true 才符合预期 */ return arr[key](...args.map(toRaw)); } else { return res; } }; }); // 数组修改操作，会间接读取/修改 length，造成不必要的依赖收集 ([\u0026#39;push\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;shift\u0026#39;, \u0026#39;unshift\u0026#39;, \u0026#39;splice\u0026#39;] as const).forEach(key =\u0026gt; { instrumentations[key] = function (this: unknown[], ...args: unknown[]) { // 直接停止依赖收集 pauseTracking(); pauseScheduling(); // 调用原始对象的方法，并将 this 指向代理对象，并返回结果 const res = (toRaw(this) as any)[key].apply(this, args); resetScheduling(); resetTracking(); return res; }; }); return instrumentations; } readonly 用来创建原始对象的只读副本，这种转换同样是深层的，readonly 会影响所有嵌套属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 export function readonly(target) { return createReactiveObject( target, true, // Object、Array { get(target, key, receiver) { if (key === \u0026#39;__v_isReactive\u0026#39;) { return false; } else if (key === \u0026#39;__v_isReadonly\u0026#39;) { return true; } else if (key === \u0026#39;__v_raw\u0026#39; \u0026amp;\u0026amp; receiver === readonlyMap.get(target)) { return target; } const targetIsArray = isArray(target); const res = Reflect.get(target, key, receiver); if ( isSymbol(key) ? builtInSymbols.has(key) : key === `__proto__` || key === `__v_isRef` ) { return res; } if (isRef(res)) { // 如果 target 是一个数组且 key 是一个整数，就不应该把 res 自动展开 const shouldUnwrap = !targetIsArray || !isIntegerKey(key); return shouldUnwrap ? res.value : res; } // 递归只读 if (isObject(res)) return readonly(res); return res; }, set(target, key) { console.warn(\u0026#39;target is readonly\u0026#39;); return true; }, deleteProperty(target, key) { console.warn(\u0026#39;target is readonly\u0026#39;); return true; } }, readonlyInstrumentations ); } const readonlyInstrumentations: Record\u0026lt;string, Function\u0026gt; = { get(this: MapTypes, key: unknown) { return get(this, key, true); }, get size() { return size(this as unknown as IterableCollections, true); }, has(this: MapTypes, key: unknown) { return has.call(this, key, true); }, // 除了 delete，其他全部返回 this add: createReadonlyMethod(TriggerOpTypes.ADD), set: createReadonlyMethod(TriggerOpTypes.SET), delete: createReadonlyMethod(TriggerOpTypes.DELETE), clear: createReadonlyMethod(TriggerOpTypes.CLEAR), forEach: createForEach(true, false) }; function createReadonlyMethod(type: TriggerOpTypes): Function { return function (this: CollectionTypes, ...args: unknown[]) { return type === TriggerOpTypes.DELETE ? false : this; }; } createRef 用来将基本类型的值（原始值）转换为包装类型；ref、shallowRef 都会通过它来转换数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function createRef(rawValue, shallow = false) { if (rawValue \u0026amp;\u0026amp; rawValue.__v_isRef === true) { return rawValue; // 已经是包装类型，就别来凑热闹了 } // ref 就是简单的对 value 的 getter/setter return new RefImpl(rawValue, shallow); } class RefImpl\u0026lt;T\u0026gt; { private _value: T; // 可以用来区分 ref(1) 与 reactive({value: 1})，也是自动解构 .value 的依据 public readonly __v_isRef = true; constructor(private _rawValue: T, public readonly _shallow = false) { this._value = _shallow ? _rawValue : isObject(_rawValue) ? // 如果 _rawValue 是对象，调用 reactive 深度转换 reactive(_rawValue) : _rawValue; } get value() { track(toRaw(this), \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;); return this._value; } set value(newVal) { if (hasChanged(toRaw(newVal), this._rawValue)) { this._rawValue = newVal; this._value = this._shallow ? newVal : convert(newVal); trigger(toRaw(this), \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;, newVal); } } } ref 接受一个内部值并返回一个响应式且可变的 ref 对象；ref 对象具有指向内部值的单个属性 .value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 export function ref(value) { return createRef(value); } // 循环调用 toRef，可以在解构的同时，保持响应性，解决响应性丢失的问题 export function toRefs\u0026lt;T extends object\u0026gt;(object: T): ToRefs\u0026lt;T\u0026gt; { const ret: any = isArray(object) ? new Array(object.length) : {}; for (const key in object) { ret[key] = toRef(object, key); } return ret; } export function toRef\u0026lt;T extends object, K extends keyof T\u0026gt;( object: T, key: K ): ToRef\u0026lt;T[K]\u0026gt; { return isRef(object[key]) ? object[key] : (new ObjectRefImpl(object, key) as any); } class ObjectRefImpl\u0026lt;T extends object, K extends keyof T\u0026gt; { public readonly __v_isRef = true; constructor(private readonly _object: T, private readonly _key: K) {} get value() { return this._object[this._key]; } set value(newVal) { this._object[this._key] = newVal; } } export function proxyRefs\u0026lt;T extends object\u0026gt;( objectWithRefs: T ): ShallowUnwrapRef\u0026lt;T\u0026gt; { return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, { get: (target, key, receiver) =\u0026gt; unref(Reflect.get(target, key, receiver)), set: (target, key, value, receiver) =\u0026gt; { const oldValue = target[key]; if (isRef(oldValue) \u0026amp;\u0026amp; !isRef(value)) { oldValue.value = value; return true; } else { return Reflect.set(target, key, value, receiver); } } }); } export function unref\u0026lt;T\u0026gt;(ref: T | Ref\u0026lt;T\u0026gt;): T { return isRef(ref) ? (ref.value as any) : ref; } track 和 trigger 用于依赖收集和在依赖变动时触发的副作用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 // 追踪类型 export const enum TrackOpTypes { GET = \u0026#39;get\u0026#39;, // 属性读取 HAS = \u0026#39;has\u0026#39;, // in 操作符（不包括 for...in） ITERATE = \u0026#39;iterate\u0026#39; // 迭代器 } // 触发类型 export const enum TriggerOpTypes { ADD = \u0026#39;add\u0026#39;, // 属性添加 CLEAR = \u0026#39;clear\u0026#39; // 清空属性 DELETE = \u0026#39;delete\u0026#39;, // 属性删除 SET = \u0026#39;set\u0026#39;, // 属性设置 } // 依赖列表（2.x Array =\u0026gt; 3.x Set） type Dep = Set\u0026lt;ReactiveEffect\u0026gt;; // key 对应的依赖列表 [[[key, dep]],...] type KeyToDepMap = Map\u0026lt;any, Dep\u0026gt;; let shouldTrack = true; // 指向被收集的副作用函数，同 2.x 中的 Dep.target let activeEffect: ReactiveEffect | undefined; const trackStack: boolean[] = []; /** * target 的 key 对应的依赖列表，储存着 target -\u0026gt; key -\u0026gt; dep 的联系 * 为什么不用 Map 而用 WeakMap？ * 1. Map（WeakMap）内部有两个数组，分别存 key 和 value；所以在 Map（WeakMap）内部，key 和 value 并没有真正建立联系； * 2. Map 的 key 和内存地址绑定，外部引用的消失不会影响绑定关系；WeakMap 内部对 key 的引用都是弱引用，不会阻止垃圾回收； * 3. Map 的 key 可以为任意类型，WeakMap 的 key 只能为对象； * 4. Map 可以被遍历，WeakMap 不能被遍历。 * 这里使用 WeakMap 可以使内存及时被释放 * 同理 Set 和 WeakSet 的区别如下： * 1. WeakSet 的成员都是弱引用； * 2. WeakSet 的成员都是对象； * 3. WeakSet 不能遍历。 * 只要外部引用消失，立即清除就会帮我们自动回收 */ const targetMap = new WeakMap\u0026lt;any, KeyToDepMap\u0026gt;(); export const ITERATE_KEY = Symbol(\u0026#39;\u0026#39;); export const MAP_KEY_ITERATE_KEY = Symbol(\u0026#39;\u0026#39;); /** * 暂停追踪，使用场景： * 1. 在对数组执行一些可能间接改变 length 属性的操作（push、pop、shift、unshift、splice）； * 2. 在生命周期函数里暂停追踪，因为可能会触发潜在的 effect； * 3. 调用 applyOptions 之前（兼容 2.x 语法）； * 4. 调用内置的 warn 时； * 5. 调用 setup 之前。 */ export function pauseTracking() { trackStack.push(shouldTrack); shouldTrack = false; } // 开始追踪 export function enableTracking() { trackStack.push(shouldTrack); shouldTrack = true; } // 重置到上一步 export function resetTracking() { const last = trackStack.pop(); shouldTrack = last === undefined ? true : last; } /** * 收集 activeEffect（在对数据进行 get、has、iterate 操作时）： * 每次 track，就是把当前 activeEffect 作为对 target[key] 的依赖； * 然后收集到 target 相关的 depsMap 对应 key 下的依赖集合 dep 中。 */ export function track(target: object, type: TrackOpTypes, key: unknown) { if (!shouldTrack || activeEffect === undefined) { return; } /** * targetMap 是一个 WeakMap； * targetMap.get(target) 是一个 Map（被称为 depsMap） * 保存着 target 的每个 key 对应的 effects（2.x 里的 watcher），保存在 Set 里 * targetMap = { // WeakMap(targetMap) * [target]: { // Map(depsMap) * [key]: new Set([effect1, effect2, effect3,...]), // Set(dep) * ... * }, * ... * } */ let depsMap = targetMap.get(target); // target 对应的 depsMap 不存在，就新建一个 if (!depsMap) { targetMap.set(target, (depsMap = new Map())); } // 副作用应该只与对应的 key 建立联系，而不是和所有 key let dep = depsMap.get(key); if (!dep) { depsMap.set(key, (dep = new Set())); } if (!dep.has(activeEffect)) { // 和 2.x 一样，dep 和 activeEffect 都保存着彼此 dep.add(activeEffect); // 没有就添加 activeEffect activeEffect.deps.push(dep); // activeEffect 在自己 deps 里也保存一份（方便依赖清除） } } // 触发收集到的 effects（在对数据进行 set、add、delete、clear 操作时） export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map\u0026lt;unknown, unknown\u0026gt; | Set\u0026lt;unknown\u0026gt; ) { // 获取 depsMap 并将 activeEffect 收集到 effects 里 const depsMap = targetMap.get(target); // target 没有被 track 过 if (!depsMap) return; /** * 执行 effect 之前，需要重新构建一个 Set 来替代 depsMap.get(key) * 因为 effect 调用的过程中，存在 cleanup 并 reTrack 的逻辑 * 在这个过程中，会对 depsMap.get(key) 对应的 set 进行“操作” * 如果直接循环“原来的 set”，会导致无限循环调用 * 究其原因，在 Set.prototype.forEach 中 * 对 Set 本身进行“操作”，会陷入死循环 * const set = new Set([1]); * set.forEach(item =\u0026gt; { * // 这会死循环 * set.delete(1); * set.add(1); * }); */ const effects = new Set\u0026lt;ReactiveEffect\u0026gt;(); // 将 effectsToAdd 按条件添加到 effects 里 const add = (effectsToAdd: Set\u0026lt;ReactiveEffect\u0026gt; | undefined) =\u0026gt; { if (effectsToAdd) { // effectsToAdd 中保存着 activeEffect effectsToAdd.forEach(effect =\u0026gt; { /** * 如果 effect 和当前正在执行的 activeEffect 相同，就不放到 effects 里 * 因为这种情况，一般是因为 activeEffect 内部逻辑对 target[key] 进行了操作 * 导致又触发了 track/trigger，为了避免无限递归导致的栈溢出，需要做一下判断 */ if (effect !== activeEffect || effect.allowRecurse) { effects.add(effect); } }); } }; if (type === \u0026#39;clear\u0026#39;) { // Map/Set 要被清空，触发 target 下的所有 effects depsMap.forEach(add); } else if (key === \u0026#39;length\u0026#39; \u0026amp;\u0026amp; isArray(target)) { // 触发数组“长度变化”对应的 effect，一般是由于 key \u0026gt;= Array.length depsMap.forEach((dep, k) =\u0026gt; { // k 为 0、1、2、3、...、length if (k === \u0026#39;length\u0026#39; || k \u0026gt;= newValue) { // target[\u0026#39;length\u0026#39;] 和 target[newValue～k] 对应的 effects 都要加去 add(dep); } }); } else { // 处理 SET | ADD | DELETE if (key !== void 0) { // Set(dep) 都添加进去 add(depsMap.get(key)); } // 处理 ADD | DELETE | SET 的 ITERATE_KEY switch (type) { /** * 需要将 ITERATE_KEY 对应的副作用也取出来 * 因为，target 属性的增删，可能会影响到对 target 属性的遍历 */ case \u0026#39;add\u0026#39;: if (!isArray(target)) { add(depsMap.get(ITERATE_KEY)); if (isMap(target)) { // Map 的 key 值变多了，要触发副作用 add(depsMap.get(MAP_KEY_ITERATE_KEY)); } } else if (isIntegerKey(key)) { // 数组 length 改变 add(depsMap.get(\u0026#39;length\u0026#39;)); } break; case \u0026#39;delete\u0026#39;: if (!isArray(target)) { add(depsMap.get(ITERATE_KEY)); if (isMap(target)) { // Map 的 key 值变少了，要触发副作用 add(depsMap.get(MAP_KEY_ITERATE_KEY)); } } break; case \u0026#39;set\u0026#39;: // 如果操作类型是 SET 并且 target 是 Map 类型，需要触发 ITERATE_KEY 关联的副作用 if (isMap(target)) { add(depsMap.get(ITERATE_KEY)); } break; } } // 循环 effects，调用被收集的 effect effects.forEach((effect: ReactiveEffect) =\u0026gt; { if (effect.options.scheduler) { // 使用调度器调用 effect effect.options.scheduler(effect); } else { effect(); // 直接执行 effect } }); } effect 很像之前的 watcher；每次调用 effect（如果不 lazy 的话），会调用 createReactiveEffect 创建 reactiveEffect 并设置为 activeEffect（就像 2.x 的 watcher 在被收集之前，会将自己赋值给 Dep.target 一样）；之后会调用传入的 fn（componentEffect 内部的 renderComponentRoot 方法会执行组件的 render 方法、computedGetter、\u0026hellip;），如果在 fn 调用的过程中，访问到了『响应式』数据；Proxy 会通过 track 将 activeEffect 收集起来（响应式数据与 effect 建立联系），放到 Set(dep) 里（dep.add(activeEffect)）；同时，activeEffect 也会保存一份 dep（activeEffect.deps.push(dep)）。\ncleanup 流程就是通知 effect.deps 里保存的 dep，调用 dep.delete 方法。\nstop 流程就是在 cleanup 的基础上，调用传入的 onStop 钩子。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 let uid = 0; const effectStack: ReactiveEffect[] = []; export interface ReactiveEffect\u0026lt;T = any\u0026gt; { (): T; // ReactiveEffect 可调用 _isEffect: true; // ReactiveEffect._isEffect = true active: boolean; // ReactiveEffect.active = false allowRecurse: boolean; // ReactiveEffect.allowRecurse = true deps: Array\u0026lt;Dep\u0026gt;; // ReactiveEffect.deps = [] id: number; // ReactiveEffect.id = 123 options: ReactiveEffectOptions; // ReactiveEffect.options = {} raw: () =\u0026gt; T; // ReactiveEffect.raw = ReactiveEffect } export interface ReactiveEffectOptions { allowRecurse?: boolean; lazy?: boolean; onStop?: () =\u0026gt; void; scheduler?: (job: ReactiveEffect) =\u0026gt; void; // 调度器 } /** * 将 fn（普通副作用）转换为 ReactiveEffect（自动副作用），场景如下： * 1. setupRenderEffect 中，instance.update = effect(function componentEffect() {...}) * 2. computed 中，this._value = (effect(getter, {}))() * 3. watch 中，newValue = (effect(getter, {}))() */ export function effect(fn, options = {}) { if (fn \u0026amp;\u0026amp; fn._isEffect === true) { fn = fn.raw; } const effect = createReactiveEffect(fn, options); /** * 运行 effect，触发 fn 里对使用到的数据的操作 * 如果是 lazy，惰性运行 effect（不立即执行） */ if (!options.lazy) { effect(); } return effect; } function createReactiveEffect\u0026lt;T = any\u0026gt;( fn: () =\u0026gt; T, options: ReactiveEffectOptions ): ReactiveEffect\u0026lt;T\u0026gt; { // 被收集的 effect 的每次调用：cleanup -\u0026gt; enableTracking -\u0026gt; fn -\u0026gt; resetTracking const effect = function reactiveEffect(): unknown { if (!effect.active) { return options.scheduler ? undefined : fn(); } if (!effectStack.includes(effect)) { /** * 每次运行 fn 之前，先清除上一次被收集的结果 * 确保收集的依赖总是最新的 */ cleanup(effect); try { enableTracking(); /** * effect 会发生嵌套，就像组件一层一层嵌套那样 * 如果内层 effect 调用完，不及时释放 activeEffect 的话 * 外层 effect 在进行剩下的逻辑处理的过程中，如果触发依赖收集，被收集的还会是内层的 effect * effectStack 的存在，保证了 activeEffect 永远指向 effectStack 的栈顶 * 酱紫保证了，依赖收集机制只会收集对当前数据进行直接访问的 effect */ effectStack.push(effect); // 将自身设置为 activeEffect，方便 track 对自己进行追踪，从而进行依赖收集 activeEffect = effect; /** * 每次调用 effect，都会执行 fn，将 fn 的返回值返回 * computed/watch/render 需要用到返回值 */ return fn(); } finally { /** * （fn/组件的渲染工作）是递归的 * 渲染完成之后，需要及时将渲染流程交还给父级组件 * 此时，虽然子级已完成渲染（子级依赖收集完成） * 但父级的渲染还没完成，需要交还给父级继续完成父级的依赖收集 */ effectStack.pop(); resetTracking(); // activeEffect 永远指向 effectStack 的栈顶 activeEffect = effectStack[effectStack.length - 1]; } } } as ReactiveEffect; effect._isEffect = true; effect.active = true; effect.allowRecurse = !!options.allowRecurse; effect.deps = []; effect.id = uid++; effect.options = options; effect.raw = fn; return effect; } // 清除 effect function cleanup(effect: ReactiveEffect) { // 每个 effect 都保存了“自己被哪个 dep 收集了” const { deps } = effect; if (deps.length) { for (let i = 0; i \u0026lt; deps.length; i++) { // 通知他们，把自己删掉；如果再更新的话，不要通知我 deps[i].delete(effect); } // 清空 effect.deps deps.length = 0; } } /** * 终止 effect，使用场景如下： * 1. watcher 返回的函数中，用于取消 watcher 的 effect * 2. unmountComponent 时，用于清除组件的 effect */ export function stop(effect: ReactiveEffect) { if (effect.active) { cleanup(effect); if (effect.options.onStop) { effect.options.onStop(); } effect.active = false; } } 异步队列 2.x queueWatcher 在 watcher.update 方法内调用，用来将 watcher 推入队列（缓冲在一个事件循环内的所有数据变化）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 export function queueWatcher(watcher: Watcher) { // 获取 watcher 的唯一的 id const id = watcher.id; if (has[id] == null) { // 同一个 watcher 被多次 update，也只进入队列一次 has[id] = true; if (!flushing) { // 队列暂时没有被清空，直接入队 queue.push(watcher); } else { // 如果正在清空队列，将新来的 watcher 添加到合适的位置 let i = queue.length - 1; while (i \u0026gt; index \u0026amp;\u0026amp; queue[i].id \u0026gt; watcher.id) { i--; } queue.splice(i + 1, 0, watcher); } if (!waiting) { waiting = true; // 在下个事件循环就清空队列并执行所有 watcher 回调 nextTick(flushSchedulerQueue); } } } flushSchedulerQueue 刷新/清空队列，调用 watcher.run 执行副作用；完成 watcher 调用之后，调用组件 activated/updated 钩子函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function flushSchedulerQueue() { currentFlushTimestamp = Date.now(); flushing = true; let watcher, id; /** * 在清空之前，先按照 id 进行排序： * 1. 组件更新/渲染总是先父后子（父组件先创建） * 2. vm.$watch 比 renderWatch 先运行（因为 vm.$watch 先创建） * 3. 在父组件 watcher 运行期间，如果子组件被销毁，他的 watcher 会被跳过（watcher.active = false） */ queue.sort((a, b) =\u0026gt; a.id - b.id); // 不要缓存队列长度，因为随时可能会变 for (index = 0; index \u0026lt; queue.length; index++) { watcher = queue[index]; if (watcher.before) { // 2.x 里唯一用到的地方是 callHook(vm, \u0026#39;beforeUpdate\u0026#39;) watcher.before(); } id = watcher.id; has[id] = null; watcher.run(); if (has[id] != null) { circular[id] = (circular[id] || 0) + 1; // 同一个 watch 不能运行多次 if (circular[id] \u0026gt; 100) { // 判断是否是死循环 break; } } } // 在重置状态之前保留队列的副本 const activatedQueue = activatedChildren.slice(); const updatedQueue = queue.slice(); resetSchedulerState(); // 重置队列状态 callActivatedHooks(activatedQueue); // callHook(vm, \u0026#39;activated\u0026#39;) callUpdatedHooks(updatedQueue); // callHook(vm, \u0026#39;updated\u0026#39;) } 异步队列 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 /** * 一共有三种队列：preFlushCbs、queue、postFlushCbs * watchEffect(() =\u0026gt; {}, { * flush: \u0026#39;pre\u0026#39;, // 默认，在组件渲染之前执行 * flush: \u0026#39;sync\u0026#39; // 在响应式依赖发生改变时立即触发侦听器 * flush: \u0026#39;post\u0026#39;, // 延迟到组件渲染之后再执行 * }); * 1. preFlushCbs，清空 queue 之前执行的回调队列（渲染之前需要的任务） * 2. queue，“组件渲染/同步”任务队列 * 3. postFlushCbs，清空 queue 之后执行的回调队列（渲染之后需要的任务） * 每次刷新（flush）的过程：清空 preFlushCbs -\u0026gt; 清空 queue -\u0026gt; 清空 postFlushCbs */ export interface SchedulerJob { (): void; id?: number; // 唯一的 jobID，仅在 RAWEffect（例如，组件渲染）上出现 /** * 是否允许 job 递归触发自身 * 默认情况下，一个 job 不能触发自身 * 因为一些内建方法的调用（例如，Array.prototype.push）会导致无限循环 * 只有在“组件更新函数”和“watch 回调”的情况下，这个选项才可以为 true * 组件更新可能会导致子组件的 props 更新，进而触发子组件的“flush: pre”的 watch 回调 */ allowRecurse?: boolean; } export type SchedulerCb = Function \u0026amp; { id?: number }; export type SchedulerCbs = SchedulerCb | SchedulerCb[]; type CountMap = Map\u0026lt;SchedulerJob | SchedulerCb, number\u0026gt;; let isFlushing = false; // 是否正在刷新 let isFlushPending = false; // 是否正在等待刷新 // 还未被执行的 pre/post 任务，如果当前 tick 正在 flushPreCbs/flushPostCbs 的时候，有新的任务进来，会被添加到这个数组中 const pendingPreFlushCbs: SchedulerCb[] = []; const pendingPostFlushCbs: SchedulerCb[] = []; // 正在被执行的任务，此时如果 pendingPreFlushCbs/pendingPostFlushCbs 中有新的任务进来的时候，会被合并到这个队列中被继续执行 let activePreFlushCbs: SchedulerCb[] | null = null; let activePostFlushCbs: SchedulerCb[] | null = null; let preFlushIndex = 0; let postFlushIndex = 0; let currentFlushPromise: Promise\u0026lt;void\u0026gt; | null = null; let currentPreFlushParentJob: SchedulerJob | null = null; const resolvedPromise: Promise\u0026lt;any\u0026gt; = Promise.resolve(); // 在下个事件循环刷新 job 队列 function queueFlush() { // 在没有刷新队列和没有等待刷新队列的情况下，进入「刷新 job 队列」任务 if (!isFlushing \u0026amp;\u0026amp; !isFlushPending) { isFlushPending = true; // 正在等待刷新 currentFlushPromise = resolvedPromise.then(flushJobs); // 使用微任务 } } let flushIndex = 0; // 异步渲染任务队列 const queue: SchedulerJob[] = []; /** * 渲染任务入列（renderEffect 的调度器）： * 1. 强制组件重新渲染：vm.$forceUpdate: i =\u0026gt; () =\u0026gt; queueJob(i.update) * 2. 强制父组件重新渲染：queueJob(instance.parent.update) */ export function queueJob(job: SchedulerJob) { /** * 重复数据消除搜索使用 Array.prototype.include 的 startIndex 参数 * 判断队列中是否已有该 job，没有才会添加到任务队列中，防止任务重新执行 * 默认情况下，搜索索引包含正在运行的当前 job，因此它无法再次递归触发自身 */ if ( (!queue.length || !queue.includes( job, isFlushing \u0026amp;\u0026amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) \u0026amp;\u0026amp; job !== currentPreFlushParentJob ) { // 就把 job 加入队列 queue.push(job); /** * 在下个事件循环调用 flushJobs“刷新 job 队列” * 内部会调用 Promise.then(flushJobs) */ queueFlush(); } } // 将失效的 job 从队列中剔除（主要用来避免子组件重新渲染） export function invalidateJob(job: SchedulerJob) { const i = queue.indexOf(job); if (i \u0026gt; -1) { queue.splice(i, 1); } } // 刷新 job 队列（flushPreFlushCbs -\u0026gt; queue -\u0026gt; flushPostFlushCbs） function flushJobs(seen?: CountMap) { isFlushPending = false; isFlushing = true; // 队列正在刷新，isFlushing 确保了每个事件循环内，只会调用一次 flushJobs flushPreFlushCbs(seen); // 刷新前置回调队列 /** * 刷新队列前，先排序；确保： * 1. 组件的更新顺序是由父到子（父比子先创建，renderEffect 的优先级也应该如此） * 2. 如果组件在父级更新之后被卸载了，他就可以跳过更新 */ queue.sort((a, b) =\u0026gt; getId(a) - getId(b)); try { // 循环 job 队列，执行 effect for (flushIndex = 0; flushIndex \u0026lt; queue.length; flushIndex++) { const job = queue[flushIndex]; if (job) { // 将 job 放到 try...catch 里执行 callWithErrorHandling(job, null, ErrorCodes.SCHEDULER); } } } finally { flushIndex = 0; queue.length = 0; flushPostFlushCbs(seen); // 刷新后置回调队列 isFlushing = false; currentFlushPromise = null; // 重置 Promise // 回调可能将新的 job 添加到了 job 队列，那就再次刷新 job 队列 if (queue.length || pendingPostFlushCbs.length) { flushJobs(seen); } } } // 将回调函数加入队列 function queueCb( cb: SchedulerCbs, activeQueue: SchedulerCb[] | null, // 激活的队列？ pendingQueue: SchedulerCb[], // 等待的队列？ index: number ) { // 向 pendingQueue 添加回调 if (!isArray(cb)) { if ( !activeQueue || !activeQueue.includes( cb, (cb as SchedulerJob).allowRecurse ? index + 1 : index ) ) { pendingQueue.push(cb); } } else { pendingQueue.push(...cb); } queueFlush(); } // 将「渲染之“前”要执行的回调」入列（flush: pre） export function queuePreFlushCb(cb: SchedulerCb) { queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex); } // 将「渲染之“后”要执行的回调」入列 export function queuePostFlushCb(cb: SchedulerCbs) { queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex); } /** * 刷新「渲染之“前”要执行的回调」 * 渲染更新之前，触发因为 props 更新而运行的 watcher（flush: pre） */ export function flushPreFlushCbs( seen?: CountMap, parentJob: SchedulerJob | null = null ) { if (pendingPreFlushCbs.length) { currentPreFlushParentJob = parentJob; activePreFlushCbs = [...new Set(pendingPreFlushCbs)]; pendingPreFlushCbs.length = 0; for ( preFlushIndex = 0; preFlushIndex \u0026lt; activePreFlushCbs.length; preFlushIndex++ ) { activePreFlushCbs[preFlushIndex](); } activePreFlushCbs = null; preFlushIndex = 0; currentPreFlushParentJob = null; // 递归刷新，直到耗尽为止 flushPreFlushCbs(seen, parentJob); } } // 刷新「渲染之“后”要执行的回调」 export function flushPostFlushCbs(seen?: CountMap) { if (pendingPostFlushCbs.length) { const deduped = [...new Set(pendingPostFlushCbs)]; pendingPostFlushCbs.length = 0; if (activePostFlushCbs) { activePostFlushCbs.push(...deduped); return; } activePostFlushCbs = deduped; activePostFlushCbs.sort((a, b) =\u0026gt; getId(a) - getId(b)); for ( postFlushIndex = 0; postFlushIndex \u0026lt; activePostFlushCbs.length; postFlushIndex++ ) { activePostFlushCbs[postFlushIndex](); } activePostFlushCbs = null; postFlushIndex = 0; } } 依赖注入 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 /** * 在 Vue 初始化的过程中（Vue.prototype._init） * 先会调用 initInjections(vm) 再调用 initProvide(vm) * 1. Reflect.ownKeys/Object.keys 获取 inject 配置的 keys * 2. inject[keys[i]].from 获取对应的 provideKey * 3. 通过 vm.$parent 向上查找组件 * 4. 直到 vm._provided \u0026amp;\u0026amp; hasOwn(vm._provided, provideKey) * 5. 取出 vm._provided[provideKey] 的值或者 inject[key].default 的值 * 6. 得到所有 inject 对应的值之后，调用 defineReactive 将其变为响应式 */ export function initProvide(vm: Component) { // 获取 provide 配置 const provide = vm.$options.provide; if (provide) { // 兼容 provide 的两种写法 vm._provided = typeof provide === \u0026#39;function\u0026#39; ? provide.call(vm) : provide; } } export function initInjections(vm: Component) { // 解析 inject 获取结果 const result = resolveInject(vm.$options.inject, vm); if (result) { toggleObserving(false); Object.keys(result).forEach(key =\u0026gt; { defineReactive(vm, key, result[key]); }); toggleObserving(true); } } export function resolveInject(inject: any, vm: Component): ?Object { if (inject) { const result = Object.create(null); /** * Reflect.ownKeys 自身可枚举属性 + 自身不可枚举属性 + Symbol 属性 + length * for...in... 自身可枚举属性 + 原型链 * Object.keys 自身可枚举属性 */ const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject); for (let i = 0; i \u0026lt; keys.length; i++) { const key = keys[i]; // 获取注入的 key if (key === \u0026#39;__ob__\u0026#39;) continue; // 跳过 __ob__ const provideKey = inject[key].from; // 对应 provider 的 key let source = vm; while (source) { // 通过 $parent 向上查找 if (source._provided \u0026amp;\u0026amp; hasOwn(source._provided, provideKey)) { result[key] = source._provided[provideKey]; break; } source = source.$parent; } // 没有找到？ if (!source) { // 如果有默认值，使用默认值 if (\u0026#39;default\u0026#39; in inject[key]) { const provideDefault = inject[key].default; result[key] = typeof provideDefault === \u0026#39;function\u0026#39; ? provideDefault.call(vm) : provideDefault; } else { // 否则报错 warn(`Injection \u0026#34;${key}\u0026#34; not found`, vm); } } } return result; } } 依赖注入 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 export function provide(key, value) { if (!currentInstance) { warn(`provide() 只能在用在 setup() 里`); } else { let provides = currentInstance.provides; /** * 默认，实例会继承父级的 provides 对象 * 组件会基于父级的 provides（作为原型）创建自己的 provides * 这样，在“Inject”的时候，我们可以简单地查找来自“直接父级”的注入，并让原型链来完成这项工作 */ const parentProvides = currentInstance.parent \u0026amp;\u0026amp; currentInstance.parent.provides; // 找到父级的 provides if (parentProvides === provides) { // 基于父级的 provides 创建自己的 provides provides = currentInstance.provides = Object.create(parentProvides); } // 保存 value provides[key] = value; } } export function inject( key: InjectionKey\u0026lt;any\u0026gt; | string, defaultValue?: unknown, treatDefaultAsFactory = false ) { // 找到离自己最近的父组件的 provides 或着 vnode 的上下文 const instance = currentInstance || currentRenderingInstance; if (instance) { // 从父级组件查找 provide const provides = instance.parent == null ? instance.vnode.appContext \u0026amp;\u0026amp; instance.vnode.appContext.provides : instance.parent.provides; // 在 provies 里找到 inject 对应的 key 的值，返回即可 if (provides \u0026amp;\u0026amp; (key as string | symbol) in provides) { return provides[key as string]; } else if (arguments.length \u0026gt; 1) { // 找不到的情况下，使用默认值 return treatDefaultAsFactory \u0026amp;\u0026amp; isFunction(defaultValue) ? defaultValue() : defaultValue; } else { warn(`找不到`); } } else { warn(`inject() 只能在用在 setup() 里`); } } 生命周期 2.x 所有生命周期，都是通过 callHook 调用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 export function callHook(vm: Component, hook: string) { pushTarget(); const handlers = vm.$options[hook]; // 找到钩子函数 const info = `${hook} hook`; if (handlers) { // 如果是 mixin/extend，handlers 有可能是数组 for (let i = 0, j = handlers.length; i \u0026lt; j; i++) { invokeWithErrorHandling(handlers[i], vm, null, vm, info); } } if (vm._hasHookEvent) { /** * 如果有 vm.$on(\u0026#39;hook:xxx\u0026#39;, () =\u0026gt; {}) * vm._hasHookEvent 会被置为 true * 需要用 $emit 调用 */ vm.$emit(\u0026#39;hook:\u0026#39; + hook); } popTarget(); } Vue 是一个构造函数，在被 new 之前，需要经过初始化和混入操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 function Vue(options) { if (!(this instanceof Vue)) { warn(\u0026#39;Vue 只能被 new 操作符调用\u0026#39;); } this._init(options); } // Vue.prototype._init = ... initMixin(Vue); /** * Vue.prototype.$data = ... * Vue.prototype.$props = ... * Vue.prototype.$set = ... * Vue.prototype.$delete = ... * Vue.prototype.$watch = ... */ stateMixin(Vue); /** * Vue.prototype.$on = ... * Vue.prototype.$once = ... * Vue.prototype.$off = ... * Vue.prototype.$emit = ... */ eventsMixin(Vue); /** * Vue.prototype._update = ... * Vue.prototype.$forceUpdate = ... * Vue.prototype.$destroy = ... */ lifecycleMixin(Vue); /** * Vue.prototype.$nextTick = ... * Vue.prototype._render = ... * */ renderMixin(Vue); export function initMixin(Vue: Class\u0026lt;Component\u0026gt;) { Vue.prototype._init = function (options?: Object) { const vm: Component = this; let startTag, endTag; vm._isVue = true; // 不要 observe 我 vm._uid = uid++; // 每个实例唯一的 // 合并 options if (options \u0026amp;\u0026amp; options._isComponent) { initInternalComponent(vm, options); } else { vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || {}, vm ); } vm._renderProxy = vm; vm._self = vm; // 我自己就是我自己 initLifecycle(vm); // 初始化属性，定位非抽象父级 initEvents(vm); // 更新父级给自己绑定的事件 initRender(vm); // 处理插槽的渲染上下文 callHook(vm, \u0026#39;beforeCreate\u0026#39;); initInjections(vm); // 在解析 data/props 之前先解析 injections initState(vm); // 按顺序初始化 props、methods、data、computed、watch initProvide(vm); // 在解析 data/props 之后先解析 provide callHook(vm, \u0026#39;created\u0026#39;); if (vm.$options.el) { vm.$mount(vm.$options.el); // 挂载，调用 mountComponent } }; } created 钩子调用之后，会判断 vm.$options.el 是否存在，接着会调用 mountComponent。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean ): Component { el = el \u0026amp;\u0026amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating); }; export function mountComponent( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el; if (!vm.$options.render) { vm.$options.render = createEmptyVNode; } callHook(vm, \u0026#39;beforeMount\u0026#39;); // 找到挂载点，render 准备好渲染的内容之后，调用“beforeMount” let updateComponent = () =\u0026gt; { vm._update(vm._render(), hydrating); }; // renderWatcher 被 render 用到的变量的 getter 收集 new Watcher( vm, updateComponent, noop, { before() { /** * 在 watcher.before 之前执行 * 如果组件已经挂载，则执行‘beforeUpdate’ */ if (vm._isMounted \u0026amp;\u0026amp; !vm._isDestroyed) { callHook(vm, \u0026#39;beforeUpdate\u0026#39;); } } }, true /* isRenderWatcher */ ); // renderWatcher 初始化完成之后，调用“mounted” if (vm.$vnode == null) { vm._isMounted = true; callHook(vm, \u0026#39;mounted\u0026#39;); } return vm; } updated 钩子会在前边总结的“异步队列”里调用；下面来看 destroy。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Vue.prototype.$destroy = function () { const vm: Component = this; if (vm._isBeingDestroyed) { // 如果组件正在销毁，别往下走了 return; } // 进入销毁流程 callHook(vm, \u0026#39;beforeDestroy\u0026#39;); vm._isBeingDestroyed = true; const parent = vm.$parent; if (parent \u0026amp;\u0026amp; !parent._isBeingDestroyed \u0026amp;\u0026amp; !vm.$options.abstract) { // 如果父级没有销毁，将自己从父级的子组件中删除 remove(parent.$children, vm); } // 销毁 renderWatcher if (vm._watcher) { vm._watcher.teardown(); } // 销毁 computedWatchers 和 其他的 watchers let i = vm._watchers.length; while (i--) { vm._watchers[i].teardown(); } // 移除 observer if (vm._data.__ob__) { vm._data.__ob__.vmCount--; } // 我死了 vm._isDestroyed = true; // 将组件对应的 VNode 置为 null vm.__patch__(vm._vnode, null); // 我真的死了 callHook(vm, \u0026#39;destroyed\u0026#39;); // 移除所有事件绑定 vm.$off(); if (vm.$el) { vm.$el.__vue__ = null; } if (vm.$vnode) { vm.$vnode.parent = null; } }; 生命周期 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 export const enum LifecycleHooks { BEFORE_CREATE = \u0026#39;bc\u0026#39;, CREATED = \u0026#39;c\u0026#39;, BEFORE_MOUNT = \u0026#39;bm\u0026#39;, MOUNTED = \u0026#39;m\u0026#39;, BEFORE_UPDATE = \u0026#39;bu\u0026#39;, UPDATED = \u0026#39;u\u0026#39;, BEFORE_UNMOUNT = \u0026#39;bum\u0026#39;, UNMOUNTED = \u0026#39;um\u0026#39;, DEACTIVATED = \u0026#39;da\u0026#39;, ACTIVATED = \u0026#39;a\u0026#39;, RENDER_TRIGGERED = \u0026#39;rtg\u0026#39;, RENDER_TRACKED = \u0026#39;rtc\u0026#39;, ERROR_CAPTURED = \u0026#39;ec\u0026#39; } export const createHook = lifecycle =\u0026gt; (hook, target) =\u0026gt; injectHook(lifecycle, hook, target); export function injectHook( type: LifecycleHooks, hook: Function \u0026amp; { __weh?: Function }, target: ComponentInternalInstance | null = currentInstance, prepend: boolean = false ): Function | undefined { if (target) { const hooks = target[type] || (target[type] = []); // 保存着实例对应的钩子函数的数组 const wrappedHook = hook.__weh || // __weh 的意思是“带有错误处理的” (hook.__weh = (...args: unknown[]) =\u0026gt; { if (target.isUnmounted) { return; } pauseTracking(); // 在 Hook 中禁用依赖收集 /** * 在 Hook 调用期间，设置 currentInstance 为 target * 只有当用户做了一些 funky 操作，这条假设（钩子不会同步触发其他钩子）才不成立 */ setCurrentInstance(target); const res = callWithAsyncErrorHandling(hook, target, type, args); setCurrentInstance(null); // 释放 currentInstance resetTracking(); // 恢复依赖收集 return res; }); if (prepend) { hooks.unshift(wrappedHook); } else { hooks.push(wrappedHook); } return wrappedHook; } } // 在 setup 内部，没有 beforeCreate 和 created 钩子；setup 充当了这两个钩子的角色 export const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT); export const onMounted = createHook(LifecycleHooks.MOUNTED); export const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE); export const onUpdated = createHook(LifecycleHooks.UPDATED); export const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT); export const onUnmounted = createHook(LifecycleHooks.UNMOUNTED); // 酱紫写，是为了区分 ErrorCapturedHook 与普通 Hook 的不同 export type ErrorCapturedHook = ( err: unknown, instance: ComponentPublicInstance | null, info: string ) =\u0026gt; boolean | void; export const onErrorCaptured = (hook, target) =\u0026gt; { injectHook(LifecycleHooks.ERROR_CAPTURED, hook, target); }; 在 setup 内部，没有 beforeCreate 和 created 钩子；setup 充当了这两个钩子的角色。对于 Options API，beforeCreate 和 created 继续存在；组件在 mountComponent 时会调用 setupComponent，最终会调用 applyOptions 将 options API 和 composition API 进行合并。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 export function applyOptions( instance: ComponentInternalInstance, options: ComponentOptions, deferredData: DataFn[] = [], deferredWatch: ComponentWatchOptions[] = [], deferredProvide: (Data | Function)[] = [], asMixin: boolean = false ) { // 在明确了上下文和 this 之后，应用“GlobalMixins”之前会调用“beforeCreate” if (!asMixin) { isInBeforeCreate = true; callSyncHook( \u0026#39;beforeCreate\u0026#39;, LifecycleHooks.BEFORE_CREATE, options, instance, globalMixins ); isInBeforeCreate = false; // 应用 GlobalMixins } // 应用 extendsOptions // 应用 mixins // 处理 injectOptions // 合并 methods // 处理 dataOptions // 处理 computedOptions // 处理 watchOptions // 处理 provideOptions if (!asMixin) { callSyncHook( \u0026#39;created\u0026#39;, LifecycleHooks.CREATED, options, instance, globalMixins ); } // 处理 lifecycleOptions } function callSyncHook( name: \u0026#39;beforeCreate\u0026#39; | \u0026#39;created\u0026#39;, type: LifecycleHooks, options: ComponentOptions, instance: ComponentInternalInstance, globalMixins: ComponentOptions[] ) { // 循环 globalMixins 的深度，循环调用 mixins[i][name] callHookFromMixins(name, type, globalMixins, instance); const { extends: base, mixins } = options; if (base) { // 递归调用 base[name] callHookFromExtends(name, type, base, instance); } if (mixins) { // 循环 mixins 的深度，循环调用 mixins[i][name] callHookFromMixins(name, type, mixins, instance); } // 调用自身的 beforeCreate 或 created const selfHook = options[name]; if (selfHook) { callWithAsyncErrorHandling(selfHook.bind(instance.proxy!), instance, type); } } onActivated 和 onDeactivated 会通过 registerKeepAliveHook 进行注册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 export function onActivated(hook, target) { registerKeepAliveHook(hook, LifecycleHooks.ACTIVATED, target); } export function onDeactivated(hook, target) { registerKeepAliveHook(hook, LifecycleHooks.DEACTIVATED, target); } function registerKeepAliveHook( hook: Function \u0026amp; { __wdc?: Function }, type: LifecycleHooks, target: ComponentInternalInstance | null = currentInstance ) { // __wdc 的意思是“带有失活检查的”，这玩意，调度器会删除重复的钩子 const wrappedHook = hook.__wdc || (hook.__wdc = () =\u0026gt; { // 仅当目标实例不在 deactivated 状态中时才触发 Hook let current: ComponentInternalInstance | null = target; while (current) { if (current.isDeactivated) { return; } current = current.parent; } hook(); }); injectHook(type, wrappedHook, target); /** * 除了在目标实例上注册它之外 * 向上遍历父链，并将其注册到‘are keep-alive roots’的所有祖先实例上 * 这避免了在调用这些钩子时需要遍历整个组件树，更重要的是，避免了跟踪数组中的子组件 */ if (target) { let current = target.parent; while (current \u0026amp;\u0026amp; current.parent) { if (isKeepAlive(current.parent.vnode)) { injectToKeepAliveRoot(wrappedHook, type, target, current); } current = current.parent; } } } computed 2.x computed 是定义在 vm 上的特殊 getter，computedWatcher 在创建的时候会将 dirty 和 lazy 属性设置为 true；当 computed 的值被访问，触发 computedGetter，computedGetter 会调用 watcher.evaluate 进行求值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 export function initState (vm: Component) { // ... if (opts.computed) initComputed(vm, opts.computed) // ... } // 在 initState 过程中会调用 initComputed(vm, opts.computed) function initComputed(vm, computed) { // 实例的 computed 创建的 watcher 都保存在 vm._computedWatchers const watchers = (vm._computedWatchers = Object.create(null)); // 循环组件内 computed 配置 for (const key in computed) { /** * computed 有两种形式： * 1. a: () =\u0026gt; someValue * 2. b: { get:..., set:... } * 最终，都会转化为 getter/setter */ const userDef = computed[key]; const getter = typeof userDef === \u0026#39;function\u0026#39; ? userDef : userDef.get; if (getter == null) { warn(\u0026#39;没有 getter？开什么玩笑\u0026#39;); } // 为计算属性创建 watcher，这里的“副作用回调”为 noop watchers[key] = new Watcher(vm, getter || noop, noop, { lazy: true }); // 判断 computed 属性是否和 vm.$data、vm.$options.methods、vm.$options.props 冲突 if (!(key in vm)) { defineComputed(vm, key, userDef); } else { // 冲突的话，抛出警告 if (key in vm.$data) { warn(`already defined in data`); } else if (vm.$options.props \u0026amp;\u0026amp; key in vm.$options.props) { warn(`already defined as a prop`); } else if (vm.$options.methods \u0026amp;\u0026amp; key in vm.$options.methods) { warn(`already defined as a method`); } } } } export function defineComputed(target, key, userDef) { userDef.get = typeof userDef === \u0026#39;function\u0026#39; ? userDef : userDef.get; Object.defineProperty(target, key, { get: createComputedGetter(key) set: userDef.set || noop }); } function createComputedGetter(key) { return function computedGetter() { const watcher = this._computedWatchers \u0026amp;\u0026amp; this._computedWatchers[key]; if (watcher) { if (watcher.dirty) { // 惰性求值 watcher.evaluate(); } if (Dep.target) { // 依赖收集 watcher.depend(); } return watcher.value; } }; } computed 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 // 处理两种参数形式 export function computed\u0026lt;T\u0026gt;( getterOrOptions: ComputedGetter\u0026lt;T\u0026gt; | WritableComputedOptions\u0026lt;T\u0026gt; ) { let getter: ComputedGetter\u0026lt;T\u0026gt;; let setter: ComputedSetter\u0026lt;T\u0026gt;; // 标准化参数 if (isFunction(getterOrOptions)) { getter = getterOrOptions; setter = NOOP; } else { getter = getterOrOptions.get; setter = getterOrOptions.set; } // 返回 computed 对象 return new ComputedRefImpl( getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set ) as any; } /** * computed 有别于一般的副作用（watch/render） * 它的 effect 在创建时，不会被运行一次（lazy 是 true） * 当内部的 value 被访问时，才进行第一次依赖收集（运行 this.effect 求值，然后被收集） * 当 getter 内部访问到的数据更新时，只会将 _dirty 置为 true * 当内部的 value 再次被访问时，才会重新求值 */ class ComputedRefImpl\u0026lt;T\u0026gt; { private _dirty = true; // 初始化的时候，默认是“脏”的 private _value!: T; public readonly __v_isRef = true; // computed 是一个 ref public readonly [ReactiveFlags.IS_READONLY]: boolean; public readonly effect: ReactiveEffect\u0026lt;T\u0026gt;; constructor( getter: ComputedGetter\u0026lt;T\u0026gt;, private readonly _setter: ComputedSetter\u0026lt;T\u0026gt;, isReadonly: boolean ) { /** * this.effect 还没有运行过，还没有被 getter 中访问到的数据收集过 * scheduler 运行，将 this._dirty 赋值为 true * valueGetter 会执行 this.effect 进行求值 * 如果 valueGetter 没有被访问到 * this.effect 也不会被依赖收集 * 更不会进行求值 */ this.effect = effect(getter, { // 等到 computedValueGetter 被访问时，才会运行 effect lazy: true, // 每当依赖更新，scheduler 将 this._dirty 设置为 true，并派发通知 scheduler: () =\u0026gt; { if (!this._dirty) { this._dirty = true; // 派发通知，通知访问该计算属性的 activeEffect 运行 trigger(toRaw(this), \u0026#39;set\u0026#39;, \u0026#39;value\u0026#39;); } } }); this[\u0026#39;__v_isReadonly\u0026#39;] = isReadonly; } get value() { /** * 渲染开始时，当 .value 真正被访问，computedValueGetter 才被触发 * 调用 this.effect，getter 副作用运行，track 被调用，依赖被收集 */ if (this._dirty) { // 值是通过调用 effect 获得的，缓存在 this._value 上 this._value = this.effect(); // 当被外界 get 之后，数据不再“脏”了（因为刚刚进行求值，值还是新的） this._dirty = false; } /** * computed 本身被访问，computed 内部的 getter 会访问别的响应式数据 * 这种情况会发生 effect 嵌套，所以这里需要触发 track * 这时候的 computed 很像一个 ref 有没有？ */ track(toRaw(this), \u0026#39;get\u0026#39;, \u0026#39;value\u0026#39;); // 返回计算值 return this._value; } set value(newValue: T) { this._setter(newValue); } } diff 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 // 挂载 export function mountComponent( vm: Component, el: ?Element, hydrating?: boolean ): Component { vm.$el = el; callHook(vm, \u0026#39;beforeMount\u0026#39;); let updateComponent = () =\u0026gt; { vm._update(vm._render(), hydrating); }; // 创建 renderWatcher new Watcher( vm, updateComponent, noop, { before() { if (vm._isMounted \u0026amp;\u0026amp; !vm._isDestroyed) { // 如果是更新流程，调用“beforeUpdate”钩子 callHook(vm, \u0026#39;beforeUpdate\u0026#39;); } } }, true ); hydrating = false; if (vm.$vnode == null) { vm._isMounted = true; callHook(vm, \u0026#39;mounted\u0026#39;); } return vm; } // 调用 render，返回 VNode Vue.prototype._render = function (): VNode { const vm: Component = this; const { render, _parentVnode } = vm.$options; if (_parentVnode) { vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots ); } // 设置父节点，这允许 render 访问占位符节点上的数据 vm.$vnode = _parentVnode; // 渲染自身 let vnode; try { /** * 不需要维护栈的原因是，render 是依次分开被调用的 * 当父级 patched 之后，嵌套组件的 render 才会被调用 */ currentRenderingInstance = vm; /** * vm._renderProxy = vm * vm.$createElement = (a, b, c, d) =\u0026gt; createElement(vm, a, b, c, d, true) */ vnode = render.call(vm._renderProxy, vm.$createElement); } catch (e) { handleError(e, vm, `render`); if (vm.$options.renderError) { try { vnode = vm.$options.renderError.call( vm._renderProxy, vm.$createElement, e ); } catch (e) { handleError(e, vm, `renderError`); vnode = vm._vnode; } } else { vnode = vm._vnode; } } finally { // 渲染完成，重置变量 currentRenderingInstance = null; } if (Array.isArray(vnode) \u0026amp;\u0026amp; vnode.length === 1) { vnode = vnode[0]; } if (!(vnode instanceof VNode)) { if (Array.isArray(vnode)) { warn(\u0026#39;2.x 里 render 不能返回多个节点，需要有一个根节点\u0026#39;); } // 返回空节点代替 vnode = createEmptyVNode(); } // 设置父节点 vnode.parent = _parentVnode; return vnode; }; // h 函数，生成 VNode export function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean ): VNode | Array\u0026lt;VNode\u0026gt; { if (Array.isArray(data) || isPrimitive(data)) { normalizationType = children; children = data; data = undefined; } if (isTrue(alwaysNormalize)) { normalizationType = ALWAYS_NORMALIZE; } return _createElement(context, tag, data, children, normalizationType); } export function _createElement( context: Component, tag?: string | Class\u0026lt;Component\u0026gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number ): VNode | Array\u0026lt;VNode\u0026gt; { if (isDef(data) \u0026amp;\u0026amp; isDef(data.__ob__)) { return createEmptyVNode(); } // \u0026lt;component :is=\u0026#34;xxx\u0026#34; /\u0026gt; if (isDef(data) \u0026amp;\u0026amp; isDef(data.is)) { tag = data.is; } if (!tag) { return createEmptyVNode(); } if (isDef(data) \u0026amp;\u0026amp; isDef(data.key) \u0026amp;\u0026amp; !isPrimitive(data.key)) { warn(\u0026#39;key 只能为“原始值”\u0026#39;); } // children 为数组并且第一项与函数 if (Array.isArray(children) \u0026amp;\u0026amp; typeof children[0] === \u0026#39;function\u0026#39;) { data = data || {}; // 作为作用域插槽的默认值 data.scopedSlots = { default: children[0] }; children.length = 0; } if (normalizationType === ALWAYS_NORMALIZE) { children = normalizeChildren(children); } else if (normalizationType === SIMPLE_NORMALIZE) { children = simpleNormalizeChildren(children); } let vnode, ns; if (typeof tag === \u0026#39;string\u0026#39;) { let Ctor; ns = (context.$vnode \u0026amp;\u0026amp; context.$vnode.ns) || config.getTagNamespace(tag); if (config.isReservedTag(tag)) { // 平台原生/内建标签 if (isDef(data) \u0026amp;\u0026amp; isDef(data.nativeOn) \u0026amp;\u0026amp; data.tag !== \u0026#39;component\u0026#39;) { warn(\u0026#39;.native 修饰符只能用在组件上，而不是原生元素上\u0026#39;); } vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); } else if ( (!data || !data.pre) \u0026amp;\u0026amp; isDef((Ctor = resolveAsset(context.$options, \u0026#39;components\u0026#39;, tag))) ) { // Vue 组件，使用 createComponent 创建 VNode vnode = createComponent(Ctor, data, context, children, tag); } else { // 未知元素 vnode = new VNode(tag, data, children, undefined, undefined, context); } } else { // 组件选项/构造函数 vnode = createComponent(tag, data, context, children); } if (Array.isArray(vnode)) { return vnode; } else if (isDef(vnode)) { if (isDef(ns)) applyNS(vnode, ns); if (isDef(data)) registerDeepBindings(data); return vnode; } else { return createEmptyVNode(); } } export function createComponent( Ctor: Class\u0026lt;Component\u0026gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array\u0026lt;VNode\u0026gt;, tag?: string ): VNode | Array\u0026lt;VNode\u0026gt; | void { if (isUndef(Ctor)) { return; } const baseCtor = context.$options._base; if (isObject(Ctor)) { Ctor = baseCtor.extend(Ctor); } if (typeof Ctor !== \u0026#39;function\u0026#39;) { return; } // 异步组件 let asyncFactory; if (isUndef(Ctor.cid)) { asyncFactory = Ctor; Ctor = resolveAsyncComponent(asyncFactory, baseCtor); if (Ctor === undefined) { return createAsyncPlaceholder(asyncFactory, data, context, children, tag); } } data = data || {}; resolveConstructorOptions(Ctor); // v-model 转换为 props 和事件 if (isDef(data.model)) { transformModel(Ctor.options, data); } // 提取 props const propsData = extractPropsFromVNodeData(data, Ctor, tag); if (isTrue(Ctor.options.functional)) { // 函数式组件 return createFunctionalComponent(Ctor, propsData, data, context, children); } const listeners = data.on; // 使用 on.native 替代 nativeOn data.on = data.nativeOn; if (isTrue(Ctor.options.abstract)) { // 抽象组件除了 props、listeners、slot，什么都不管 const slot = data.slot; data = {}; if (slot) { data.slot = slot; } } installComponentHooks(data); const name = Ctor.options.name || tag; const vnode = new VNode( `vue-component-${Ctor.cid}${name ? `-${name}` : \u0026#39;\u0026#39;}`, data, undefined, undefined, undefined, context, { Ctor, propsData, listeners, tag, children }, asyncFactory ); return vnode; } // 将 VNode 更新到 DOM Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) { const vm: Component = this; const prevEl = vm.$el; // 旧 VNode 挂载的 DOM 节点 const prevVnode = vm._vnode; // 旧 VNode const restoreActiveInstance = setActiveInstance(vm); vm._vnode = vnode; if (!prevVnode) { // 初次渲染 vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false); } else { // 应用更新 vm.$el = vm.__patch__(prevVnode, vnode); } restoreActiveInstance(); if (prevEl) { prevEl.__vue__ = null; } if (vm.$el) { vm.$el.__vue__ = vm; } // 如果父组件是告诫组件，更新他的 $el 属性 if (vm.$vnode \u0026amp;\u0026amp; vm.$parent \u0026amp;\u0026amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el; } }; /** * patch 在做什么？ * 1. vnode 不存在，oldVnode 存在，销毁旧节点 * 2. vnode 存在： * 2.1 oldVnode 不存在，组件首次渲染 * 2.2 oldVnode 存在： * 2.2.1 oldVnode 是 DOM 元素，根组件的首次渲染 * 2.2.2 oldVnode 不是 DOM 元素，组件更新： * 2.2.2.1 oldVnode 与 vnode 相同节点，调用 patchVNode * 2.2.2.2 oldVnode 与 vnode 不同节点，卸载 oldVnode 创建 vnode * 什么是相同节点？ * 1. key 相等 * 2. tag 相同 * 3. 都（不）是注释节点 * 4. data 都（没有）定义 * 5. 如果是 input，type 要一致 * 6. 如果都是异步组件，工厂函数要完全相同 */ Vue.prototype.__patch__ = function patch( oldVnode, vnode, hydrating, removeOnly ) { // 旧节点存在新节点不存在，触发旧节点的 destory if (isUndef(vnode)) { if (isDef(oldVnode)) invokeDestroyHook(oldVnode); return; } let isInitialPatch = false; // 是否是初次 patch const insertedVnodeQueue = []; if (isUndef(oldVnode)) { // 旧节点不存在？肯定是第一次 patch，创建新的根元素 isInitialPatch = true; createElm(vnode, insertedVnodeQueue); } else { // 旧节点存在，属于更新流程 const isRealElement = isDef(oldVnode.nodeType); if (!isRealElement \u0026amp;\u0026amp; sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); } else { if (isRealElement) { // oldVnode 是 DOM 节点 if (oldVnode.nodeType === 1 \u0026amp;\u0026amp; oldVnode.hasAttribute(SSR_ATTR)) { oldVnode.removeAttribute(SSR_ATTR); hydrating = true; } oldVnode = emptyNodeAt(oldVnode); } const oldElm = oldVnode.elm; const parentElm = nodeOps.parentNode(oldElm); // 旧 VNode 对应元素的父级 // 创建一个 DOM 元素 createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ); // 递归更新父级的占位节点元素 if (isDef(vnode.parent)) { let ancestor = vnode.parent; const patchable = isPatchable(vnode); while (ancestor) { for (let i = 0; i \u0026lt; cbs.destroy.length; ++i) { cbs.destroy[i](ancestor); } ancestor.elm = vnode.elm; if (patchable) { for (let i = 0; i \u0026lt; cbs.create.length; ++i) { cbs.create[i](emptyNode, ancestor); } const insert = ancestor.data.hook.insert; if (insert.merged) { for (let i = 1; i \u0026lt; insert.fns.length; i++) { insert.fns[i](); } } } else { registerRef(ancestor); } ancestor = ancestor.parent; } } if (isDef(parentElm)) { removeVnodes([oldVnode], 0, 0); // 销毁旧节点 } else if (isDef(oldVnode.tag)) { invokeDestroyHook(oldVnode); // 触发就节点的 destory 钩子 } } } invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch); return vnode.elm; }; // 当 oldVnode 与 vnode 相同节点，会调用 patchVNode 更新节点 function patchVnode( oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly ) { // 一摸一样？返回 if (oldVnode === vnode) { return; } if (isDef(vnode.elm) \u0026amp;\u0026amp; isDef(ownerArray)) { vnode = ownerArray[index] = cloneVNode(vnode); } const elm = (vnode.elm = oldVnode.elm); if (isTrue(oldVnode.isAsyncPlaceholder)) { // 旧 VNode 异步占位 if (isDef(vnode.asyncFactory.resolved)) { hydrate(oldVnode.elm, vnode, insertedVnodeQueue); } else { vnode.isAsyncPlaceholder = true; } return; } // 如果是静态树，可以复用元素 if ( isTrue(vnode.isStatic) \u0026amp;\u0026amp; isTrue(oldVnode.isStatic) \u0026amp;\u0026amp; vnode.key === oldVnode.key \u0026amp;\u0026amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce)) ) { // 新旧都是静态的，且 key 相同 vnode.componentInstance = oldVnode.componentInstance; return; } let i; const data = vnode.data; // 调用 prepatch 钩子（更新之前的钩子） if (isDef(data) \u0026amp;\u0026amp; isDef((i = data.hook)) \u0026amp;\u0026amp; isDef((i = i.prepatch))) { i(oldVnode, vnode); } const oldCh = oldVnode.children; // 旧 VNode 子节点 const ch = vnode.children; // 新 VNode 子节点 if (isDef(data) \u0026amp;\u0026amp; isPatchable(vnode)) { // VNode 可修补 for (i = 0; i \u0026lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); if (isDef((i = data.hook)) \u0026amp;\u0026amp; isDef((i = i.update))) i(oldVnode, vnode); // 调用 VNode 的 Update } if (isUndef(vnode.text)) { if (isDef(oldCh) \u0026amp;\u0026amp; isDef(ch)) { // 新旧子节点不同，需要更新 if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); } else if (isDef(ch)) { // 旧子节点是文本？清空文本，添加新子节点 if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \u0026#39;\u0026#39;); addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue); } else if (isDef(oldCh)) { // 没有新子节点，仅有旧的子节点，那么删除旧的就好 removeVnodes(oldCh, 0, oldCh.length - 1); } else if (isDef(oldVnode.text)) { // 清空旧的文本子节点 nodeOps.setTextContent(elm, \u0026#39;\u0026#39;); } } else if (oldVnode.text !== vnode.text) { // 如果新旧子节点都为文本节点，更新文字就好 nodeOps.setTextContent(elm, vnode.text); } if (isDef(data)) { // 调用 postpatch 钩子（更新之后的钩子） if (isDef((i = data.hook)) \u0026amp;\u0026amp; isDef((i = i.postpatch))) i(oldVnode, vnode); } } // diff（更新新旧 VNode 的子节点） function updateChildren( parentElm, // VNode 对应的 DOM 元素 oldCh, // 旧 VNode 的子元素 newCh, // 新 VNode 的子元素 insertedVnodeQueue, removeOnly ) { // ... let oldStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; // 下一个未经 patch 的旧子 VNode 节点，在此索引之前的旧子 VNode 都已经处理完毕 let oldEndVnode = oldCh[oldEndIdx]; // 最后一个未经 patch 的旧子 VNode 节点，在此索引之后的旧子 VNode 都已经处理完毕 // ... let newStartIdx = 0; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; // 下一个未经 patch 的新子 VNode 节点，在此索引之前的新子 VNode 都已经处理完毕 let newEndVnode = newCh[newEndIdx]; // 最后一个未经 patch 的新子 VNode 节点，在此索引之前的新子 VNode 都已经处理完毕 // ... let oldKeyToIdx, idxInOld, vnodeToMove, refElm; // 只有 \u0026lt;transition-group\u0026gt; 用到，确保在 transitions 期间移除元素呆在正确的相对位置 const canMove = !removeOnly; /** * 当下一个未经处理的（新/旧）节点的索引小于等于最后一个未经处理的（新/旧）节点的索引 * 每次循环会进行四次比较： * 1. sameVnode(oldStartVnode, newStartVnode) * 2. sameVnode(oldEndVnode, newEndVnode) * 3. sameVnode(oldStartVnode, newEndVnode) * 4. sameVnode(oldEndVnode, newStartVnode) */ while (oldStartIdx \u0026lt;= oldEndIdx \u0026amp;\u0026amp; newStartIdx \u0026lt;= newEndIdx) { if (isUndef(oldStartVnode)) { oldStartVnode = oldCh[++oldStartIdx]; // 下一个旧的 } else if (isUndef(oldEndVnode)) { oldEndVnode = oldCh[--oldEndIdx]; // 上一个旧的 } else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode( oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx ); oldStartVnode = oldCh[++oldStartIdx]; // 下一个旧的 newStartVnode = newCh[++newStartIdx]; // 下一个新的 } else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode( oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx ); oldEndVnode = oldCh[--oldEndIdx]; // 上一个旧的 newEndVnode = newCh[--newEndIdx]; // 上一个新的 } else if (sameVnode(oldStartVnode, newEndVnode)) { // 下一个未经 patch 的旧子 VNode 节点 和 最后一个未经 patch 的新子 VNode 节点 相同 patchVnode( oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx ); canMove \u0026amp;\u0026amp; nodeOps.insertBefore( parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm) ); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; } else if (sameVnode(oldEndVnode, newStartVnode)) { // 最后一个未经 patch 的旧子 VNode 节点 和 下一个未经 patch 的新子 VNode 节点 相同 patchVnode( oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx ); canMove \u0026amp;\u0026amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; } else { if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); } idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); if (isUndef(idxInOld)) { createElm( newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx ); } else { vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) { patchVnode( vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx ); oldCh[idxInOld] = undefined; canMove \u0026amp;\u0026amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm); } else { createElm( newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx ); } } newStartVnode = newCh[++newStartIdx]; } } if (oldStartIdx \u0026gt; oldEndIdx) { refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm; addVnodes( parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue ); } else if (newStartIdx \u0026gt; newEndIdx) { removeVnodes(oldCh, oldStartIdx, oldEndIdx); } } diff 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 export const createApp = ((...args) =\u0026gt; { /** * patchProp 更新 props 方法集合 * forcePatchProp = (_, key) =\u0026gt; key === \u0026#39;value\u0026#39; * nodeOps DOM 操作方法集合 */ const rendererOptions = extend({ patchProp, forcePatchProp }, nodeOps); const { render } = baseCreateRenderer(rendererOptions); const createApp = createAppAPI(render); const app = createApp(...args); const { mount } = app; // 根组件挂载节点，ShadowRoot 接口是一个 DOM 子树的根节点，它与文档的主 DOM 树分开渲染 app.mount = (containerOrSelector: Element | ShadowRoot | string): any =\u0026gt; { const container = normalizeContainer(containerOrSelector); // HTMLElement || null if (!container) return; const component = app._component; if (!isFunction(component) \u0026amp;\u0026amp; !component.render \u0026amp;\u0026amp; !component.template) { component.template = container.innerHTML; } // 挂载之前清空 container container.innerHTML = \u0026#39;\u0026#39;; const proxy = mount(container); if (container instanceof Element) { container.removeAttribute(\u0026#39;v-cloak\u0026#39;); container.setAttribute(\u0026#39;data-v-app\u0026#39;, \u0026#39;\u0026#39;); } return proxy; }; return app; }) as CreateAppFunction\u0026lt;Element\u0026gt;; export function createAppAPI\u0026lt;HostElement\u0026gt;( render: RootRenderFunction ): CreateAppFunction\u0026lt;HostElement\u0026gt; { return function createApp(rootComponent, rootProps = null) { if (rootProps != null \u0026amp;\u0026amp; !isObject(rootProps)) { rootProps = null; } const context = createAppContext(); const installedPlugins = new Set(); let isMounted = false; const app: App = (context.app = { _uid: uid++, _component: rootComponent as ConcreteComponent, _props: rootProps, _container: null, _context: context, get config() { return context.config; }, set config(v) { warn(\u0026#39;app.config 不能被覆盖\u0026#39;); }, use(plugin: Plugin, ...options: any[]) { if (installedPlugins.has(plugin)) { warn(`插件已安装`); } else if (plugin \u0026amp;\u0026amp; isFunction(plugin.install)) { installedPlugins.add(plugin); plugin.install(app, ...options); } else if (isFunction(plugin)) { installedPlugins.add(plugin); plugin(app, ...options); } else { warn(\u0026#39;插件应该是一个函数或者一个有 install 方法的对象\u0026#39;); } return app; }, mixin(mixin: ComponentOptions) { if (!context.mixins.includes(mixin)) { context.mixins.push(mixin); if (mixin.props || mixin.emits) { context.deopt = true; } } else { warn(\u0026#39;mixin 过了\u0026#39;); } return app; }, component(name: string, component?: Component): any { if (!component) { return context.components[name]; } if (context.components[name]) { warn(\u0026#39;组件已经注册过了\u0026#39;); } context.components[name] = component; return app; }, directive(name: string, directive?: Directive) { if (!directive) { return context.directives[name] as any; } if (context.directives[name]) { warn(\u0026#39;指令已经注册过了\u0026#39;); } context.directives[name] = directive; return app; }, mount(rootContainer: HostElement): any { if (!isMounted) { const vnode = createVNode( rootComponent as ConcreteComponent, rootProps ); // 在根节点上存储 app context，在第一次渲染的，会被设为根实例 vnode.appContext = context; // 将 VNode 借助 patch 渲染到 container render(vnode, rootContainer); isMounted = true; app._container = rootContainer; return vnode.component!.proxy; } }, unmount() { if (isMounted) { // 直接渲染 null render(null, app._container); } else { warn(`没有挂载过，怎么卸载？`); } }, provide(key, value) { if ((key as string | symbol) in context.provides) { warn(\u0026#39;App 已经 provides 这个属性了，小心被覆盖\u0026#39;); } context.provides[key as string] = value; return app; } }); return app; }; } export function createRenderer\u0026lt; HostNode = RendererNode, HostElement = RendererElement \u0026gt;(options: RendererOptions\u0026lt;HostNode, HostElement\u0026gt;) { return baseCreateRenderer\u0026lt;HostNode, HostElement\u0026gt;(options); } function baseCreateRenderer( options: RendererOptions, // 操作原生元素的方法，浏览器平台为 DOM 操作方法 createHydrationFns?: typeof createHydrationFunctions ): any { const { insert: hostInsert, // parent.insertBefore(el, anchor) remove: hostRemove, patchProp: hostPatchProp, forcePatchProp: hostForcePatchProp, createElement: hostCreateElement, // document.createElement(vnode.type) createText: hostCreateText, createComment: hostCreateComment, // document.createComment(data) setText: hostSetText, setElementText: hostSetElementText, // el.textContent = text parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options; /** * 是否是相同节点（可以复用）：type \u0026amp; key 都相同 * 如果 n1 存在，并且 n1 n2 不能复用，卸载 n1 * 如果 n2 的 patchFlag 为 BAIL 忽略所有优化手段（dynamicChildren） * 根据 n2 的 type 的值，对 n2 类型做判断，分别做处理： * 文字 processText * 注释 processCommentNode * 静态 mountStaticNode * FRAGMENT processFragment * ELEMENT processElement: n1 === null ? mountElement : patchElement * mountElement 会调用原生方法挂载 n2，如果 n2.children 存在，会调用 mountChildren 将 n2.children 挂载到 n2.el 下 * patchElement 会根据 n2.patchFlag 调用 patchProps、patchBlockChildren、patchChildren 处理 n1 和 n2 及其子节点，并调用生命周期函数 * 如果 n2 是一个 Block，自身存在 dynamicChildren，调用 patchBlockChildren 处理动态子节点 * dynamicChildren 的结构是稳定的，只需要遍历 newChildren，调用 patch(old, new) 即可 * 如果 n2 不是一个 Block，调用 patchChildren 处理子节点 * 如果 n2.patchFlag\u0026amp;KEYED_FRAGMENT，patchChildren 调用 patchKeyedChildren * 这种情况，说明存在可以被复用的节点 * 从前向后遍历 i\u0026lt;=e1\u0026amp;\u0026amp;i\u0026lt;=e2，如果 c1[i] 和 c2[i] 可复用，调用 patch；否则，停止遍历；i++ * 从后向前遍历 i\u0026lt;=e1\u0026amp;\u0026amp;i\u0026lt;=e2，如果 c1[e1] 和 c2[e2] 可复用，调用 patch；否则，停止遍历；e1++ e2++ * 如果 i\u0026gt;e1，oldChildren 没有剩余 * 如果 i\u0026lt;=e2，newChildren 有剩余，调用 patch，挂载 c2[i] * 如果 i\u0026gt;e2，newChildren 没有剩余 * 如果 i\u0026lt;=e1，oldChildren 有剩余，调用 unmount，卸载 c1[i] * 此时 oldChildren/newChildren 均有剩余 * 从 s2 开始 e2 结束，遍历 newChildren，将 [c2[i].key,i] 保存在 keyToNewIndexMap（即 c2.key 到相对位置索引 i 的映射） * 初始化变量 patched（将要被 patch 的新节点数量）为 0 * 初始化变量 toBePatched（剩下的需要被 patch 的新节点数量）为 e2-s2+1 * 初始化一个长度为 toBePatched 的数组 newIndexToOldIndexMap，每项均为 0，用来保存每个 c2 在 oldChildren 中的位置（未更新前的位置） * 从 s1 开始 e1 结束，遍历剩余的 oldChildren * 如果 patched\u0026gt;toBePatched，说明 newChildren 的每项都被 patch 完了，调用 unmount 卸载 c1[i] 即可 * 如果 c1[i].key 存在，在 keyToNewIndexMap 中查找 c1[i] 在 newChildren 中的新的绝对位置 newIndex * 否则，从 s2 开始 e2 结束，遍历 newChildren，如果 c2[j] 在 oldChildren 中不存在，newIndex=j * 如果 newIndex 不存在，说明，c1[i] 在 newChildren 中不存在，需要被卸载掉 * 如果 newIndex 存在，说明 c1[i] 可以被复用，他的新的绝对位置是 newIndex，只是需要被移动 * 更新 newIndexToOldIndexMap[newIndex-s2]=i+1，处于 newIndex-s2 位置的可复用节点 c2 在 oldChildren 中的位置是 i+1 * newIndexToOldIndexMap 的下标都是相对位置，所以是 newIndex-s2 * 如果 newIndex 小于“遍历 oldChildren 过程中遇到的最大的 newIndex 值”maxNewIndexSoFar，说明当前节点不需要移动 * 对 c1[i] 和 c2[newIndex] 调用 patch，patched++ * 找出 newIndexToOldIndexMap 中“最长递增子序列”的下标，放到 increasingNewIndexSequence 数组里 * 从后向前（toBePatched-1 到 0）遍历剩余的 newChildren * 如果他在 newIndexToOldIndexMap 中的值为 0，说明这个节点在 oldChildren 中是没有的，需要新增 * 否则，节点需要被移动，调用 move 移动节点，锚点为 c2[nextIndex + 1] * 从后向前遍历，就是为了方便找移动的锚点 * 如果 n2.patchFlag\u0026amp;UNKEYED_FRAGMENT，patchChildren 调用 patchUnkeyedChildren * 遍历 commonLength，对 c1[i] 和 c2[i] 调用 patch * 如果 oldLength \u0026gt; newLength，调用 unmountChildren 卸载 commonLength 之后的所有剩下的 c1 * 否则，调用 mountChildren 挂载 commonLength 之后的所有剩下的 c2 * 如果 n2.shapeFlag\u0026amp;TEXT_CHILDREN * 如果 n1.shapeFlag\u0026amp;ARRAY_CHILDREN，调用 unmountChildren 卸载 c1 * 如果 c1 !== c2，将 c2 更新到页面上去 * 如果 n1.shapeFlag\u0026amp;ARRAY_CHILDREN * 如果 n2.shapeFlag\u0026amp;ARRAY_CHILDREN，调用 patchKeyedChildren * 否则，卸载 c1 * 如果 n1.shapeFlag\u0026amp;TEXT_CHILDREN，从页面上删除 c1 * 否则，调用 mountChildren，挂载 c2 即可 * COMPONENT processComponent * TELEPORT type.process，使用 vnode 自带的 process 方法 * SUSPENSE type.process，使用 vnode 自带的 process 方法 */ const patch: PatchFn = ( n1, // 旧 vnode n2, // 新 vnode container, // 挂载容器 anchor = null, // 挂载锚点 parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren ) =\u0026gt; { /** * isSameVNodeType 逻辑： * n1.type === n2.type \u0026amp;\u0026amp; n1.key === n2.key */ if (n1 \u0026amp;\u0026amp; !isSameVNodeType(n1, n2)) { // 如果 n1 存在，并且 n1 n2 不是相同节点，卸载 n1 anchor = getNextHostNode(n1); // 设置锚点为 n1 的宿主节点 unmount(n1, parentComponent, parentSuspense, true); n1 = null; // 保证后续挂载操作的正常执行 } if (n2.patchFlag === PatchFlags.BAIL) { // 如果 patchFlag 为 BAIL，忽略所有优化手段，清空 dynamicChildren n2.dynamicChildren = null; optimized = false; } const { type, ref, shapeFlag } = n2; // 判断新 vnode 的类型 switch (type) { case Text: // 文字节点 processText(n1, n2, container, anchor); break; case Comment: // 注释节点 processCommentNode(n1, n2, container, anchor); break; case Static: // 静态节点 if (n1 == null) { mountStaticNode(n2, container, anchor, isSVG); } break; case Fragment: // 代码片段 processFragment( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); break; default: if (shapeFlag \u0026amp; ShapeFlags.ELEMENT) { // 如果 n2 是 ELEMENT processElement( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else if (shapeFlag \u0026amp; ShapeFlags.COMPONENT) { // 如果 n2 是 COMPONENT/COMPONENT_KEPT_ALIVE processComponent( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else if (shapeFlag \u0026amp; ShapeFlags.TELEPORT) { /** * 如果 n2 是 TELEPORT，调用 Teleport 组件中的 process 方法 * 如果 n1 不存在，就将 n2.children 挂载到 n2.props.to 节点下 * n2 本身是一个虚拟节点，包含了一段代码片段 * 如果 n1 存在，调用 patchChildren(n1, n2, container) * 还需要处理 n1.props.to !== n2.props.to 这种情况 * 需要调用 move 进行节点移动操作 */ (type as typeof TeleportImpl).process( n1 as TeleportVNode, n2 as TeleportVNode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ); } else if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { // 如果 n2 是 SUSPENSE，调用 Suspense 组件中的 process 方法 (type as typeof SuspenseImpl).process( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ); } } if (ref != null \u0026amp;\u0026amp; parentComponent) { setRef(ref, n1 \u0026amp;\u0026amp; n1.ref, parentSuspense, n2 || n1, !n2); } }; const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) =\u0026gt; { if (n1 == null) { hostInsert( (n2.el = hostCreateText(n2.children as string)), container, anchor ); } else { const el = (n2.el = n1.el!); if (n2.children !== n1.children) { hostSetText(el, n2.children as string); } } }; const processCommentNode: ProcessTextOrCommentFn = ( n1, n2, container, anchor ) =\u0026gt; { if (n1 == null) { hostInsert( (n2.el = hostCreateComment((n2.children as string) || \u0026#39;\u0026#39;)), container, anchor ); } else { n2.el = n1.el; } }; const mountStaticNode = ( n2: VNode, container: RendererElement, anchor: RendererNode | null, isSVG: boolean ) =\u0026gt; { [n2.el, n2.anchor] = hostInsertStaticContent!( n2.children as string, container, anchor, isSVG ); }; const moveStaticNode = ( { el, anchor }: VNode, container: RendererElement, nextSibling: RendererNode | null ) =\u0026gt; { let next; while (el \u0026amp;\u0026amp; el !== anchor) { next = hostNextSibling(el); hostInsert(el, container, nextSibling); el = next; } hostInsert(anchor!, container, nextSibling); }; const removeStaticNode = ({ el, anchor }: VNode) =\u0026gt; { let next; while (el \u0026amp;\u0026amp; el !== anchor) { next = hostNextSibling(el); hostRemove(el); el = next; } hostRemove(anchor!); }; const processElement = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { isSVG = isSVG || (n2.type as string) === \u0026#39;svg\u0026#39;; if (n1 == null) { // 如果旧的 vnode 不存在，直接挂载 n2 即可 mountElement( n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else { // 对 n1 n2 进行 patch 操作 patchElement( n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } }; const mountElement = ( vnode: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { let el: RendererElement; let vnodeHook: VNodeHook | undefined | null; const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode; if ( vnode.el \u0026amp;\u0026amp; hostCloneNode !== undefined \u0026amp;\u0026amp; patchFlag === PatchFlags.HOISTED ) { // 静态提升节点，如果 vnode.el 存在，复用 DOM el = vnode.el = hostCloneNode(vnode.el); } else { // 创建 DOM el = vnode.el = hostCreateElement( vnode.type as string, isSVG, props \u0026amp;\u0026amp; props.is, props ); if (shapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { // 如果 vnode.children 为文本节点，设置 textContent hostSetElementText(el, vnode.children as string); } else if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 如果 vnode.children 为数组，调用 mountChildren 处理子节点数组 mountChildren( vnode.children as VNodeArrayChildren, el, // 将子节点都挂载到 el 下 null, parentComponent, parentSuspense, isSVG \u0026amp;\u0026amp; type !== \u0026#39;foreignObject\u0026#39;, slotScopeIds, optimized ); } if (dirs) { invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;created\u0026#39;); } // 处理 vnode.props if (props) { for (const key in props) { if (!isReservedProp(key)) { /** * 调用 node.setAttribute 等 API 处理 HTMLAttr/DOMProp * HTMLAttr 的值，在一些情况下会作为 DOMProp 初始值 * 内部会调用 shouldSetAsProp 处理特殊情况 * 如果 shouldSetAsProp 返回 true，作为 DOMProp 处理 * 如果 key 的属性值应该为 boolean，那么 prop[key] 如果为 \u0026#39;\u0026#39;，按照 true 处理 * 其他均作为 HTMLAttr 处理 * class 可以通过 className、classList、setAttribute 三种方式设置（性能依次递减） */ hostPatchProp( el, key, null, props[key], isSVG, vnode.children as VNode[], parentComponent, parentSuspense, unmountChildren ); } } if ((vnodeHook = props.onVnodeBeforeMount)) { invokeVNodeHook(vnodeHook, parentComponent, vnode); } } setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent); } if (dirs) { invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;beforeMount\u0026#39;); } const needCallTransitionHooks = (!parentSuspense || (parentSuspense \u0026amp;\u0026amp; !parentSuspense.pendingBranch)) \u0026amp;\u0026amp; transition \u0026amp;\u0026amp; !transition.persisted; if (needCallTransitionHooks) { transition!.beforeEnter(el); } // 挂载 el hostInsert(el, container, anchor); if ( (vnodeHook = props \u0026amp;\u0026amp; props.onVnodeMounted) || needCallTransitionHooks || dirs ) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode); needCallTransitionHooks \u0026amp;\u0026amp; transition!.enter(el); dirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;mounted\u0026#39;); }, parentSuspense); } }; const setScopeId = ( el: RendererElement, vnode: VNode, scopeId: string | null, slotScopeIds: string[] | null, parentComponent: ComponentInternalInstance | null ) =\u0026gt; { if (scopeId) { hostSetScopeId(el, scopeId); } if (slotScopeIds) { for (let i = 0; i \u0026lt; slotScopeIds.length; i++) { hostSetScopeId(el, slotScopeIds[i]); } } if (parentComponent) { let subTree = parentComponent.subTree; if (vnode === subTree) { const parentVNode = parentComponent.vnode; setScopeId( el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent ); } } }; const mountChildren: MountChildrenFn = ( children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0 ) =\u0026gt; { // 遍历 children 数组，调用 patch 进行挂载 for (let i = start; i \u0026lt; children.length; i++) { const child = (children[i] = optimized ? cloneIfMounted(children[i] as VNode) : normalizeVNode(children[i])); patch( null, // 此时，旧的 child 不存在 child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } }; const patchElement = ( n1: VNode, n2: VNode, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { const el = (n2.el = n1.el!); // DOM 复用 let { patchFlag, dynamicChildren, dirs } = n2; patchFlag |= n1.patchFlag \u0026amp; PatchFlags.FULL_PROPS; const oldProps = n1.props || EMPTY_OBJ; const newProps = n2.props || EMPTY_OBJ; let vnodeHook: VNodeHook | undefined | null; if ((vnodeHook = newProps.onVnodeBeforeUpdate)) { invokeVNodeHook(vnodeHook, parentComponent, n2, n1); } if (dirs) { invokeDirectiveHook(n2, n1, parentComponent, \u0026#39;beforeUpdate\u0026#39;); } if (patchFlag \u0026gt; 0) { if (patchFlag \u0026amp; PatchFlags.FULL_PROPS) { // 动态 props patchProps( el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG ); } else { if (patchFlag \u0026amp; PatchFlags.CLASS) { // 动态 class if (oldProps.class !== newProps.class) { hostPatchProp(el, \u0026#39;class\u0026#39;, null, newProps.class, isSVG); } } if (patchFlag \u0026amp; PatchFlags.STYLE) { // 动态 style hostPatchProp(el, \u0026#39;style\u0026#39;, oldProps.style, newProps.style, isSVG); } if (patchFlag \u0026amp; PatchFlags.PROPS) { // props 的值动态 const propsToUpdate = n2.dynamicProps!; for (let i = 0; i \u0026lt; propsToUpdate.length; i++) { const key = propsToUpdate[i]; const prev = oldProps[key]; const next = newProps[key]; if ( next !== prev || (hostForcePatchProp \u0026amp;\u0026amp; hostForcePatchProp(el, key)) ) { hostPatchProp( el, key, prev, next, isSVG, n1.children as VNode[], parentComponent, parentSuspense, unmountChildren ); } } } } if (patchFlag \u0026amp; PatchFlags.TEXT) { // 动态 textContent if (n1.children !== n2.children) { hostSetElementText(el, n2.children as string); } } } else if (!optimized \u0026amp;\u0026amp; dynamicChildren == null) { patchProps( el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG ); } const areChildrenSVG = isSVG \u0026amp;\u0026amp; n2.type !== \u0026#39;foreignObject\u0026#39;; if (dynamicChildren) { // 直接处理 dynamicChildren patchBlockChildren( n1.dynamicChildren!, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds ); } else if (!optimized) { patchChildren( n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false ); } if ((vnodeHook = newProps.onVnodeUpdated) || dirs) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, n2, n1); dirs \u0026amp;\u0026amp; invokeDirectiveHook(n2, n1, parentComponent, \u0026#39;updated\u0026#39;); }, parentSuspense); } }; // 相比于 patchChildren 的优化，只会更新动态节点 const patchBlockChildren: PatchBlockChildrenFn = ( oldChildren, // n1.dynamicChildren newChildren, // n2.dynamicChildren fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds ) =\u0026gt; { // 只会对 dynamicChildren 进行遍历 patch，跳过了所有静态节点 for (let i = 0; i \u0026lt; newChildren.length; i++) { const oldVNode = oldChildren[i]; const newVNode = newChildren[i]; const container = oldVNode.el \u0026amp;\u0026amp; (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT || oldVNode.shapeFlag \u0026amp; ShapeFlags.TELEPORT) ? hostParentNode(oldVNode.el)! : fallbackContainer; patch( oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true ); } }; /** * 调用 hostPatchProp 处理节点 props * 比如事件监听 addEventListener * 需要对事件冒泡做特殊处理（performance.now） */ const patchProps = ( el: RendererElement, vnode: VNode, oldProps: Data, newProps: Data, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean ) =\u0026gt; { if (oldProps !== newProps) { // 遍历新的 props for (const key in newProps) { if (isReservedProp(key)) continue; const next = newProps[key]; // key 对应的新 props 值 const prev = oldProps[key]; // key 对应的旧 props 值 if ( next !== prev || (hostForcePatchProp \u0026amp;\u0026amp; hostForcePatchProp(el, key)) ) { hostPatchProp( el, key, prev, next, isSVG, vnode.children as VNode[], parentComponent, parentSuspense, unmountChildren ); } } // 遍历旧的，仅对不在新 props 里的属性作处理 if (oldProps !== EMPTY_OBJ) { for (const key in oldProps) { if (!isReservedProp(key) \u0026amp;\u0026amp; !(key in newProps)) { hostPatchProp( el, key, oldProps[key], null, isSVG, vnode.children as VNode[], parentComponent, parentSuspense, unmountChildren ); } } } } }; const processFragment = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(\u0026#39;\u0026#39;))!; const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(\u0026#39;\u0026#39;))!; let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2; if (dynamicChildren) { optimized = true; } if (fragmentSlotScopeIds) { slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds; } if (n1 == null) { // 旧的 vnode 不存在，挂载 n2.children 即可 hostInsert(fragmentStartAnchor, container, anchor); hostInsert(fragmentEndAnchor, container, anchor); mountChildren( n2.children as VNodeArrayChildren, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else { // 对 n1.children 和 n2.children 进行 patch if ( patchFlag \u0026gt; 0 \u0026amp;\u0026amp; patchFlag \u0026amp; PatchFlags.STABLE_FRAGMENT \u0026amp;\u0026amp; dynamicChildren \u0026amp;\u0026amp; n1.dynamicChildren ) { // children 不变的 Frangment patchBlockChildren( n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds ); if ( n2.key != null || (parentComponent \u0026amp;\u0026amp; n2 === parentComponent.subTree) ) { traverseStaticChildren(n1, n2, true /* shallow */); } } else { patchChildren( n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } } }; const processComponent = ( n1: VNode | null, n2: VNode, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { n2.slotScopeIds = slotScopeIds; if (n1 == null) { if (n2.shapeFlag \u0026amp; ShapeFlags.COMPONENT_KEPT_ALIVE) { // 激活组件 (parentComponent!.ctx as KeepAliveContext).activate( n2, container, anchor, isSVG, optimized ); } else { // 挂载组件 mountComponent( n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized ); } } else { // 更新组件 updateComponent(n1, n2, optimized); } }; const mountComponent: MountComponentFn = ( initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized ) =\u0026gt; { const compatMountInstance = __COMPAT__ \u0026amp;\u0026amp; initialVNode.isCompatRoot \u0026amp;\u0026amp; initialVNode.component; /** * 获取/创建组件实例 * 包含了数据状态、isMounted、渲染内容 subTree... */ const instance: ComponentInternalInstance = compatMountInstance || // 保存在 vnode.component 上 (initialVNode.component = createComponentInstance( initialVNode, parentComponent, parentSuspense )); if (isKeepAlive(initialVNode)) { (instance.ctx as KeepAliveContext).renderer = internals; } if (!(__COMPAT__ \u0026amp;\u0026amp; compatMountInstance)) { // 初始化组件，将内部状态转化为响应式数据 setupComponent(instance); } if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; instance.asyncDep) { parentSuspense \u0026amp;\u0026amp; parentSuspense.registerDep(instance, setupRenderEffect); if (!initialVNode.el) { const placeholder = (instance.subTree = createVNode(Comment)); processCommentNode(null, placeholder, container!, anchor); } return; } // 构建 renderEffect 并触发声明周期调用 setupRenderEffect( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized ); }; const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) =\u0026gt; { const instance = (n2.component = n1.component)!; if (shouldUpdateComponent(n1, n2, optimized)) { // 需要更新 if ( __FEATURE_SUSPENSE__ \u0026amp;\u0026amp; instance.asyncDep \u0026amp;\u0026amp; !instance.asyncResolved ) { updateComponentPreRender(instance, n2, optimized); return; } else { instance.next = n2; invalidateJob(instance.update); instance.update(); } } else { // 不需要更新 n2.component = n1.component; n2.el = n1.el; instance.vnode = n2; } }; /** * 组件渲染对应的 effect： * 通过 instance.isMounted 判断组件是更新还是挂载 * 执行 bm/bu，调用 render 获得 VDOM 并进行 patch * 执行 m/u 钩子函数 */ const setupRenderEffect: SetupRenderEffectFn = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized ) =\u0026gt; { // 会对 instance.isMounted 做判断 const componentUpdateFn = () =\u0026gt; { if (!instance.isMounted) { // 如果组件实例还没有 mount let vnodeHook: VNodeHook | null | undefined; const { el, props } = initialVNode; const { bm, m, parent } = instance; effect.allowRecurse = false; if (bm) { invokeArrayFns(bm); // 触发 beforeMount 生命周期 } if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeBeforeMount)) { invokeVNodeHook(vnodeHook, parent, initialVNode); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { instance.emit(\u0026#39;hook:beforeMount\u0026#39;); } effect.allowRecurse = true; if (el \u0026amp;\u0026amp; hydrateNode) { const hydrateSubTree = () =\u0026gt; { instance.subTree = renderComponentRoot(instance); hydrateNode!( el as Node, instance.subTree, instance, parentSuspense, null ); }; if (isAsyncWrapper(initialVNode)) { (initialVNode.type as ComponentOptions).__asyncLoader!().then( () =\u0026gt; !instance.isUnmounted \u0026amp;\u0026amp; hydrateSubTree() ); } else { hydrateSubTree(); } } else { // 得到 render 渲染结果 const subTree = (instance.subTree = renderComponentRoot(instance)); // 对渲染结果进行 patch patch( null, // 如果为 null，代表进行全新的挂载 subTree, container, anchor, instance, parentSuspense, isSVG ); initialVNode.el = subTree.el; } if (m) { // 将 mount 生命周期加入任务队列 queuePostRenderEffect(m, parentSuspense); } if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeMounted)) { const scopedInitialVNode = initialVNode; queuePostRenderEffect( () =\u0026gt; invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode), parentSuspense ); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { queuePostRenderEffect( () =\u0026gt; instance.emit(\u0026#39;hook:mounted\u0026#39;), parentSuspense ); } if (initialVNode.shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { // 将 activated 生命周期加入任务队列 instance.a \u0026amp;\u0026amp; queuePostRenderEffect(instance.a, parentSuspense); if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { queuePostRenderEffect( () =\u0026gt; instance.emit(\u0026#39;hook:activated\u0026#39;), parentSuspense ); } } instance.isMounted = true; // 更新组件实例挂载状态 initialVNode = container = anchor = null as any; } else { // 如果组件实例已经 mount let { next, bu, u, parent, vnode } = instance; let originNext = next; let vnodeHook: VNodeHook | null | undefined; if (next) { next.el = vnode.el; updateComponentPreRender(instance, next, optimized); } else { next = vnode; } effect.allowRecurse = false; if (bu) { invokeArrayFns(bu); // 触发 beforeUpdate 生命周期 } if ((vnodeHook = next.props \u0026amp;\u0026amp; next.props.onVnodeBeforeUpdate)) { invokeVNodeHook(vnodeHook, parent, next, vnode); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { instance.emit(\u0026#39;hook:beforeUpdate\u0026#39;); } effect.allowRecurse = true; const nextTree = renderComponentRoot(instance); // 重新渲染 subTree const prevTree = instance.subTree; instance.subTree = nextTree; // 对渲染前后的 subTree 进行 diff patch( prevTree, nextTree, hostParentNode(prevTree.el!)!, getNextHostNode(prevTree), instance, parentSuspense, isSVG ); next.el = nextTree.el; if (originNext === null) { updateHOCHostEl(instance, nextTree.el); } if (u) { queuePostRenderEffect(u, parentSuspense); // 触发 updated 生命周期 } if ((vnodeHook = next.props \u0026amp;\u0026amp; next.props.onVnodeUpdated)) { queuePostRenderEffect( () =\u0026gt; invokeVNodeHook(vnodeHook!, parent, next!, vnode), parentSuspense ); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { queuePostRenderEffect( () =\u0026gt; instance.emit(\u0026#39;hook:updated\u0026#39;), parentSuspense ); } } }; const effect = new ReactiveEffect( componentUpdateFn, // 调用 componentUpdateFn 完成依赖收集 () =\u0026gt; queueJob(instance.update), // 组件的后续更新，放在 queueJob 队列中 instance.scope ); const update = (instance.update = effect.run.bind(effect) as SchedulerJob); update.id = instance.uid; effect.allowRecurse = update.allowRecurse = true; update(); }; const updateComponentPreRender = ( instance: ComponentInternalInstance, nextVNode: VNode, optimized: boolean ) =\u0026gt; { nextVNode.component = instance; // 更新 nextVNode 组件实例的指向 const prevProps = instance.vnode.props; // 获取更新前的 props instance.vnode = nextVNode; // 更新组件实例 vnode 指向 instance.next = null; updateProps(instance, nextVNode.props, prevProps, optimized); // 更新组件实例 props updateSlots(instance, nextVNode.children, optimized); // 调用插槽 pauseTracking(); flushPreFlushCbs(undefined, instance.update); resetTracking(); }; // diff 核心：patchChildren、patchKeyedChildren、patchUnkeyedChildren const patchChildren: PatchChildrenFn = ( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false ) =\u0026gt; { const c1 = n1 \u0026amp;\u0026amp; n1.children; const prevShapeFlag = n1 ? n1.shapeFlag : 0; const c2 = n2.children; const { patchFlag, shapeFlag } = n2; if (patchFlag \u0026gt; 0) { if (patchFlag \u0026amp; PatchFlags.KEYED_FRAGMENT) { // children 有 key 的 Frangment，处理带有 key 属性的情况 patchKeyedChildren( c1 as VNode[], c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); return; } else if (patchFlag \u0026amp; PatchFlags.UNKEYED_FRAGMENT) { // children 没有 key 的 Frangment，处理没有 key 属性的情况 patchUnkeyedChildren( c1 as VNode[], c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); return; } } if (shapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { // 处理 n2.children 为文本节点的情况（n1.children 可能：没有节点｜文本节点｜一组节点） if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 如果 n1.children 为一组节点，unmountChildren 会循环卸载所有 n1.children unmountChildren(c1 as VNode[], parentComponent, parentSuspense); } if (c2 !== c1) { // 此时 n1.children 可能：没有节点｜文本节点 hostSetElementText(container, c2 as string); } } else { // 此时 n2.children 可能：没有节点｜一组节点 if (prevShapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 如果 n1.children 为一组节点 if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { /** * 并且 n2.children 也为一组节点，对 c1 c2 进行 patch * 最简单的 diff，n1.children 全部卸载，n2.children 全部挂载 */ patchKeyedChildren( c1 as VNode[], c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else { // n2.children 什么也没有，卸载 n1.children 即可 unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true); } } else { // 此时 n1.children 可能：没有节点｜文本节点 if (prevShapeFlag \u0026amp; ShapeFlags.TEXT_CHILDREN) { // 如果 n1.children 为文本节点，删除文本 hostSetElementText(container, \u0026#39;\u0026#39;); } if (shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) { // 如果 n2.children 为一组节点，挂载 n2.children mountChildren( c2 as VNodeArrayChildren, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } } } }; /** * 对于没有 key 的情况： * 循环 commonLength 次，对 c1[i] 和 c2[i] 进行 patch 操作 * oldLength \u0026gt; newLength，卸载旧的节点（commonLength 之后的） * oldLength \u0026lt; newLength，挂载新的节点（commonLength 之后的） */ const patchUnkeyedChildren = ( c1: VNode[], c2: VNodeArrayChildren, container: RendererElement, anchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { c1 = c1 || EMPTY_ARR; c2 = c2 || EMPTY_ARR; const oldLength = c1.length; // 旧节点长度 const newLength = c2.length; // 新节点长度 const commonLength = Math.min(oldLength, newLength); // 取最短（公共长度） let i; for (i = 0; i \u0026lt; commonLength; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])); // 对 c1[i] 和 c2[i] 进行 patch 操作 patch( c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } if (oldLength \u0026gt; newLength) { // 卸载旧的节点 unmountChildren( c1, parentComponent, parentSuspense, true, false, commonLength // commonLength 之后的 ); } else { // 挂载新的节点 mountChildren( c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength // commonLength 之后的 ); } }; /** * 快速 Diff 算法： * 对于有 key 的情况（新旧节点存在可复用的情况） * 只要 vnode 的 type 相同、key 相同，就认为是相同节点 */ const patchKeyedChildren = ( c1: VNode[], // oldChildren c2: VNodeArrayChildren, // newChildren container: RendererElement, parentAnchor: RendererNode | null, parentComponent: ComponentInternalInstance | null, parentSuspense: SuspenseBoundary | null, isSVG: boolean, slotScopeIds: string[] | null, optimized: boolean ) =\u0026gt; { let i = 0; // newStartIndex/oldStartIndex const l2 = c2.length; let e1 = c1.length - 1; // oldEndIndex let e2 = l2 - 1; // newEndIndex /** * 这个步骤用来处理相同的‘前置’节点 * (a b) c * (a b) d e * 从前向后遍历 * 每次循环对比 c1[i] 和 c2[i] * 如果 c1[i] 和 c2[i] 是相同节点，patch c1[i] 和 c2[i] * 否则终止循环，记录下 i */ while (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) { const n1 = c1[i]; const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])); if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else { break; } i++; } /** * 这个步骤用来处理相同的‘后置’节点 * a (b c) * d e (b c) * 从后向前遍历 * 如果 c1[e1] 和 c2[e2] 是相同节点，patch c1[e1] 和 c2[e2] * 否则终止循环，记录下 e1 和 e2 */ while (i \u0026lt;= e1 \u0026amp;\u0026amp; i \u0026lt;= e2) { const n1 = c1[e1]; const n2 = (c2[e2] = optimized ? cloneIfMounted(c2[e2] as VNode) : normalizeVNode(c2[e2])); if (isSameVNodeType(n1, n2)) { patch( n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else { break; } e1--; e2--; } if (i \u0026gt; e1) { /** * 前置相同节点和后置相同节点处理完毕后 * 如果 oldStartIndex 大于 oldEndIndex * 说明，对 oldChildren 完成了完整的遍历 * oldChildren 中没有剩余节点 */ if (i \u0026lt;= e2) { /** * 如果 newStartIndex 小于等于 newEndIndex * 说明，对 newChildren 没有完成完整的遍历 * newChildren 中有新增节点 */ const nextPos = e2 + 1; // 通过 newStartIndex 找到挂载锚点，如果 newStartIndex + 1 已经大于 newChildren 的长度，则锚点应为父元素 const anchor = nextPos \u0026lt; l2 ? (c2[nextPos] as VNode).el : parentAnchor; // 遍历剩下的 newChildren while (i \u0026lt;= e2) { patch( null, (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); i++; } } } else if (i \u0026gt; e2) { /** * 如果 newStartIndex 大于 newEndIndex * 说明，对 newChildren 完成完整的遍历 * newChildren 中没有剩余节点 * 卸载剩下的 oldChildren */ while (i \u0026lt;= e1) { unmount(c1[i], parentComponent, parentSuspense, true); i++; } } else { // newChildren 和 oldChildren 都没完成完整的遍历，新旧节点均有剩余 const s1 = i; // oldStartIndex const s2 = i; // newStartIndex const keyToNewIndexMap: Map\u0026lt;string | number, number\u0026gt; = new Map(); // 将剩余的 newChildrenKey 和索引映射为 Map // 遍历剩余的 newChildren，将 c2[i].key 和在 newChildren 中的实际 index 保存在 Map 中 for (i = s2; i \u0026lt;= e2; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])); if (nextChild.key != null) { keyToNewIndexMap.set(nextChild.key, i); // i 是绝对位置，因为是从 s2 开始的 } } let j; let moved = false; // 是否需要移动节点 let patched = 0; // 已经被 patch 的节点数量 let maxNewIndexSoFar = 0; // 遍历 oldChildren 过程中遇到的最大的 newIndex 值 const toBePatched = e2 - s2 + 1; // newChildren 中，需要被 patch 的节点个数（剩余节点数量） /** * 新建长度为 toBePatched 的数组，用来保存“newChildren 中的节点在 oldChildren 中的位置（原先的位置）” * newIndexToOldIndexMap[newChild 的相对位置] = oldChild 的下标 + 1（如果找得到的话） * 需要计算出 newIndexToOldIndexMap 中的最长递增子序列 * 0 1 2 3 4 5 6 * a b [c d e] f g * a b [e c d h] f g * [5,3,4,0] * [5,3,4,0] 中，3,4 不需要移动，5 需要移动，0 需要新建 * newChildren 中的 h 节点没有找到可复用的对应节点，所以对应的值为 0 * 在 newIndexToOldIndexMap 中查找“最长递增子序列”的目的是为了“尽可能少的移动节点”，在子序列中出现的节点是不用动的 */ const newIndexToOldIndexMap = new Array(toBePatched); for (i = 0; i \u0026lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0; // 遍历 oldChildren for (i = s1; i \u0026lt;= e1; i++) { const prevChild = c1[i]; // 拿取一个 oldChild if (patched \u0026gt;= toBePatched) { /** * 如果已经被 patch 的节点数量 \u0026gt;= 需要被 patch 的节点数量 * newChildren 中已经没有要更新的节点 * 卸载 prevChild 即可 */ unmount(prevChild, parentComponent, parentSuspense, true); continue; // 跳过本次循环 } let newIndex; if (prevChild.key != null) { /** * newIndex 取 prevChild.key 在 keyToNewIndexMap 中对应的 value（绝对位置） * newIndex 指可复用节点 prevChild 在 newChildren 中的位置 * 此时，c2[newIndex] 对应的可复用节点为 prevChild/c1[i] * 如果能取到，说明节点可以复用 * 如果取不到，卸载 prevChild */ newIndex = keyToNewIndexMap.get(prevChild.key); } else { // 如果 prevChild.key 是 null，遍历剩余（s2～e2）的 newChildren for (j = s2; j \u0026lt;= e2; j++) { if ( /** * newIndexToOldIndexMap 的下标为相对位置，所以是 j-s2 * 如果 j-s2 位置的值 === 0 * j-s2 对应的节点没有被复用 */ newIndexToOldIndexMap[j - s2] === 0 \u0026amp;\u0026amp; isSameVNodeType(prevChild, c2[j] as VNode) ) { newIndex = j; // 新增节点的位置 break; } } } if (newIndex === undefined) { // 如果 newChildren 中没有找到和 c1[i] 有相同 key 的节点，卸载 c1[i] unmount(prevChild, parentComponent, parentSuspense, true); } else { /** * 找到了就进行 patch（c1[i] 和 c2[newIndex]），还要更新 patched 的值 * 既然找到了可复用的元素，更新 newIndexToOldIndexMap */ newIndexToOldIndexMap[newIndex - s2] = i + 1; if (newIndex \u0026gt;= maxNewIndexSoFar) { /** * 如果 c1[i] 在 newChildren 中的新位置 newIndex 比 maxNewIndexSoFar 还要大 * 因为是从前向后遍历的，如果每次 newIndex 都比上次的 newIndex 大 * 说明不需要进行移动操作，更新 maxNewIndexSoFar 即可 */ maxNewIndexSoFar = newIndex; } else { /** * 如果 newIndex 突然出现有小于 maxNewIndexSoFar * 说明，newIndex 的递增趋势被打破 * 有节点要插队，需要移动节点 * 否则，就没有必要计算子序列 */ moved = true; } patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); patched++; } } /** * 到了这一步，没用的旧节点已经被卸载了，可以“被复用的不需要被移动”的旧节点也被 patch 了 * 如果出现了需要移动旧节点到新位置的情况（moved===true） * 需要计算出 newIndexToOldIndexMap 中的最长递增子序列的“索引/下标” * newIndexToOldIndexMap: [5,3,4,0] * 最长递增子序列为：[3,4] * 对应的下标为：[1,2] * 此时，increasingNewIndexSequence 为 [1,2] */ const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR; /** * 获取 increasingNewIndexSequence 中最后一个元素的下标 * 下标本身没什么实际意义，算是“最长递增子序列”长度的别名 * 在循环 toBePatched-\u0026gt;0 的时候，用来判断： * 什么时候开始移动（跳过多少个节点不移动） * 因为子序列里的节点是稳定的，不需要移动 */ j = increasingNewIndexSequence.length - 1; /** * 从后向前遍历需要被处理的剩余节点，处理 move \u0026amp; mount 情况 * 为什么不“从前往后”遍历呢？因为“插入节点”需要有一个“锚点” * 这里的 i 表示“相对位置” */ for (i = toBePatched - 1; i \u0026gt;= 0; i--) { const nextIndex = s2 + i; // 在 newChildren 中的索引（绝对位置） const nextChild = c2[nextIndex] as VNode; // 拿到待处理的 nextChild // 锚点为 c2[nextIndex + 1] 或父级锚点（根据 newIndex+1 和 l2 的关系） const anchor = nextIndex + 1 \u0026lt; l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor; if (newIndexToOldIndexMap[i] === 0) { // 在 oldChildren 中没有对应的节点，属于新增的节点，挂载 nextChild patch( null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ); } else if (moved) { if (i !== increasingNewIndexSequence[j] || j \u0026lt; 0) { /** * 当前相对下标和子序列里的最后的下标不相等 * 或者，不在子序列里的节点 * 需要移动 */ move(nextChild, container, anchor, MoveType.REORDER); } else { j--; } } } } }; const move: MoveFn = ( vnode, container, anchor, moveType, parentSuspense = null ) =\u0026gt; { const { el, type, transition, children, shapeFlag } = vnode; if (shapeFlag \u0026amp; ShapeFlags.COMPONENT) { move(vnode.component!.subTree, container, anchor, moveType); return; } if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { vnode.suspense!.move(container, anchor, moveType); return; } if (shapeFlag \u0026amp; ShapeFlags.TELEPORT) { (type as typeof TeleportImpl).move(vnode, container, anchor, internals); return; } if (type === Fragment) { hostInsert(el!, container, anchor); for (let i = 0; i \u0026lt; (children as VNode[]).length; i++) { move((children as VNode[])[i], container, anchor, moveType); } hostInsert(vnode.anchor!, container, anchor); return; } if (type === Static) { moveStaticNode(vnode, container, anchor); return; } const needTransition = moveType !== MoveType.REORDER \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.ELEMENT \u0026amp;\u0026amp; transition; if (needTransition) { if (moveType === MoveType.ENTER) { // 挂载 DOM 之前，调用 transition.beforeEnter 钩子 transition!.beforeEnter(el!); hostInsert(el!, container, anchor); // 挂载 DOM 之后，调用 transition.enter 钩子 queuePostRenderEffect(() =\u0026gt; transition!.enter(el!), parentSuspense); } else { const { leave, delayLeave, afterLeave } = transition!; const remove = () =\u0026gt; hostInsert(el!, container, anchor); const performLeave = () =\u0026gt; { leave(el!, () =\u0026gt; { remove(); afterLeave \u0026amp;\u0026amp; afterLeave(); }); }; if (delayLeave) { // 调用 transition.delayLeave delayLeave(el!, remove, performLeave); } else { // 调用 transition.leave \u0026amp; transition.afterLeave performLeave(); } } } else { hostInsert(el!, container, anchor); } }; /** * 卸载 vnode * 调用自身/子级组件生命周期 * 调用自定义指令声明周期 * 移除 DOM 事件绑定 * 移除 DOM 元素 */ const unmount: UnmountFn = ( vnode, parentComponent, parentSuspense, doRemove = false, optimized = false ) =\u0026gt; { const { type, props, ref, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode; if (ref != null) { setRef(ref, null, parentSuspense, vnode, true); } if (shapeFlag \u0026amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) { // 如果包裹在 keep-alive 组件，调用 deactivate 声明周期 (parentComponent!.ctx as KeepAliveContext).deactivate(vnode); return; } const shouldInvokeDirs = shapeFlag \u0026amp; ShapeFlags.ELEMENT \u0026amp;\u0026amp; dirs; let vnodeHook: VNodeHook | undefined | null; if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeBeforeUnmount)) { invokeVNodeHook(vnodeHook, parentComponent, vnode); } if (shapeFlag \u0026amp; ShapeFlags.COMPONENT) { // 卸载对应 vnode 对应的组件实例 unmountComponent(vnode.component!, parentSuspense, doRemove); } else { if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { vnode.suspense!.unmount(parentSuspense, doRemove); return; } if (shouldInvokeDirs) { invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;beforeUnmount\u0026#39;); } if (shapeFlag \u0026amp; ShapeFlags.TELEPORT) { (vnode.type as typeof TeleportImpl).remove( vnode, parentComponent, parentSuspense, optimized, internals, doRemove ); } else if ( dynamicChildren \u0026amp;\u0026amp; (type !== Fragment || (patchFlag \u0026gt; 0 \u0026amp;\u0026amp; patchFlag \u0026amp; PatchFlags.STABLE_FRAGMENT)) ) { // children 不变的 Frangment unmountChildren( dynamicChildren, parentComponent, parentSuspense, false, true ); } else if ( (type === Fragment \u0026amp;\u0026amp; (patchFlag \u0026amp; PatchFlags.KEYED_FRAGMENT || patchFlag \u0026amp; PatchFlags.UNKEYED_FRAGMENT)) || (!optimized \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.ARRAY_CHILDREN) ) { // 如果为 Fragment，卸载 children unmountChildren(children as VNode[], parentComponent, parentSuspense); } if (doRemove) { remove(vnode); } } if ((vnodeHook = props \u0026amp;\u0026amp; props.onVnodeUnmounted) || shouldInvokeDirs) { queuePostRenderEffect(() =\u0026gt; { vnodeHook \u0026amp;\u0026amp; invokeVNodeHook(vnodeHook, parentComponent, vnode); shouldInvokeDirs \u0026amp;\u0026amp; invokeDirectiveHook(vnode, null, parentComponent, \u0026#39;unmounted\u0026#39;); }, parentSuspense); } }; const remove: RemoveFn = vnode =\u0026gt; { const { type, el, anchor, transition } = vnode; if (type === Fragment) { removeFragment(el!, anchor!); return; } if (type === Static) { removeStaticNode(vnode); return; } const performRemove = () =\u0026gt; { hostRemove(el!); if (transition \u0026amp;\u0026amp; !transition.persisted \u0026amp;\u0026amp; transition.afterLeave) { transition.afterLeave(); } }; if ( vnode.shapeFlag \u0026amp; ShapeFlags.ELEMENT \u0026amp;\u0026amp; transition \u0026amp;\u0026amp; !transition.persisted ) { const { leave, delayLeave } = transition; const performLeave = () =\u0026gt; leave(el!, performRemove); if (delayLeave) { delayLeave(vnode.el!, performRemove, performLeave); } else { performLeave(); } } else { performRemove(); } }; const removeFragment = (cur: RendererNode, end: RendererNode) =\u0026gt; { let next; while (cur !== end) { next = hostNextSibling(cur)!; hostRemove(cur); cur = next; } hostRemove(end); }; const unmountComponent = ( instance: ComponentInternalInstance, parentSuspense: SuspenseBoundary | null, doRemove?: boolean ) =\u0026gt; { const { bum, scope, update, subTree, um } = instance; if (bum) { invokeArrayFns(bum); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { instance.emit(\u0026#39;hook:beforeDestroy\u0026#39;); } if (scope) { scope.stop(); } if (update) { update.active = false; unmount(subTree, instance, parentSuspense, doRemove); } if (um) { queuePostRenderEffect(um, parentSuspense); } if ( __COMPAT__ \u0026amp;\u0026amp; isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance) ) { queuePostRenderEffect( () =\u0026gt; instance.emit(\u0026#39;hook:destroyed\u0026#39;), parentSuspense ); } queuePostRenderEffect(() =\u0026gt; { instance.isUnmounted = true; }, parentSuspense); if ( __FEATURE_SUSPENSE__ \u0026amp;\u0026amp; parentSuspense \u0026amp;\u0026amp; parentSuspense.pendingBranch \u0026amp;\u0026amp; !parentSuspense.isUnmounted \u0026amp;\u0026amp; instance.asyncDep \u0026amp;\u0026amp; !instance.asyncResolved \u0026amp;\u0026amp; instance.suspenseId === parentSuspense.pendingId ) { parentSuspense.deps--; if (parentSuspense.deps === 0) { parentSuspense.resolve(); } } }; const unmountChildren: UnmountChildrenFn = ( children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0 ) =\u0026gt; { // 遍历 children，一次调用 unmount，unmount 内部会递归调用 unmountChildren for (let i = start; i \u0026lt; children.length; i++) { unmount( children[i], parentComponent, parentSuspense, doRemove, optimized ); } }; const getNextHostNode: NextFn = vnode =\u0026gt; { if (vnode.shapeFlag \u0026amp; ShapeFlags.COMPONENT) { return getNextHostNode(vnode.component!.subTree); } if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; vnode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { return vnode.suspense!.next(); } return hostNextSibling((vnode.anchor || vnode.el)!); }; const render: RootRenderFunction = (vnode, container, isSVG) =\u0026gt; { if (vnode == null) { // 旧的 vnode 存在，新的 vnode 不存在，执行卸载（自身及子组件） if (container._vnode) { unmount(container._vnode, null, null, true); } } else { // 新旧的 vnode 存在，进行 diff/patch/mount patch( container._vnode || null, // 每次渲染完成，旧的 vnode 保存在 container._vnode，首次渲染时为 undefined vnode, // 将要被挂载到 DOM 的新 vnode container, // 挂载容器 null, null, null, isSVG ); } // 清空渲染后的任务队列 flushPostFlushCbs(); container._vnode = vnode; }; const internals: RendererInternals = { p: patch, um: unmount, m: move, r: remove, mt: mountComponent, mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, n: getNextHostNode, o: options }; let hydrate: ReturnType\u0026lt;typeof createHydrationFunctions\u0026gt;[0] | undefined; let hydrateNode: ReturnType\u0026lt;typeof createHydrationFunctions\u0026gt;[1] | undefined; if (createHydrationFns) { [hydrate, hydrateNode] = createHydrationFns( internals as RendererInternals\u0026lt;Node, Element\u0026gt; ); } return { render, hydrate, createApp: createAppAPI(render, hydrate) }; } function getSequence(arr) { const lis = [0]; // 保存着“最长递增子序列”的下标 const record = arr.slice(); const { length: len } = arr; for (let i = 0; i \u0026lt; len; i++) { const arrI = arr[i]; // Vue 中，需要用 0 表示新增节点的情况，所以跳过 if (arrI !== 0) { /** * lis[lis.length - 1] 表示最长递增子序列最后一个值的下标 * 所以 arr[last] 表示最长递增子序列的最后一个值 * 我们这里没有把最长递增子序列显式的定义出来 */ const last = lis[lis.length - 1]; /** * 如果最长递增子序列的最后一个值 arr[last] 小于 arrI * 说明 arrI 可以直接加入子序列 * 所以将对应的下标加入 lis */ if (arr[last] \u0026lt; arrI) { /** * “最长递增子序列”的最后一个元素 arr[last] 小于新来的元素 arrI * [1,3,5] \u0026lt;- 10，arr[last] 是 5，arrI 是 10 */ record[i] = last; // 记录一下 i 对应的下标 lis[lis.length - 1] lis.push(i); continue; } /** * 构建最长递增子序列时，最后一个元素，越小越好 * 如果 arr[last] \u0026gt;= arrI，需要进行元素替换 * 用 arrI 把比 arrI 大的最小的那个元素替换掉 * 所以，需要用二分查找替换 * 最终找到 arr[lis[left]] */ let left = 0, right = lis.length - 1; while (left \u0026lt; right) { /** * 找到“最长递增子序列”里中间的元素的下标 lis[mid] * 在去 arr 里找到对应的值 arr[lis[mid]] * arr[lis[mid]] 就是子序列的中间值 * 这里是去找 lis[mid] 对应的值 * 所以 arr 没有事先排序无所谓 * “最长递增子序列”是排好序的 */ const mid = (left + right) \u0026gt;\u0026gt; 1; if (arr[lis[mid]] \u0026lt; arrI) { // 比 arrI 大的最小的那个元素，在右边 left = mid + 1; } else { // 比 arrI 大的最小的那个元素，在左边 right = mid; } } // 找比 arrI 大的最小元素，用 arrI 替换掉 if (arrI \u0026lt; arr[lis[left]]) { if (left \u0026gt; 0) { /** * 因为发生了元素的替换，需要更新一下 record[i] * record[i] 从 lis[lis.length - 1] 变为了 lis[left - 1] */ record[i] = lis[left - 1]; } lis[left] = i; } } } let i = lis.length; // “最长递增子序列”的长度 let last = lis[i - 1]; // “最长递增子序列”中最后一个元素的下标 while (i-- \u0026gt; 0) { lis[i] = last; last = record[last]; } return lis; } export function createComponentInstance( vnode: VNode, parent: ComponentInternalInstance | null, suspense: SuspenseBoundary | null ) { const type = vnode.type as ConcreteComponent; // 继承父级的 appContext const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext; const instance: ComponentInternalInstance = { uid: uid++, // 唯一 ID vnode, type, parent, appContext, root: null!, next: null, subTree: null!, // 实例创建后，被同步设置 update: null!, // 实例创建后，被同步设置 scope: new EffectScope(), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: parent ? parent.provides : Object.create(appContext.provides), accessCache: null!, renderCache: [], components: null, directives: null, propsOptions: normalizePropsOptions(type, appContext), // 处理 props emitsOptions: normalizeEmitsOptions(type, appContext), // 处理 emits emit: null as any, emitted: null, propsDefaults: EMPTY_OBJ, // props 默认是一个对象 inheritAttrs: type.inheritAttrs, // 组件实例状态 ctx: EMPTY_OBJ, data: EMPTY_OBJ, props: EMPTY_OBJ, attrs: EMPTY_OBJ, slots: EMPTY_OBJ, refs: EMPTY_OBJ, setupState: EMPTY_OBJ, setupContext: null, // Suspense 相关 suspense, suspenseId: suspense ? suspense.pendingId : 0, asyncDep: null, asyncResolved: false, // 生命周期相关 isMounted: false, isUnmounted: false, isDeactivated: false, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; instance.ctx = { _: instance }; instance.root = parent ? parent.root : instance; instance.emit = emit.bind(null, instance); // 对自定义元素特殊处理 if (vnode.ce) { vnode.ce(instance); } return instance; } export function setupComponent( instance: ComponentInternalInstance, isSSR = false ) { isInSSRComponentSetup = isSSR; const { props, children } = instance.vnode; // 获取 vnode 的 props 和 children // isStateful = instance.vnode.shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT const isStateful = isStatefulComponent(instance); initProps(instance, props, isStateful, isSSR); initSlots(instance, children); const setupResult = isStateful ? // 调用 setupStatefulComponent setupStatefulComponent(instance, isSSR) : undefined; isInSSRComponentSetup = false; return setupResult; } function setupStatefulComponent( instance: ComponentInternalInstance, isSSR: boolean ) { const Component = instance.type as ComponentOptions; // 创建渲染代理 instance.accessCache = Object.create(null); instance.proxy = markRaw( new Proxy(instance.ctx, PublicInstanceProxyHandlers) ); const { setup } = Component; if (setup) { // {slots, emit, attrs, expose} const setupContext = (instance.setupContext = setup.length \u0026gt; 1 ? createSetupContext(instance) : null); setCurrentInstance(instance); // 将 instance 赋值给 currentInstance pauseTracking(); // 调用 setup，返回 Promise|function|{} const setupResult = callWithErrorHandling( setup, instance, ErrorCodes.SETUP_FUNCTION, [instance.props, setupContext] // setup 接受的两个参数 ); resetTracking(); unsetCurrentInstance(); // // 将 null 赋值给 currentInstance if (isPromise(setupResult)) { setupResult.then(unsetCurrentInstance, unsetCurrentInstance); if (isSSR) { return setupResult .then((resolvedResult: unknown) =\u0026gt; { handleSetupResult(instance, resolvedResult, isSSR); }) .catch(e =\u0026gt; { handleError(e, instance, ErrorCodes.SETUP_FUNCTION); }); } else if (__FEATURE_SUSPENSE__) { instance.asyncDep = setupResult; } } else { /** * 如果是函数，赋值给 instance.render * 如果是对象，赋值给 instance.setupState */ handleSetupResult(instance, setupResult, isSSR); } } else { finishComponentSetup(instance, isSSR); } } export function handleSetupResult( instance: ComponentInternalInstance, setupResult: unknown, isSSR: boolean ) { if (isFunction(setupResult)) { if (__NODE_JS__ \u0026amp;\u0026amp; (instance.type as ComponentOptions).__ssrInlineRender) { instance.ssrRender = setupResult; } else { instance.render = setupResult as InternalRenderFunction; } } else if (isObject(setupResult)) { instance.setupState = proxyRefs(setupResult); } finishComponentSetup(instance, isSSR); } export function finishComponentSetup( instance: ComponentInternalInstance, isSSR: boolean, skipOptions?: boolean ) { const Component = instance.type as ComponentOptions; if (__COMPAT__) { convertLegacyRenderFn(instance); } if (__NODE_JS__ \u0026amp;\u0026amp; isSSR) { instance.render = (instance.render || Component.render || NOOP) as InternalRenderFunction; } else if (!instance.render) { if (compile \u0026amp;\u0026amp; !Component.render) { const template = (__COMPAT__ \u0026amp;\u0026amp; instance.vnode.props \u0026amp;\u0026amp; instance.vnode.props[\u0026#39;inline-template\u0026#39;]) || Component.template; if (template) { const { isCustomElement, compilerOptions } = instance.appContext.config; const { delimiters, compilerOptions: componentCompilerOptions } = Component; const finalCompilerOptions: CompilerOptions = extend( extend( { isCustomElement, delimiters }, compilerOptions ), componentCompilerOptions ); if (__COMPAT__) { finalCompilerOptions.compatConfig = Object.create(globalCompatConfig); if (Component.compatConfig) { extend(finalCompilerOptions.compatConfig, Component.compatConfig); } } // 通过编译器，拿到 render Component.render = compile(template, finalCompilerOptions); } } instance.render = (Component.render || NOOP) as InternalRenderFunction; if (instance.render._rc) { instance.withProxy = new Proxy( instance.ctx, RuntimeCompiledPublicInstanceProxyHandlers ); } } if (__FEATURE_OPTIONS_API__ \u0026amp;\u0026amp; !(__COMPAT__ \u0026amp;\u0026amp; skipOptions)) { setCurrentInstance(instance); pauseTracking(); applyOptions(instance); resetTracking(); unsetCurrentInstance(); } } export function createSetupContext( instance: ComponentInternalInstance ): SetupContext { const expose: SetupContext[\u0026#39;expose\u0026#39;] = exposed =\u0026gt; { instance.exposed = exposed || {}; }; return { attrs: instance.attrs, slots: instance.slots, emit: instance.emit, expose }; } // 返回了 AsyncComponentWrapper，一个包装组件 export function defineAsyncComponent\u0026lt; T extends Component = { new (): ComponentPublicInstance } \u0026gt;(source: AsyncComponentLoader\u0026lt;T\u0026gt; | AsyncComponentOptions\u0026lt;T\u0026gt;): T { if (isFunction(source)) { source = { loader: source }; } const { loader, loadingComponent, errorComponent, delay = 200, timeout, suspensible = true, onError: userOnError } = source; let pendingRequest: Promise\u0026lt;ConcreteComponent\u0026gt; | null = null; let resolvedComp: ConcreteComponent | undefined; let retries = 0; const retry = () =\u0026gt; { retries++; pendingRequest = null; return load(); }; // load 函数，调用 loader 获取组件内容 const load = (): Promise\u0026lt;ConcreteComponent\u0026gt; =\u0026gt; { let thisRequest: Promise\u0026lt;ConcreteComponent\u0026gt;; return ( pendingRequest || (thisRequest = pendingRequest = loader() // 调用传入的 loader 加载远程组件 .catch(err =\u0026gt; { err = err instanceof Error ? err : new Error(String(err)); if (userOnError) { return new Promise((resolve, reject) =\u0026gt; { const userRetry = () =\u0026gt; resolve(retry()); // 触发重试 const userFail = () =\u0026gt; reject(err); userOnError(err, userRetry, userFail, retries + 1); }); } else { throw err; } }) .then((comp: any) =\u0026gt; { // 组件加载成功后，赋值给 resolvedComp if (thisRequest !== pendingRequest \u0026amp;\u0026amp; pendingRequest) { return pendingRequest; } if ( comp \u0026amp;\u0026amp; (comp.__esModule || comp[Symbol.toStringTag] === \u0026#39;Module\u0026#39;) ) { comp = comp.default; } resolvedComp = comp; return comp; })) ); }; return defineComponent({ name: \u0026#39;AsyncComponentWrapper\u0026#39;, __asyncLoader: load, get __asyncResolved() { return resolvedComp; }, setup() { const instance = currentInstance!; if (resolvedComp) { return () =\u0026gt; createInnerComp(resolvedComp!, instance); } const onError = (err: Error) =\u0026gt; { pendingRequest = null; handleError( err, instance, ErrorCodes.ASYNC_COMPONENT_LOADER, !errorComponent ); }; if ( (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; suspensible \u0026amp;\u0026amp; instance.suspense) || (__NODE_JS__ \u0026amp;\u0026amp; isInSSRComponentSetup) ) { return load() .then(comp =\u0026gt; { return () =\u0026gt; createInnerComp(comp, instance); }) .catch(err =\u0026gt; { onError(err); return () =\u0026gt; errorComponent ? createVNode(errorComponent as ConcreteComponent, { error: err }) : null; }); } const loaded = ref(false); // 异步是否加载成功 const error = ref(); // 错误信息 const delayed = ref(!!delay); if (delay) { setTimeout(() =\u0026gt; { delayed.value = false; }, delay); } if (timeout != null) { setTimeout(() =\u0026gt; { if (!loaded.value \u0026amp;\u0026amp; !error.value) { // 超时后，渲染失败 const err = new Error( `Async component timed out after ${timeout}ms.` ); onError(err); error.value = err; } }, timeout); } load() .then(() =\u0026gt; { // 组件加载成功，更改 loaded.value loaded.value = true; if (instance.parent \u0026amp;\u0026amp; isKeepAlive(instance.parent.vnode)) { queueJob(instance.parent.update); } }) .catch(err =\u0026gt; { onError(err); error.value = err; }); return () =\u0026gt; { if (loaded.value \u0026amp;\u0026amp; resolvedComp) { // 加载完成并加载成功，渲染 resolvedComp return createInnerComp(resolvedComp, instance); } else if (error.value \u0026amp;\u0026amp; errorComponent) { // 加载失败，渲染 errorComponent return createVNode(errorComponent as ConcreteComponent, { error: error.value }); } else if (loadingComponent \u0026amp;\u0026amp; !delayed.value) { // 加载中，渲染 loadingComponent return createVNode(loadingComponent as ConcreteComponent); } }; } }) as any; } keep-alive 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 // 获取组件 name function getComponentName(opts: ?VNodeComponentOptions): ?string { return opts \u0026amp;\u0026amp; (opts.Ctor.options.name || opts.tag); } // name 是否匹配 pattern function matches(pattern, name) { if (Array.isArray(pattern)) { return pattern.indexOf(name) \u0026gt; -1; } else if (typeof pattern === \u0026#39;string\u0026#39;) { return pattern.split(\u0026#39;,\u0026#39;).indexOf(name) \u0026gt; -1; } else if (isRegExp(pattern)) { return pattern.test(name); } return false; } type CacheEntry = { componentInstance: Component; name: ?string; tag: ?string; }; type CacheEntryMap = { [key: string]: ?CacheEntry }; // 修剪缓存 function pruneCache(keepAliveInstance: any, filter: Function) { const { cache, keys, _vnode } = keepAliveInstance; for (const key in cache) { const entry = cache[key]; if (entry) { const { name } = entry; if (name \u0026amp;\u0026amp; !filter(name)) { pruneCacheEntry(cache, key, keys, _vnode); } } } } // 被修剪的组件，会被组件卸载，在 cache 中也会被置为 null function pruneCacheEntry( cache: CacheEntryMap, key: string, keys: Array\u0026lt;string\u0026gt;, current?: VNode ) { const entry = cache[key]; if (entry \u0026amp;\u0026amp; (!current || entry.tag !== current.tag)) { entry.componentInstance.$destroy(); } cache[key] = null; remove(keys, key); } const patternTypes: Array\u0026lt;Function\u0026gt; = [String, RegExp, Array]; // \u0026lt;keep-alive :include=\u0026#34;xxx\u0026#34; :exclude=\u0026#34;yyy\u0026#34; :max=\u0026#34;zzz\u0026#34;\u0026gt; export default { name: \u0026#39;keep-alive\u0026#39;, abstract: true, // 抽象组件（在组件实例建立父子关系的时候会被忽略） props: { include: patternTypes, exclude: patternTypes, max: [String, Number] }, methods: { // 仅在 render 执行过后才执行（mounted/updated） cacheVNode() { const { cache, keys, vnodeToCache, keyToCache } = this; if (vnodeToCache) { const { tag, componentInstance, componentOptions } = vnodeToCache; // 将 vnode 中的名称、tag、实例缓存起来 cache[keyToCache] = { name: getComponentName(componentOptions), tag, componentInstance }; // key 也要保存一份 keys.push(keyToCache); // 清理老旧的缓存 if (this.max \u0026amp;\u0026amp; keys.length \u0026gt; parseInt(this.max)) { pruneCacheEntry(cache, keys[0], keys, this._vnode); } // 指向需要被缓存的 vnode this.vnodeToCache = null; } } }, created() { // 创建缓存 this.cache = Object.create(null); this.keys = []; }, destroyed() { // 卸载的时候，清空缓存 for (const key in this.cache) { /** * 找到要删除的组件实例并调用 destory 钩子 * 从缓存中删除 key 对应的缓存 * 从 keys 中删除 key */ pruneCacheEntry(this.cache, key, this.keys); } }, mounted() { this.cacheVNode(); // 监听黑白名单 this.$watch(\u0026#39;include\u0026#39;, val =\u0026gt; { pruneCache(this, name =\u0026gt; matches(val, name)); }); this.$watch(\u0026#39;exclude\u0026#39;, val =\u0026gt; { pruneCache(this, name =\u0026gt; !matches(val, name)); }); }, updated() { this.cacheVNode(); }, render() { const slot = this.$slots.default; /** * 处理默认插槽的第一个子组件 * 所以常和 component 和 router-view 一起使用 */ const vnode: VNode = getFirstComponentChild(slot); const componentOptions = vnode \u0026amp;\u0026amp; vnode.componentOptions; if (componentOptions) { // 获取 VNode 对应的组件名称 const name: ?string = getComponentName(componentOptions); const { include, exclude } = this; // 组件名称不在白名单（include）内或者在黑名单（exclude）内 if ( (include \u0026amp;\u0026amp; (!name || !matches(include, name))) || (exclude \u0026amp;\u0026amp; name \u0026amp;\u0026amp; matches(exclude, name)) ) { return vnode; // 直接返回 } const { cache, keys } = this; // 想办法拼凑一个独一无二的 key const key = vnode.key == null ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : \u0026#39;\u0026#39;) : vnode.key; /** * 如果命中缓存，VNode 的组件实例从缓存里取，并调整 key 的顺序（放在最后一个） * 调整 key 的原因是，keys[0] 对应的 key 一定是很久没用的缓存对应的 key */ if (cache[key]) { vnode.componentInstance = cache[key].componentInstance; remove(keys, key); keys.push(key); } else { // 没有缓存的话，设置缓存 this.vnodeToCache = vnode; this.keyToCache = key; } /** * 对于 KeepAlive 标识的组件，被缓存组件初次渲染时会走正常流程（因为 VNode.componentInstance 为空） * 当组件切换，命中缓存时；被缓存组件实例存在，会直接返回；不会执行 created、mounted 等钩子 * 而是执行 activated，对应的也不会执行 destory，而是会执行 deactivate 钩子 */ vnode.data.keepAlive = true; } // 通过插槽渲染组件 return vnode || (slot \u0026amp;\u0026amp; slot[0]); } }; export function getFirstComponentChild( children?: Array\u0026lt;VNode\u0026gt; ): VNode | undefined { if (isArray(children)) { for (let i = 0; i \u0026lt; children.length; i++) { const c = children[i]; if (isDef(c) \u0026amp;\u0026amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) { return c; } } } } export function isAsyncPlaceholder(node: VNode): boolean { // @ts-expect-error not really boolean type return node.isComment \u0026amp;\u0026amp; node.asyncFactory; } keep-alive 3.x 实现 keep-alive 的关键 API 是 _KeepAlive；其缓存原则是“如果经常被访问，则能够快速命中；而不常被访问，则在不满足条件的情况下被释放”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 type Cache = Map\u0026lt;CacheKey, VNode\u0026gt;; // 缓存结构 type Keys = Set\u0026lt;CacheKey\u0026gt;; // 保存缓存 key 值 const KeepAliveImpl = { name: `KeepAlive`, // 用于渲染器内部特殊处理的标记 __isKeepAlive: true, inheritRef: true, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(props: KeepAliveProps, { slots }: SetupContext) { const instance = getCurrentInstance()!; // 获取当前 KeepAlive 组件实例 const parentSuspense = instance.suspense; const keys: Keys = new Set(); const cache: Cache = new Map(); // 缓存容器 let current: VNode | null = null; /** * KeepAlive 通过在其内部传递 ctx 与实例化的渲染器通信 * KeepAlive 实例公开 activate/deactivate 的实现 * 这么做的目的就是避免在 renderer 直接引入 KeepAlive * 实现 tree-shaking */ const sharedContext = instance.ctx as KeepAliveContext; const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext; const storageContainer = createElement(\u0026#39;div\u0026#39;); // 创建“隐藏容器” // KeepAlive 组件实例上，会被添加两个内部函数 activate \u0026amp; deactivate sharedContext.activate = (vnode, container, anchor, isSVG, optimized) =\u0026gt; { const instance = vnode.component!; // 获取组件实例 move(vnode, container, anchor, MoveType.ENTER, parentSuspense); patch( instance.vnode, vnode, container, anchor, instance, parentSuspense, isSVG, optimized ); queuePostRenderEffect(() =\u0026gt; { instance.isDeactivated = false; if (instance.a) { invokeArrayFns(instance.a); } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeMounted; if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode); } }, parentSuspense); }; sharedContext.deactivate = (vnode: VNode) =\u0026gt; { const instance = vnode.component!; // 仅仅移动到 storageContainer，没有卸载 move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense); queuePostRenderEffect(() =\u0026gt; { if (instance.da) { invokeArrayFns(instance.da); } const vnodeHook = vnode.props \u0026amp;\u0026amp; vnode.props.onVnodeUnmounted; if (vnodeHook) { invokeVNodeHook(vnodeHook, instance.parent, vnode); } instance.isDeactivated = true; }, parentSuspense); }; function unmount(vnode: VNode) { resetShapeFlag(vnode); _unmount(vnode, instance, parentSuspense); } // 修剪缓存，可以传入一个过滤函数 function pruneCache(filter?: (name: string) =\u0026gt; boolean) { cache.forEach((vnode, key) =\u0026gt; { const name = getComponentName(vnode.type as ConcreteComponent); if (name \u0026amp;\u0026amp; (!filter || !filter(name))) { pruneCacheEntry(key); } }); } function pruneCacheEntry(key: CacheKey) { const cached = cache.get(key) as VNode; if (!current || cached.type !== current.type) { unmount(cached); } else if (current) { // 当前已激活的实例不再 kept-alive resetShapeFlag(current); } cache.delete(key); keys.delete(key); } // prop 变化，对缓存进行修剪 watch( () =\u0026gt; [props.include, props.exclude], ([include, exclude]) =\u0026gt; { // 根据 include｜exclude 进行修剪 include \u0026amp;\u0026amp; pruneCache(name =\u0026gt; matches(include, name)); exclude \u0026amp;\u0026amp; pruneCache(name =\u0026gt; !matches(exclude, name)); }, { flush: \u0026#39;post\u0026#39;, deep: true } ); let pendingCacheKey: CacheKey | null = null; const cacheSubtree = () =\u0026gt; { if (pendingCacheKey != null) { cache.set(pendingCacheKey, getInnerChild(instance.subTree)); } }; // 渲染/更新完成之后，缓存子树 onMounted(cacheSubtree); onUpdated(cacheSubtree); onBeforeUnmount(() =\u0026gt; { cache.forEach(cached =\u0026gt; { const { subTree, suspense } = instance; const vnode = getInnerChild(subTree); if (cached.type === vnode.type) { resetShapeFlag(vnode); // 触发 deactivated 钩子 const da = vnode.component!.da; da \u0026amp;\u0026amp; queuePostRenderEffect(da, suspense); return; } unmount(cached); }); }); // KeepAlive 的渲染函数 return () =\u0026gt; { pendingCacheKey = null; if (!slots.default) { return null; } // 通过默认插槽，拿到 KeepAlive 包裹的组件 const children = slots.default(); // KeepAlive 是抽象组件，它本身不渲染成实体节点，而是渲染它的第一个子节点 const rawVNode = children[0]; if (children.length \u0026gt; 1) { console.warn(\u0026#39;KeepAlive 应该只包含一个子组件\u0026#39;); current = null; return children; } else if ( !isVNode(rawVNode) || (!(rawVNode.shapeFlag \u0026amp; ShapeFlags.STATEFUL_COMPONENT) \u0026amp;\u0026amp; !(rawVNode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE)) ) { // 如果不是 vnode｜不是状态组件｜不是 SUSPENSE，直接渲染 current = null; return rawVNode; } let vnode = getInnerChild(rawVNode); const comp = vnode.type as ConcreteComponent; const name = getComponentName(comp); // 缓存控制 const { include, exclude, max } = props; if ( (include \u0026amp;\u0026amp; (!name || !matches(include, name))) || (exclude \u0026amp;\u0026amp; name \u0026amp;\u0026amp; matches(exclude, name)) ) { // 直接返回 current = vnode; return rawVNode; } const key = vnode.key == null ? comp : vnode.key; // 获取缓存的 vnode const cachedVNode = cache.get(key); // 如果重复使用 VNode，则克隆它；因为我们将对其进行修改 if (vnode.el) { vnode = cloneVNode(vnode); if (rawVNode.shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { rawVNode.ssContent = vnode; } } pendingCacheKey = key; if (cachedVNode) { // 缓存存在，使用缓存的内容 vnode.el = cachedVNode.el; vnode.component = cachedVNode.component; if (vnode.transition) { setTransitionHooks(vnode, vnode.transition!); } // 避免 VNode 节点作为新节点被挂载，并打上 KEPT_ALIVE vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE; // 删除再添加，是为更新缓存位置（当缓存满的时候，会卸载最老的组件） keys.delete(key); keys.add(key); } else { // 缓存不存在 keys.add(key); // 舍弃最早的缓存 if (max \u0026amp;\u0026amp; keys.size \u0026gt; parseInt(max as string, 10)) { pruneCacheEntry(keys.values().next().value); } } // 避免 VNode 被卸载，给组件打上 COMPONENT_SHOULD_KEEP_ALIVE vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE; current = vnode; return rawVNode; }; } }; export const KeepAlive = KeepAliveImpl as any as { __isKeepAlive: true; new (): { $props: VNodeProps \u0026amp; KeepAliveProps; }; }; nextTick 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 Vue.prototype.$nextTick = function (fn) { return nextTick(fn, this); }; Vue.nextTick = nextTick; const callbacks = []; let pending = false; let timerFunc; // 执行 callbacks 里所有的回调函数 function flushCallbacks() { pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i \u0026lt; copies.length; i++) { copies[i](); } } if (typeof Promise !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; isNative(Promise)) { // 使用 Promise const p = Promise.resolve(); timerFunc = () =\u0026gt; { p.then(flushCallbacks); if (isIOS) setTimeout(noop); }; isUsingMicroTask = true; } else if ( !isIE \u0026amp;\u0026amp; typeof MutationObserver !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; (isNative(MutationObserver) || MutationObserver.toString() === \u0026#39;[object MutationObserverConstructor]\u0026#39;) ) { // 使用 MutationObserver let counter = 1; const observer = new MutationObserver(flushCallbacks); const textNode = document.createTextNode(String(counter)); observer.observe(textNode, { characterData: true }); timerFunc = () =\u0026gt; { counter = (counter + 1) % 2; textNode.data = String(counter); }; isUsingMicroTask = true; } else if (typeof setImmediate !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; isNative(setImmediate)) { // 使用 setImmediate timerFunc = () =\u0026gt; { setImmediate(flushCallbacks); }; } else { // 使用 setTimeout timerFunc = () =\u0026gt; { setTimeout(flushCallbacks, 0); }; } /** * $nextTick 有三种调用方式： * 1. $nextTick(cb) * 2. $nextTick.then(cb) * 3. async $nextTick() */ export function nextTick(cb, ctx) { let _resolve; callbacks.push(() =\u0026gt; { if (cb) { try { cb.call(ctx); } catch (e) { handleError(e, ctx, \u0026#39;nextTick\u0026#39;); } } else if (_resolve) { // _resolve 将 ctx 传递给 then 里边的 cb _resolve(ctx); } }); if (!pending) { pending = true; /** * timerFunc 有四种运行 flushCallbacks 的方式： * 1. Promise（微任务） * 2. MutationObserver（微任务） * 3. setImmediate（宏任务） * 4. setTimeout（宏任务） */ timerFunc(); } if (!cb \u0026amp;\u0026amp; typeof Promise !== \u0026#39;undefined\u0026#39;) { return new Promise(resolve =\u0026gt; { // 当调用 _resolve 时，会走 then(cb) _resolve = resolve; }); } } nextTick 3.x 1 2 3 4 5 6 7 8 9 10 const resolvedPromise: Promise\u0026lt;any\u0026gt; = Promise.resolve(); let currentFlushPromise: Promise\u0026lt;void\u0026gt; | null = null; // nextTick 的实现就是 Promise export function nextTick( this: ComponentPublicInstance | void, fn?: () =\u0026gt; void ): Promise\u0026lt;void\u0026gt; { const p = currentFlushPromise || resolvedPromise; return fn ? p.then(this ? fn.bind(this) : fn) : p; } vnode 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 /** * 调用场景： * 1. createComponent 中 new VNode(...) * 2. _createElement 中 * 如果是注册的组件，调用 createComponent * 如果是 HTML 元素，new VNode(...) * 如果是未知元素，new VNode(...) * 3. 创建空节点，emptyNode = new VNode(\u0026#39;\u0026#39;, {}, []) * 4. 创建文本节点，new VNode(undefined, undefined, undefined, String(val)) * 5. cloneVNode，源码就在下面 */ export default class VNode { constructor( tag, data, children, text, elm, context, componentOptions, asyncFactory ) { this.tag = tag; // `vue-component-${Ctor.cid}${name ? `-${name}` : \u0026#39;\u0026#39;}`, this.data = data; this.children = children; this.text = text; this.elm = elm; this.ns = undefined; // 命名空间 this.context = context; // 渲染组件的作用域 this.fnContext = undefined; // 函数节点的上下文 this.fnOptions = undefined; // SSR 缓存相关 this.fnScopeId = undefined; // 函数作用域 ID 支持 this.key = data \u0026amp;\u0026amp; data.key; this.componentOptions = componentOptions; this.componentInstance = undefined; // 组件实例 /** * vm.$options.parent：子组件渲染执行 vm.__patch__ 时当前活跃的组件实例，也就是子组件实例的父组件实例 * vm.$parent：组件实例的第一个“非抽象”的父组件实例 */ this.parent = undefined; // 组件占位 vnode，不会出现在 DOM this.raw = false; // 是否包含原生 HTML？ this.isStatic = false; // 是否是静态提升节点 this.isRootInsert = true; // 进入 transition 检查所必需的 this.isComment = false; // 是否是空的注释占位符？ this.isCloned = false; // 是否是克隆节点？ this.isOnce = false; // 是否是 v-once 节点？ this.asyncFactory = asyncFactory; // 异步组件工厂函数 this.asyncMeta = undefined; this.isAsyncPlaceholder = false; } } // 创建空白 VNode export const createEmptyVNode = (text = \u0026#39;\u0026#39;) =\u0026gt; { const node = new VNode(); node.text = text; node.isComment = true; return node; }; // 创建文本 VNode export function createTextVNode(val) { return new VNode(undefined, undefined, undefined, String(val)); } /** * 适用于静态节点和插槽节点，因为他们可能被多个 render 重用 * 当 DOM 操作依赖它们的 elm 引用时，克隆它们可以避免错误 */ export function cloneVNode(vnode) { const cloned = new VNode( vnode.tag, vnode.data, vnode.children \u0026amp;\u0026amp; vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory ); cloned.ns = vnode.ns; cloned.isStatic = vnode.isStatic; cloned.key = vnode.key; cloned.isComment = vnode.isComment; cloned.fnContext = vnode.fnContext; cloned.fnOptions = vnode.fnOptions; cloned.fnScopeId = vnode.fnScopeId; cloned.asyncMeta = vnode.asyncMeta; cloned.isCloned = true; return cloned; } vnode 3.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 function _createVNode( type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT, props: (Data \u0026amp; VNodeProps) | null = null, children: unknown = null, patchFlag: number = 0, // 补丁标志 dynamicProps: string[] | null = null, isBlockNode = false ): VNode { if (!type || type === NULL_DYNAMIC_COMPONENT) { type = Comment; } if (isVNode(type)) { const cloned = cloneVNode(type, props, true /* mergeRef: true */); if (children) { normalizeChildren(cloned, children); } return cloned; } if (isClassComponent(type)) { type = type.__vccOpts; } if (__COMPAT__) { type = convertLegacyComponent(type, currentRenderingInstance); } if (props) { props = guardReactiveProps(props)!; let { class: klass, style } = props; if (klass \u0026amp;\u0026amp; !isString(klass)) { // 处理 template 中的 class 的特殊写法（字符串、数组、对象） props.class = normalizeClass(klass); } if (isObject(style)) { if (isProxy(style) \u0026amp;\u0026amp; !isArray(style)) { style = extend({}, style); } props.style = normalizeStyle(style); } } const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : __FEATURE_SUSPENSE__ \u0026amp;\u0026amp; isSuspense(type) ? ShapeFlags.SUSPENSE : isTeleport(type) ? ShapeFlags.TELEPORT : isObject(type) ? ShapeFlags.STATEFUL_COMPONENT : isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT : 0; return createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true ); } function createBaseVNode( type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT, props: (Data \u0026amp; VNodeProps) | null = null, children: unknown = null, patchFlag = 0, dynamicProps: string[] | null = null, shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT, isBlockNode = false, needFullChildrenNormalization = false ) { const vnode = { __v_isVNode: true, __v_skip: true, /*** * 如果是普通标签，值为字符串 * 如果是组件实例，值为组件配置（对象） * 如果是注释节点，使用 Symbol 代指 * 如果是代码片段，值为 Fragment，使用 Symbol 代指 */ type, props, // 属性值 key: props \u0026amp;\u0026amp; normalizeKey(props), ref: props \u0026amp;\u0026amp; normalizeRef(props), scopeId: currentScopeId, slotScopeIds: null, children, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag, // 只要存在，就认为有当前节点为动态节点 patchFlag, dynamicProps, /** * 用来保存动态子节点，带有该属性的虚拟节点成为 Block * 一个 Block 不仅能够收集自身的动态子节点 * 而且能够收集多有的动态“子代”节点，以及子 Block 节点 * 当渲染器在更新一个 Block 时，会忽略 vnode 的 children，只更新动态节点 * 所有模版的根节点都会是一个 Block 节点 * 任何带有 v-for|v-if|v-else-if|v-else 等结构性指令的节点都可以作为 Block 节点 * 因为收集 dynamicChildren 的过程中，是忽略节点层级的，所以需要使用结构化指令的节点也作为 Block 节点 * 并且，这样可以使 dynamicChildren 结构稳定（数量和顺序一致） * 如果更新前后 dynamicChildren 结构不稳定，就没办法 patchBlockChildren * \u0026lt;template\u0026gt; * \u0026lt;div alt=\u0026#39;这个 div 是一个 Block\u0026#39;\u0026gt; * \u0026lt;p alt=\u0026#34;这个 p 不是一个 Block，因为它不是根节点\u0026#34;\u0026gt;{{ bar }}\u0026lt;/p\u0026gt; * \u0026lt;/div\u0026gt; * \u0026lt;h1 alt=\u0026#39;这个 h1 是一个 Block\u0026#39;\u0026gt; * \u0026lt;span :id=\u0026#34;dynamicId\u0026#34; alt=\u0026#34;这个 span 不是一个 Block，因为它不是根节点\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; * \u0026lt;/h1\u0026gt; * \u0026lt;/template\u0026gt; * 在 render 递归调用 createVNode 时，会为维护一个 dynamicChildrenStack 的栈 * 当调用 openBlock 时，dynamicChildrenStack 会被 push 进一个 currentDynamicChildren 的数组 * 遇到 patchFlag 不为 undefined 的 vnode 会被 push 进这个 currentDynamicChildren 数组 * 当调用 closeBlock 时，currentDynamicChildren 会从 dynamicChildrenStack 弹出 * 此时，当前 Block 的子代动态节点都被收集在 currentDynamicChildren 中 */ dynamicChildren: null, appContext: null } as VNode; if (needFullChildrenNormalization) { normalizeChildren(vnode, children); if (__FEATURE_SUSPENSE__ \u0026amp;\u0026amp; shapeFlag \u0026amp; ShapeFlags.SUSPENSE) { (type as typeof SuspenseImpl).normalize(vnode); } } else if (children) { vnode.shapeFlag |= isString(children) ? ShapeFlags.TEXT_CHILDREN : ShapeFlags.ARRAY_CHILDREN; } if ( isBlockTreeEnabled \u0026gt; 0 \u0026amp;\u0026amp; !isBlockNode \u0026amp;\u0026amp; currentBlock \u0026amp;\u0026amp; (vnode.patchFlag \u0026gt; 0 || shapeFlag \u0026amp; ShapeFlags.COMPONENT) \u0026amp;\u0026amp; vnode.patchFlag !== PatchFlags.HYDRATE_EVENTS ) { currentBlock.push(vnode); } if (__COMPAT__) { convertLegacyVModelProps(vnode); convertLegacyRefInFor(vnode); defineLegacyVNodeProperties(vnode); } return vnode; } function shouldSetAsProp( el: Element, key: string, value: unknown, isSVG: boolean ) { if (isSVG) { // 除了 innerHTML，其他属性都作为 HTMLAttr 处理 if (key === \u0026#39;innerHTML\u0026#39;) { return true; } // 如果是事件绑定，作为 DOMProp 处理 if (key in el \u0026amp;\u0026amp; nativeOnRE.test(key) \u0026amp;\u0026amp; isFunction(value)) { return true; } return false; } /** * pellcheck 和 draggable 是枚举属性，但是它们对应的 DOM 属性实际上是布尔值 * 这会导致将其设置为字符串 false，导致其被强制为 true * contentEditable 没有这个问题 */ if (key === \u0026#39;spellcheck\u0026#39; || key === \u0026#39;draggable\u0026#39;) { return false; } // form 属性是只读属性，应当作 HTMLAttr 处理 if (key === \u0026#39;form\u0026#39;) { return false; } // \u0026lt;input list\u0026gt; list 属性应当作 HTMLAttr 处理 if (key === \u0026#39;list\u0026#39; \u0026amp;\u0026amp; el.tagName === \u0026#39;INPUT\u0026#39;) { return false; } // \u0026lt;textarea type\u0026gt; type 属性应当作 HTMLAttr 处理 if (key === \u0026#39;type\u0026#39; \u0026amp;\u0026amp; el.tagName === \u0026#39;TEXTAREA\u0026#39;) { return false; } // onclick=\u0026#39;handleClick\u0026#39; onxxx 属性应当作 HTMLAttr 处理，如果 value 为字符串的话 if (nativeOnRE.test(key) \u0026amp;\u0026amp; isString(value)) { return false; } return key in el; } export const enum PatchFlags { TEXT = 1, // 表示具有动态 textContent 的元素 CLASS = 1 \u0026lt;\u0026lt; 1, // 表示具有动态 class 的元素 /** * 表示具有动态 style 的元素 * style=\u0026#34;color: red\u0026#34; * :style=\u0026#34;{ color: \u0026#39;red\u0026#39; }\u0026#34; * 都会被提升为 * const style = { color: \u0026#39;red\u0026#39; } * render() { return e(\u0026#39;div\u0026#39;, { style }) } */ STYLE = 1 \u0026lt;\u0026lt; 2, /** * 表示具有动态 props（非 class/style）的元素 * 也可表示具有动态 props（包含 class/style）的组件 */ PROPS = 1 \u0026lt;\u0026lt; 3, /** * 表示具有动态 keys 的元素 * 需要做完整 diff */ FULL_PROPS = 1 \u0026lt;\u0026lt; 4, HYDRATE_EVENTS = 1 \u0026lt;\u0026lt; 5, // 表示绑定了事件监听的元素 STABLE_FRAGMENT = 1 \u0026lt;\u0026lt; 6, // 表示 children 不变的 Frangment KEYED_FRAGMENT = 1 \u0026lt;\u0026lt; 7, // 表示 children 有 key 的 Frangment UNKEYED_FRAGMENT = 1 \u0026lt;\u0026lt; 8, // 表示 children 没有 key 的 Frangment NEED_PATCH = 1 \u0026lt;\u0026lt; 9, // 需要对非 props 之外的属性（ref/directive）进行 patch 的元素 /** * 表示具有动态插槽的组件 * 例如：动态插槽名/引用 v-for 迭代值的插槽 */ DYNAMIC_SLOTS = 1 \u0026lt;\u0026lt; 10, DEV_ROOT_FRAGMENT = 1 \u0026lt;\u0026lt; 11, /*************特殊 FLAGS：值为负数；不会参与位运算；只参与 patchFlag === FLAG 比较***************/ /** * 表示一个静态提升的 vnode，永远不会更新/变化 * 静态提升：将静态 vnode 保存在渲染函数之外 * 函数内部，只保留对静态节点的引用 * 减少更新时，创建 vnode 的开销 */ HOISTED = -1, BAIL = -2 // 退出 diff 算法优化 } export const PatchFlagNames = { [PatchFlags.TEXT]: `TEXT`, [PatchFlags.CLASS]: `CLASS`, [PatchFlags.STYLE]: `STYLE`, [PatchFlags.PROPS]: `PROPS`, [PatchFlags.FULL_PROPS]: `FULL_PROPS`, [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`, [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`, [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`, [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`, [PatchFlags.NEED_PATCH]: `NEED_PATCH`, [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`, [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`, [PatchFlags.HOISTED]: `HOISTED`, [PatchFlags.BAIL]: `BAIL` }; watch 2.x 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // 在 initState 的过程中会判断组件 options 有没有 watch 要处理 export function initState(vm: Component) { // ... if (opts.watch \u0026amp;\u0026amp; opts.watch !== nativeWatch) { initWatch(vm, opts.watch); } } function initWatch(vm: Component, watch: Object) { for (const key in watch) { const handler = watch[key]; // 如果对一个 getter 注册了多个 watcher，这些 watcher 的 handler 会拼成一个数组 if (Array.isArray(handler)) { for (let i = 0; i \u0026lt; handler.length; i++) { // 循环创建 watcher createWatcher(vm, key, handler[i]); } } else { createWatcher(vm, key, handler); } } } function createWatcher( vm: Component, expOrFn: string | Function, handler: any, options?: Object ) { // {..., handler, ...} if (isPlainObject(handler)) { options = handler; handler = handler.handler; } // 去 methods 找 handler if (typeof handler === \u0026#39;string\u0026#39;) { handler = vm[handler]; } // 调用 this.$watch return vm.$watch(expOrFn, handler, options); } export function stateMixin(Vue: Class\u0026lt;Component\u0026gt;) { // ... Vue.prototype.$watch = function ( expOrFn: string | Function, cb: any, options?: Object ): Function { const vm: Component = this; if (isPlainObject(cb)) { return createWatcher(vm, expOrFn, cb, options); } options = options || {}; options.user = true; // this.$watch 这种调用方式的 user 均为 true const watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) { // 通过 watcher.value 立即执行一次求值 const info = `callback for immediate watcher \u0026#34;${watcher.expression}\u0026#34;`; pushTarget(); invokeWithErrorHandling(cb, vm, [watcher.value], vm, info); popTarget(); } return function unwatchFn() { watcher.teardown(); }; }; } watch 3.x watch 需要侦听特定的数据源，并在单独的回调函数中（惰性）执行副作用；watchEffect 立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 // watchers 在未定义初始值时触发的初始值 const INITIAL_WATCHER_VALUE = {}; export interface WatchOptionsBase { flush?: \u0026#39;pre\u0026#39; | \u0026#39;post\u0026#39; | \u0026#39;sync\u0026#39;; onTrack?: ReactiveEffectOptions[\u0026#39;onTrack\u0026#39;]; onTrigger?: ReactiveEffectOptions[\u0026#39;onTrigger\u0026#39;]; } /** * watchEffect((onInvalidate) =\u0026gt; {...}, {...}) * Vue 会自动追踪 fn 依赖 instance 中的数据 * 也就是自动生成 getter（需要先运行一次） */ export function watchEffect(fn, options) { return doWatch(fn, null, options); } /** * watch(() =\u0026gt; state.count, (count, prevCount, onInvalidate) =\u0026gt; {...}, {...}) * 1. 懒执行副作用； * 2. 更具体地说明什么状态应该触发侦听器重新运行； * 3. 访问侦听状态变化前后的值。 */ export function watch(fn, cb, options) { return doWatch(fn, cb, options); } // vm.$watch 背后也是 doWatch export function instanceWatch( this: ComponentInternalInstance, source: string | Function, cb: WatchCallback, options?: WatchOptions ): WatchStopHandle { const publicThis = this.proxy as any; const getter = isString(source) ? () =\u0026gt; publicThis[source] : source.bind(publicThis); return doWatch(getter, cb.bind(publicThis), options, this); } // 最终实现 function doWatch( source, cb, { immediate, deep, flush, onTrack, onTrigger } = {}, instance = currentInstance ) { if (!cb) { // 这也说明 watchEffect 默认就是 immediate\u0026amp;deep if (immediate !== undefined) { warn(\u0026#39;只有 watch(source, callback, options?) 才支持 immediate\u0026#39;); } if (deep !== undefined) { warn(\u0026#39;只有 watch(source, callback, options?) 才支持 deep\u0026#39;); } } let getter: () =\u0026gt; any; let forceTrigger = false; // 根据不同的 source，生成不同的 getter，用于触发 Proxy 的拦截器，进行依赖收集 if (isRef(source)) { // 如果 source 为 ref，自动展开 getter = () =\u0026gt; source.value; forceTrigger = !!source._shallow; } else if (isReactive(source)) { // 如果 source 为 reactive，自动 deep getter = () =\u0026gt; source; deep = true; } else if (isArray(source)) { // 如果 source 为数组，对每一项做处理并返回数组 getter = () =\u0026gt; source.map(s =\u0026gt; { if (isRef(s)) { return s.value; } else if (isReactive(s)) { return traverse(s); // 递归读取 } else if (isFunction(s)) { return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER); } }); } else if (isFunction(source)) { if (cb) { // 属于 watch getter = () =\u0026gt; callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER); } else { // 属于 watchEffect getter = () =\u0026gt; { if (instance \u0026amp;\u0026amp; instance.isUnmounted) { return; // 实例都卸载了，直接返回 } if (cleanup) { cleanup(); // 运行 source 之前，运行清理函数 } // 运行 source 收集依赖；先清理再收集 return callWithErrorHandling( source, instance, ErrorCodes.WATCH_CALLBACK, [onInvalidate] ); }; } } else { getter = NOOP; } if (cb \u0026amp;\u0026amp; deep) { /** * watchEffect：深度遍历 getter 运行时访问的值 * 重新生成 watchEffectGetter */ const baseGetter = getter; getter = () =\u0026gt; traverse(baseGetter()); } let cleanup: () =\u0026gt; void; /** * 清理副作用的回调会在该副作用下一次执行前被调用 * onInvalidate 接收的函数，被指向了 cleanup */ const onInvalidate: InvalidateCbRegistrator = (fn: () =\u0026gt; void) =\u0026gt; { cleanup = runner.options.onStop = () =\u0026gt; { callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP); }; }; // 初始值是：[] 或 {} let oldValue = isArray(source) ? [] : INITIAL_WATCHER_VALUE; /** * 被 scheduler 控制执行的 job * 对于 watch 来说，先运行 runner 获得 newValue，判断和 oldValue 是否相等，在调用 cb * 对于 watchEffect，直接运行 runner 即可（拿不到 oldValue） */ const job: SchedulerJob = () =\u0026gt; { if (!runner.active) { return; } if (cb) { // job 在运行期间，重新求最新值并执行回调 const newValue = runner(); if (deep || forceTrigger || hasChanged(newValue, oldValue)) { // 执行 cb 之前，先清除上一次运行 cb 的“副作用” if (cleanup) { // cleanup = runner.options.onStop = () =\u0026gt; {...} cleanup(); } /** * cb 的三个入参： * watch(id, async (newId, oldId, onCleanup) =\u0026gt; { * const { response, cancel } = doAsyncWork(newId) * onCleanup(cancel) * data.value = await response * } */ callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [ newValue, oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue, onInvalidate ]); oldValue = newValue; // 新值变旧值 } } else { runner(); // watchEffect 要执行的副作用 } }; // 如果存在 cb，将 allowRecurse 置为 true job.allowRecurse = !!cb; /** * watch 的 flush 选项： * 1. pre，默认值，回调应该在渲染前被调用，允许回调在模板运行前更新了其他值，回调缓存在 preFlushCbs * 2. post，将回调推迟到渲染之后的，回调缓存在 postFlushCbs * 3. sync，一旦值发生了变化，回调将被同步调用 * 除了 computed，render/watch 的 effect 的初次运行发生在初次依赖收集阶段 * 一旦 effect 与响应式数据建立了联系之后，effect 的运行，都是由 scheduler 进行调用的（开启任务队列） * watch 正是利用了 scheduler 来运行 callback 回调 */ let scheduler: ReactiveEffectOptions[\u0026#39;scheduler\u0026#39;]; if (flush === \u0026#39;sync\u0026#39;) { scheduler = job; } else if (flush === \u0026#39;post\u0026#39;) { // flush:post，默认值，job 会在微任务队列里 render 之后调用 scheduler = () =\u0026gt; queuePostRenderEffect(job, instance \u0026amp;\u0026amp; instance.suspense); } else { // flush:pre，job 会在 render 之前调用 scheduler = () =\u0026gt; { if (!instance || instance.isMounted) { // 如果实例不存在或者实例已经挂载 queuePreFlushCb(job); } else { // 实例存在但是还没挂载，同步执行就好 job(); } }; } // 经过上边的流程，确定了 getter、scheduler const runner = effect(getter, { // 创建一个懒执行的 effect lazy: true, onTrack, onTrigger, scheduler }); if (instance) { (instance.effects || (instance.effects = [])).push(runner); } if (cb) { if (immediate) { job(); // 创建 watch 的时候，立即执行一次 } else { oldValue = runner(); } } else if (flush === \u0026#39;post\u0026#39;) { queuePostRenderEffect(runner, instance \u0026amp;\u0026amp; instance.suspense); } else { runner(); } // watch/watchEffect 都会返回一个“停止监听函数” return () =\u0026gt; { stop(runner); if (instance) { remove(instance.effects!, runner); } }; } ","date":"2021-10-24T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/vue-2.x/3.x-%E6%AF%94%E8%BE%83%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81/","title":"Vue 2.x/3.x 比较（基于源码）"},{"content":"调用 ReactDOM.render 发生了什么？ 确定应用渲染方式； 创建 fiberRoot 和 rootFiberNode，并将两者用指针指向彼此； 向 rootFiberNode 绑定自身的更新队列； 清空 container 里的内容； 向 container 绑定原生事件； 将 render 的第三个参数的 this 指向应用实例并调用； 初始化完成后，创建 update，并将 fiber 对应的组件作为 payload； 将 update 与 fiberNode 相关联，fiberNode 对应的 update 组成循环链表； 调用 scheduleUpdateOnFiber 开始渲染工作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 // ReactDOM 的渲染模式 export type RootTag = 0 | 1 | 2; export const LegacyRoot = 0; // ReactDOM.createLegacyRoot export const BlockingRoot = 1; // ReactDOM.createBlockingRoot export const ConcurrentRoot = 2; // ReactDOM.createRoot // ReactDOM.render export function render( element: React$Element\u0026lt;any\u0026gt;, container: Container, callback: ?Function ) { // 向 DOMContainer 里渲染子树 return legacyRenderSubtreeIntoContainer( null, element, container, false, callback ); } function legacyRenderSubtreeIntoContainer( parentComponent: ?React$Component\u0026lt;any, any\u0026gt;, // null children: ReactNodeList, // ReactElement container: Container, // DOMContainer forceHydrate: boolean, // false callback: ?Function // () =\u0026gt; {} ) { let root: RootType = container._reactRootContainer; let fiberRoot; if (!root) { /** * 初始化阶段准备工作： * 0. legacyCreateRootFromDOMContainer 最终会调用 createRootImpl * 1. container._reactRootContainer._internalRoot = createRootImpl(container, 0, undefined) * 2. createRootImpl(container, 0, undefined) 返回了 fiberRoot * 3. fiberRoot 一个应用只有一个，其 current 属性指向了 rootFiberNode * 4. fiberRoot.current 指向了 currentFiber 树 * 5. fiberRoot.finishedWork 指向了 workInProgress 树 * 6. 清空 container */ root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate ); fiberRoot = root._internalRoot; if (typeof callback === \u0026#39;function\u0026#39;) { const originalCallback = callback; callback = function () { /** * getPublicRootInstance 会通过 fiberRoot 访问 rootFiberNode * 如果 rootFiberNode 没有子节点，返回 null * 否则返回 rootFiberNode 子节点的 stateNode * 总之就是返回一个非 rootFiberNode 的组件实例 */ const instance = getPublicRootInstance(fiberRoot); // 调用了 callback 就说明应用初始化完成了 originalCallback.call(instance); }; } // 初始化完成之后，就准备进行应用渲染了 unbatchedUpdates(() =\u0026gt; { updateContainer(children, fiberRoot, parentComponent, callback); }); } else { // 后续更新需要重新渲染，会走这里 fiberRoot = root._internalRoot; if (typeof callback === \u0026#39;function\u0026#39;) { const originalCallback = callback; callback = function () { const instance = getPublicRootInstance(fiberRoot); originalCallback.call(instance); }; } updateContainer(children, fiberRoot, parentComponent, callback); } return getPublicRootInstance(fiberRoot); } function createRootImpl( container: Container, tag: RootTag, // 用来表示是否开启“并发模式” options: void | RootOptions ) { const root = createFiberRoot( container, tag, (hydrate = false), (hydrationCallbacks = null) ); container.__reactContainer$ = root.current; /** * 获取应用挂载的 DOM 的 nodeType： * Node.ELEMENT_NODE 1 元素节点 * Node.TEXT_NODE 3 文字节点 * Node.CDATA_SECTION_NODE 4 \u0026lt;!CDATA[[ … ]]\u0026gt; * Node.PROCESSING_INSTRUCTION_NODE 7 \u0026lt;?xml-stylesheet ... ?\u0026gt; * Node.COMMENT_NODE 8 注释节点 * Node.DOCUMENT_NODE 9 Document * Node.DOCUMENT_TYPE_NODE 10 \u0026lt;!DOCTYPE html\u0026gt; * Node.DOCUMENT_FRAGMENT_NODE 11 DocumentFragment */ const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container; rootContainerElement._reactListening = true; /** * allNativeEvents 是包含了离散（触发）事件、阻塞（用户交互）事件、连续（不能被打断）事件、表单事件的 Set * nonDelegatedEvents 是放置的是“非委托”事件的 Set (类似于一个白名单) * listenToNativeEvent(事件名称，是否在捕获阶段触发，应用根容器，目标元素) * 1. 将 selectionchange 绑定到 document * 2. 将支持“冒泡”的事件委托到 rootContainerElement * 3. 其他的事件除了 scroll 外，绑定到“目标元素” * 4. 从 EventTarget.__reactEvents 找到所有绑定的 listener（保存在 Set 里） * 5. listener 里如果没有 `${domEventName}__${capture ? \u0026#39;capture\u0026#39; : \u0026#39;bubble\u0026#39;}` 会执行 addTrappedEventListener * addTrappedEventListener(EventTarget, DOMEventName, EventSystemFlags, isCapture, isDeferred) * 1. createEventListenerWrapperWithPriority 会根据事件类型，使用不同的优先级函数包裹 listener（事件优先级） * a. dispatchDiscreteEvent 离散事件 * b. dispatchUserBlockingUpdate 用户阻塞事件 * c. dispatchEvent 连续事件 * 2. 对于“touchstart”、“touchmove”、“wheel”三个事件，isPassive=true（preventDefault 失效） * 3. 根据 isCapture 和 isPassive 将事件绑定分发给了四个函数 addEvent[Bubble/Capture]Listener[WithPassiveFlag] * 4. 调用原生 API：addEventListener 和 removeEventListener 进行事件的绑定和移除 * 总的来说，React 会根据事件 isCapture、isPassive 和优先级，将事件绑定到合适的 target 上 */ allNativeEvents.forEach(domEventName =\u0026gt; { if (!nonDelegatedEvents.has(domEventName)) { // 可以使用“事件委托” listenToNativeEvent( domEventName, false, // “事件委托”需要“事件冒泡”的支持 rootContainerElement, null ); } listenToNativeEvent(domEventName, true, rootContainerElement, null); }); return root; } // 创建 fiberRoot 和 rootFiberNode，并将两者关联起来 export function createFiberRoot( containerInfo: any, tag: RootTag, hydrate: boolean ): FiberRoot { const root: FiberRoot = { tag, containerInfo, // DOMContainer pendingChildren: null, current: null, pingCache: null, finishedWork: null, timeoutHandle: noTimeout, // -1 context: null, pendingContext: null, hydrate, callbackNode: null, callbackPriority: NoLanePriority, // 0 eventTimes: createLaneMap(NoLanes), // [] expirationTimes: createLaneMap(NoTimestamp), pendingLanes: NoLanes, suspendedLanes: NoLanes, pingedLanes: NoLanes, expiredLanes: NoLanes, mutableReadLanes: NoLanes, finishedLanes: NoLanes, entangledLanes: NoLanes, entanglements: createLaneMap(NoLanes) }; const uninitializedFiber: FiberNode = { tag: 3, key: null, elementType: null, type: null, stateNode: null, return: null, child: null, sibling: null, index: 0, ref: null, pendingProps: null, memoizedProps: null, updateQueue: null, memoizedState: null, dependencies: null, /** * mode 有六种模式： * 0b00000 NoMode 普通模式 * 0b00001 StrictMode 严格模式 * 0b00010 BlockingMode 块模式 * 0b00100 ConcurrentMode 并发模式 * 0b01000 ProfileMode 性能测试模式 * 0b10000 DebugTracingMode Debug 模式 */ mode: NoMode | ConcurrentMode | BlockingMode | StrictMode, flags: NoFlags, nextEffect: null, firstEffect: null, lastEffect: null, lanes: NoLanes, childLanes: NoLanes, alternate: null }; // fiberRoot 的 current 指向 rootFiberNode root.current = uninitializedFiber; // rootFiberNode 的 stateNode 指向 fiberRoot uninitializedFiber.stateNode = root; // rootFiberNode 的更新队列（链表） uninitializedFiber.updateQueue = { baseState: uninitializedFiber.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null }; return root; } // 创建更新，安排渲染 export function updateContainer( element: ReactNodeList, container: OpaqueRoot, parentComponent: ?React$Component\u0026lt;any, any\u0026gt;, callback: ?Function ): Lane { const current = container.current; // rootFiberNode const eventTime = requestEventTime(); // 当前时间 const lane = requestUpdateLane(current); // 优先级 const context = getContextForSubtree(parentComponent); // emptyContextObject = {} if (container.context === null) { container.context = context; // 走这儿 } else { container.pendingContext = context; } // 创建了一个 update 对象 const update = { callback: null, eventTime, lane, next: null, payload: { element }, tag: UpdateState // 0 }; callback = callback === undefined ? null : callback; if (callback !== null) { update.callback = callback; } /** * enqueueUpdate 做了一下事情：将 fiber 节点和 update 关联起来 * const updateQueue = fiber.updateQueue; * const sharedQueue = fiber.updateQueue.shared; * const pending = sharedQueue.pending; * update.next = update; // 每个 fiberNode 的所有 update 组成了一个链表，只不过现在链表里只有一个元素 * sharedQueue.pending = update; */ enqueueUpdate(current, update); // 执行渲染工作 scheduleUpdateOnFiber(current, lane, eventTime); return lane; } /** * 从 17 开始，e.persist() 将不再生效，因为 SyntheticEvent 不再放入事件池中 * React 将不再向 document 附加事件处理器 * 而会将事件处理器附加到渲染 React 树的根 DOM 容器中 * 原因：如果页面上有多个 React 版本，会破坏 e.stopPropagation() */ export function listenToNativeEvent( domEventName: DOMEventName, isCapturePhaseListener: boolean, rootContainerElement: EventTarget, targetElement: Element | null, eventSystemFlags?: EventSystemFlags = 0 ): void { let target = rootContainerElement; if ( domEventName === \u0026#39;selectionchange\u0026#39; \u0026amp;\u0026amp; rootContainerElement.nodeType !== DOCUMENT_NODE ) { /** * selectionchange 事件需要直接绑定在 document 上 * ownerDocument 返回节点的顶层的 document 对象 */ target = rootContainerElement.ownerDocument; } /** * 如果事件可以被委托（或者在捕获阶段触发） * 那就注册在 rootContainerElement 上 * 否则，就绑定在 targetElement 上 */ if ( targetElement !== null \u0026amp;\u0026amp; !isCapturePhaseListener \u0026amp;\u0026amp; nonDelegatedEvents.has(domEventName) ) { /** * 所有不能代理的事件（多媒体事件、cancel、close、invalid、load、scroll、toggle） * 都绑定在 targetElement 上 */ if (domEventName !== \u0026#39;scroll\u0026#39;) { // 除了 scroll 事件，因为任何元素都可以滚动 return; } eventSystemFlags |= IS_NON_DELEGATED; target = targetElement; } // target[\u0026#39;__reactEvents$\u0026#39; + Math.random().toString(36).slice(2)] = new Set() const listenerSet = getEventListenerSet(target); // `${domEventName}__${isCapturePhaseListener ? \u0026#39;capture\u0026#39; : \u0026#39;bubble\u0026#39;}` const listenerSetKey = getListenerSetKey( domEventName, isCapturePhaseListener ); if (!listenerSet.has(listenerSetKey)) { if (isCapturePhaseListener) { eventSystemFlags |= IS_CAPTURE_PHASE; } addTrappedEventListener( target, domEventName, eventSystemFlags, isCapturePhaseListener ); listenerSet.add(listenerSetKey); } } 调用 scheduleUpdateOnFiber 发生了什么？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 export function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) { // 检查是否有嵌套更新，如果嵌套超过 50 层，终止调度 checkForNestedUpdates(); // 标记从 fiberNode 到 fiberRoot 的更新时间 const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) { return null; } // 标记 fiberRoot 有挂起的更新 markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) { /** * 接收到在渲染过程中的树的更新，标记 fiberRoot 上存在交叉更新工作 * 除非 deferRenderPhaseUpdateToNextBatch 标志关闭并且这是 render 阶段更新 * 在这种情况下，出于向后兼容的原因，我们不会将 render 阶段更新视为交错处理 */ workInProgressRootUpdatedLanes = workInProgressRootUpdatedLanes | lane; } /** * 获取 currentPriorityLevel 的值和 Scheduler_*Priority 做对比；获取当前优先级 * ImmediatePriority || * UserBlockingPriority|| * NormalPriority || * LowPriority || * IdlePriority */ const priorityLevel = getCurrentPriorityLevel(); if (lane === SyncLane) { // 初次渲染是同步的 if ( // 检查是否在 unbatchedUpdates 内部 (executionContext \u0026amp; LegacyUnbatchedContext) !== NoContext \u0026amp;\u0026amp; // 检查是否还没有渲染 (executionContext \u0026amp; (RenderContext | CommitContext)) === NoContext ) { // 在 fiberRoot 上注册挂起的交互，以避免丢失跟踪的交互数据 schedulePendingInteractions(root, lane); /** * 一种边缘情况：在 batchedUpdates 内部 * ReactDOM.render 渲染的 root 节点挂载应该是同步的 * 而布局更新应该推迟到批处理结束 */ performSyncWorkOnRoot(root); } else { ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) { /** * 现在就开始同步工作，除非我们已经开始或在批处理中 * 这有意在 scheduleUpdateOnFiber 中（而不是 scheduleCallbackForFiber 中） * 以保留 schedule 回调而不立即执行它的能力 * 我们只对用户发起的更新执行此操作，以保留遗留模式的历史行为 */ resetRenderTimer(); flushSyncCallbackQueue(); } } } else { // 计划离散更新，但仅在它不是同步的情况下 if ( (executionContext \u0026amp; DiscreteEventContext) !== NoContext \u0026amp;\u0026amp; // 只有用户阻塞或更高优先级的更新才被视为离散的 (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) { // 跟踪每个 root 的最低优先级的离散更新，以便在必要时及早运行他们 if (rootsWithPendingDiscreteUpdates === null) { rootsWithPendingDiscreteUpdates = new Set([root]); } else { rootsWithPendingDiscreteUpdates.add(root); } } // 如果回调是同步的，则在之后安排其他更新 ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); } /** * 我们假设它和被更新的 root 相同，因为单个 root 的应用很常见 * 如果不是同一个 root，那也不是啥难事 * 我们只是倾向于把更多的东西 batch 在一起 */ mostRecentlyUpdatedRoot = root; } scheduler（任务调度，高优先级的任务先进行 render） 对任务按照优先级进行调度（高优先级的任务打断低优先级的任务的执行），所有任务保存在最小堆中（方便取出优先级最高的任务）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 /** * 根据 priorityLevel 新建 task，task 的内容为 callback * task 根据优先级的不同保存在不同的队列里（taskQueue、timerQueue） * taskQueue 里存放着需要执行的任务 * timerQueue 里存放着等待执行的任务 */ function unstable_scheduleCallback(priorityLevel, callback, options) { var currentTime = getCurrentTime(); var startTime; // 根据 option 计算任务最早开始时间（任务不能早于这个时间运行） if (typeof options === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; options !== null) { var delay = options.delay; if (typeof delay === \u0026#39;number\u0026#39; \u0026amp;\u0026amp; delay \u0026gt; 0) { startTime = currentTime + delay; } else { startTime = currentTime; } } else { startTime = currentTime; } // 根据优先级计算任务最多可以延后多久 var timeout; switch (priorityLevel) { case ImmediatePriority: timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1 break; case UserBlockingPriority: timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250 break; case IdlePriority: // V8 在 32 位系统上能展示的最大整数 Math.pow(2, 30) - 1 timeout = IDLE_PRIORITY_TIMEOUT; break; case LowPriority: timeout = LOW_PRIORITY_TIMEOUT; // 10000 break; case NormalPriority: default: // 5000 timeout = NORMAL_PRIORITY_TIMEOUT; break; } // 任务过期时间（晚于这个时间必须立即执行） var expirationTime = startTime + timeout; // 新建任务 var newTask = { id: taskIdCounter++, // 任务 ID callback, // 任务内容 priorityLevel, // 优先级 startTime, // 最早执行时间 expirationTime, // 最晚执行时间（过期时间） sortIndex: -1 // 值越小，优先级越高 }; if (startTime \u0026gt; currentTime) { // 任务不需要现在就执行 newTask.sortIndex = startTime; // 不需要立即执行的任务保存在 timerQueue push(timerQueue, newTask); if (peek(taskQueue) === null \u0026amp;\u0026amp; newTask === peek(timerQueue)) { // taskQueue 队列里的任务执行完了，并且新建的任务排在 timerQueue 的第一个，说明此时此刻没有任务需要执行 if (isHostTimeoutScheduled) { cancelHostTimeout(); } else { isHostTimeoutScheduled = true; } // 安排一个 timeout requestHostTimeout(handleTimeout, startTime - currentTime); } } else { newTask.sortIndex = expirationTime; // 将要处理的任务放在 taskQueue push(taskQueue, newTask); // 接着干活，如果没时间了，等到一次 yield if (!isHostCallbackScheduled \u0026amp;\u0026amp; !isPerformingWork) { isHostCallbackScheduled = true; requestHostCallback(flushWork); } } return newTask; } reconciler（render 阶段，构建 workInProgress，收集要更新的节点） 通过组件返回的 React 元素和 current 树构建 workInProgress 树，找出前后变化并打上标记，将所有变化收集到 effectList 链表里（链表对异步友好的；链表在循环时不用每次都进入递归函数，重新生成执行上下文，变量对象，激活对象，性能比递归好）。\ncurrent 与 workInProgress：\n在 React 应用中最多会同时存在两棵 fiber 树，current 树对应当前渲染完成的视图；当状态更新后会在内存中构建 workInProgress 树； 当 fiberRoot 的 current 指向 workInProgress 时，workInProgress 树也就成为了 current 树； 每次状态更新都会在内存中构建 workInProgress 树，应用通过 current 与 workInProgress 的替换完成更新； current 树的节点与 workInProgress 树的节点通过自身 alternate 指向对方。 应用 mount（首次渲染）时：\n首次执行 ReactDOM.render 会创建 fiberRoot（应用根节点）和 rootFiberNode（组件树根节点）； fiberRoot 有两个指针，current 指向 current 树，finishedWork 指向 workInProgress 树； 多次调用 ReactDOM.render 渲染不同的组件树，他们会拥有不同的 rootFiber；但是 fiberRoot 只有一个； 首次渲染时页面没有内容，current 树为空；接下来会在内存中创建 fiberNode，构成 workInProgress； workInProgress 会在 commit 阶段同步更新到视图中。 应用 update（状态变化）时：\n应用重新进入 render 阶段，调用组件 render 方法，重新构建 workInProgress； 构建 workInProgress 的过程中会和 current 进行比较，并在需要改变的节点打上标记； 根据收集到的标记，更新视图。 renderer（commit 阶段，更新页面） 遍历 effectList，更新视图（ReactArt、ReactDOM、ReactNative）；这个阶段是同步的，不能被打断：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 /** * 此时，有两棵树和一个链表： * current 表示当前屏幕显示内容 * workInProgress 表示即将更新到屏幕上的内容 * effectList 表示本次更新要执行的副作用（DOM 更新、生命周期调用、setState 回调、hooks 调用...） */ function commitRoot(root) { const renderPriorityLevel = getCurrentPriorityLevel(); runWithPriority( ImmediateSchedulerPriority, commitRootImpl.bind(null, root, renderPriorityLevel) ); return null; } function commitRootImpl(root, renderPriorityLevel) { do { /** * 触发 useEffect 回调与其他同步任务 * 由于这些任务可能触发新的渲染 * 所以，这里要一直遍历执行直到没有任务 */ flushPassiveEffects(); } while (rootWithPendingPassiveEffects !== null); /** * root 指 fiberRoot * root.finishedWork 指当前应用的 rootFiber */ const finishedWork = root.finishedWork; const lanes = root.finishedLanes; if (finishedWork === null) { return null; } root.finishedWork = null; root.finishedLanes = NoLanes; root.callbackNode = null; // 重置 scheduler 绑定的回调函数 let remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // 清除已完成的离散型 updates，例如：用户鼠标点击触发的更新 if (rootsWithPendingDiscreteUpdates !== null) { if ( !hasDiscreteLanes(remainingLanes) \u0026amp;\u0026amp; rootsWithPendingDiscreteUpdates.has(root) ) { rootsWithPendingDiscreteUpdates.delete(root); } } // 重置全局变量 if (root === workInProgressRoot) { workInProgressRoot = null; workInProgress = null; workInProgressRootRenderLanes = NoLanes; } else { // ... } /** * 将 effectList 赋值给 firstEffect * 由于每个 fiber 的 effectList 只包含他的子孙节点 * 所以根节点如果有 effectTag 则不会被包含进来 * 所以这里将有 effectTag 的根节点插入到 effectList 尾部 * 这样才能保证有 effect 的 fiber 都在 effectList 中 */ let firstEffect; if (finishedWork.flags \u0026gt; PerformedWork) { /** * 一个 fiber 的 effectList 只包括它的子节点，而不是其本身 * 因此，如果 root 有一个 effect，我们需要把它加到列表的最后 */ if (finishedWork.lastEffect !== null) { finishedWork.lastEffect.nextEffect = finishedWork; firstEffect = finishedWork.firstEffect; } else { firstEffect = finishedWork; } } else { // 根节点没有 effectTag firstEffect = finishedWork.firstEffect; } if (firstEffect !== null) { let previousLanePriority; if (decoupleUpdatePriorityFromScheduler) { previousLanePriority = getCurrentUpdateLanePriority(); setCurrentUpdateLanePriority(SyncLanePriority); } const prevExecutionContext = executionContext; executionContext |= CommitContext; const prevInteractions = pushInteractions(root); // 在调用生命周期之前置为 null ReactCurrentOwner.current = null; /** * commit 阶段被分成了几个阶段，每个阶段都会遍历一遍 effectList * 所有的 MutationEffects 都会在所有的 LayoutEffects 前执行 * 第一个阶段『before mutation』： * 在修改之前，读取主树的 state * 调用 getSnapshotBeforeUpdate * 调度 useEffect */ focusedInstanceHandle = prepareForCommit(root.containerInfo); shouldFireAfterActiveInstanceBlur = false; nextEffect = firstEffect; // 从 firstEffect 开始遍历 effectList（第一遍） do { try { commitBeforeMutationEffects(); } catch (error) { captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; } } while (nextEffect !== null); // 不再需要追踪激活的 fiber 实例 focusedInstanceHandle = null; /** * 第二个阶段『mutation』： * 更新 DOM * 调用 componentWillUnmount * 调用 useLayoutEffect 销毁回调 */ nextEffect = firstEffect; // 从 firstEffect 开始遍历 effectList（第二遍） do { try { commitMutationEffects(root, renderPriorityLevel); } catch (error) { captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; } } while (nextEffect !== null); if (shouldFireAfterActiveInstanceBlur) { afterActiveInstanceBlur(); } resetAfterCommit(root.containerInfo); /** * commit 之后，WIP 树就成为了 current 树 * 这是为了在调用 componentWillUnmount 期间，还可以获取卸载前组件的信息 * 也是为了在下一个阶段之前，在 componentDidMount/Update 调用期间，WIP 是 current 树 */ root.current = finishedWork; // fiberRoot 的 current 指针指向了 finishedWork 所指向的 WIP /** * 第三个阶段『layout』： * 调用主树修改之后需要执行的副作用 setState 第二个参数 * 类组件的生命周期也会在这里调用 componentDidMount/Update */ nextEffect = firstEffect; // 从 firstEffect 开始遍历 effectList（第三遍） do { try { commitLayoutEffects(root, lanes); } catch (error) { captureCommitPhaseError(nextEffect, error); nextEffect = nextEffect.nextEffect; } } while (nextEffect !== null); nextEffect = null; /** * 告诉 Scheduler 在当前帧停一下，让浏览器渲染一下页面 * yieldInterval = 5，每帧只给 5ms 让 React 执行 render 阶段的工作 */ requestPaint(); // needsPaint=true if (enableSchedulerTracing) { popInteractions(prevInteractions); } executionContext = prevExecutionContext; if (decoupleUpdatePriorityFromScheduler \u0026amp;\u0026amp; previousLanePriority != null) { setCurrentUpdateLanePriority(previousLanePriority); } } else { // effectList 中没有 effect，直接将 WIP 树切换为 current 树 root.current = finishedWork; } const rootDidHavePassiveEffects = rootDoesHavePassiveEffects; // useEffect 相关 if (rootDoesHavePassiveEffects) { // 当前 commit 有副作用，在完成 layout 之前，不要调用副作用回调函数 rootDoesHavePassiveEffects = false; rootWithPendingPassiveEffects = root; pendingPassiveEffectsLanes = lanes; pendingPassiveEffectsRenderPriority = renderPriorityLevel; } else { /** * 处理完 effect 了，清除 nextEffect * 如果有副作用，会在 flushPassiveEffects 里消耗掉 */ nextEffect = firstEffect; while (nextEffect !== null) { const nextNextEffect = nextEffect.nextEffect; nextEffect.nextEffect = null; if (nextEffect.flags \u0026amp; Deletion) { detachFiberAfterEffects(nextEffect); } nextEffect = nextNextEffect; } } remainingLanes = root.pendingLanes; // 检查 root 上有没有漏掉的 work if (remainingLanes !== NoLanes) { if (enableSchedulerTracing) { if (spawnedWorkDuringRender !== null) { const expirationTimes = spawnedWorkDuringRender; spawnedWorkDuringRender = null; for (let i = 0; i \u0026lt; expirationTimes.length; i++) { scheduleInteractions( root, expirationTimes[i], root.memoizedInteractions ); } } schedulePendingInteractions(root, remainingLanes); } } else { // 没任务的话，清除失败的错误边界？？？ legacyErrorBoundariesThatAlreadyFailed = null; } // 检测无限循环的同步任务，判断是否进入了死循环 if (remainingLanes === SyncLane) { if (root === rootWithNestedUpdates) { nestedUpdateCount++; } else { nestedUpdateCount = 0; rootWithNestedUpdates = root; } } else { nestedUpdateCount = 0; } // 在离开 commitRoot 函数前调用，触发一次新的调度，确保任何附加的任务被调度 ensureRootIsScheduled(root, now()); // 处理未捕获的错误 if (hasUncaughtError) { hasUncaughtError = false; const error = firstUncaughtError; firstUncaughtError = null; throw error; } if ((executionContext \u0026amp; LegacyUnbatchedContext) !== NoContext) { return null; } /** * 执行同步任务，这样同步任务不需要等到下次事件循环再执行 * 比如，在 componentDidMount 中执行 setState 创建的更新会在这里被同步执行 */ flushSyncCallbackQueue(); return null; } beforeMutation（渲染前）：遍历 effectList 并调用 commitBeforeMutationEffects；调用 getSnapshotBeforeUpdate；调度 useEffect： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 /** * 1. 调用 getSnapshotBeforeUpdate * 2. 调用 useEffect 的销毁函数 * 3. 异步调度 useEffect */ function commitBeforeMutationEffects() { while (nextEffect !== null) { const current = nextEffect.alternate; if (!shouldFireAfterActiveInstanceBlur \u0026amp;\u0026amp; focusedInstanceHandle !== null) { // 处理 DOM 节点渲染/删除后的 autoFocus、blur 逻辑 } const flags = nextEffect.flags; if ((flags \u0026amp; Snapshot) !== NoFlags) { // commitBeforeMutationEffectOnFiber 会调用 getSnapshotBeforeUpdate // snapshot = instance.getSnapshotBeforeUpdate( // finishedWork.elementType === finishedWork.type // ? prevProps // : resolveDefaultProps(finishedWork.type, prevProps), // prevState // ); // 将返回值存储在内部属性上，方便 componentDidUpdate 获取 // instance.__reactInternalSnapshotBeforeUpdate = snapshot; commitBeforeMutationEffectOnFiber(current, nextEffect); } // 异步调度 useEffect if ((flags \u0026amp; Passive) !== NoFlags) { if (!rootDoesHavePassiveEffects) { rootDoesHavePassiveEffects = true; scheduleCallback(NormalSchedulerPriority, () =\u0026gt; { // 从全局变量 rootWithPendingPassiveEffects 获取 effectList，触发 effect 回调函数 flushPassiveEffects(); return null; }); } } nextEffect = nextEffect.nextEffect; } } function flushPassiveEffectsImpl() { if (rootWithPendingPassiveEffects === null) { return false; } const root = rootWithPendingPassiveEffects; const lanes = pendingPassiveEffectsLanes; rootWithPendingPassiveEffects = null; pendingPassiveEffectsLanes = NoLanes; const prevExecutionContext = executionContext; executionContext |= CommitContext; const prevInteractions = pushInteractions(root); /** * 任何副作用函数被运行之前，应该先运行清理函数 * 否则兄弟组件的副作用可能会相互影响 * 例如，一个组件的销毁函数可能无意间覆盖（另一个组件的副作用设置的）ref 的值 */ const unmountEffects = pendingPassiveHookEffectsUnmount; pendingPassiveHookEffectsUnmount = []; for (let i = 0; i \u0026lt; unmountEffects.length; i += 2) { const effect = unmountEffects[i]; const fiber = unmountEffects[i + 1]; const destroy = effect.destroy; effect.destroy = undefined; if (typeof destroy === \u0026#39;function\u0026#39;) { try { destroy(); } catch (error) { captureCommitPhaseError(fiber, error); } } } const mountEffects = pendingPassiveHookEffectsMount; pendingPassiveHookEffectsMount = []; for (let i = 0; i \u0026lt; mountEffects.length; i += 2) { const effect = mountEffects[i]; const fiber = mountEffects[i + 1]; try { const create = effect.create; effect.destroy = create(); } catch (error) { captureCommitPhaseError(fiber, error); } } let effect = root.current.firstEffect; while (effect !== null) { const nextNextEffect = effect.nextEffect; // 移出指针，方便垃圾回收 effect.nextEffect = null; if (effect.flags \u0026amp; Deletion) { detachFiberAfterEffects(effect); } effect = nextNextEffect; } if (enableSchedulerTracing) { popInteractions(prevInteractions); finishPendingInteractions(root, lanes); } executionContext = prevExecutionContext; flushSyncCallbackQueue(); nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; return true; } mutation（渲染中）：使用 Host API 对视图进行更新； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 /** * 1. 调用 commitDetachRef 解绑 ref * 2. 根据 effectTag 处理 DOM * 3. 执行 useLayoutEffect 的销毁函数（commitWork 会调用 commitHookEffectListUnmount） */ function commitMutationEffects(root, renderPriorityLevel) { // 遍历 effectList while (nextEffect !== null) { const flags = nextEffect.flags; if (flags \u0026amp; ContentReset) { commitResetTextContent(nextEffect); } // 更新 ref if (flags \u0026amp; Ref) { const current = nextEffect.alternate; if (current !== null) { commitDetachRef(current); } } // 根据 effectTag 处理 DOM const primaryFlags = flags \u0026amp; (Placement | Update | Deletion | Hydrating); switch (primaryFlags) { // 插入 DOM case Placement: { /** * 获取父级 DOM 节点 * 获取 fiber 的 DOM 兄弟节点（fiber 树和 DOM 树并不是一一对应的） * 调用 parentNode.insertBefore 或 parentNode.appendChild 执行 DOM 插入操作 */ commitPlacement(nextEffect); nextEffect.flags \u0026amp;= ~Placement; break; } // 插入并更新 DOM case PlacementAndUpdate: { commitPlacement(nextEffect); nextEffect.flags \u0026amp;= ~Placement; const current = nextEffect.alternate; commitWork(current, nextEffect); break; } // 更新 DOM case Update: { /** * fiber.tag === FunctionComponent，调用 commitHookEffectListUnmount * 遍历 effectList，执行所有 useLayoutEffect 的销毁函数 * fiber.tag === HostComponent，调用 commitUpdate * 在 updateDOMProperties 中将 render 阶段 completeWork 中为 fiber 赋值的 updateQueue 对应的内容渲染在页面上 */ const current = nextEffect.alternate; commitWork(current, nextEffect); break; } // 删除 DOM case Deletion: { /** * 递归调用 fiber 及其子孙 fiber 中 tag === ClassComponent 的 componentWillUnmount 生命周期钩子，从页面移除 fiber 对应的 DOM * 解绑 ref * 调度 useLayoutEffect 的销毁函数 */ commitDeletion(root, nextEffect, renderPriorityLevel); break; } // ... } nextEffect = nextEffect.nextEffect; } } layout（渲染后）：同步调用 componentDidMount/Update。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 /** * 1. 调用 commitLayoutEffectOnFiber(commitLifeCycles) 执行相应的生命周期函数 * 2. 调用 commitAttachRef 更新 ref * 3. 调用 setState 第二个参数 */ function commitLayoutEffects(root, committedLanes) { while (nextEffect !== null) { const flags = nextEffect.flags; // 调用生命周期钩子和 hook if (flags \u0026amp; (Update | Callback)) { const current = nextEffect.alternate; /** * commitLifeCycles 的同名函数 * current === null ? componentDidMount : componentDidUpdate * 调用 setState 的第二个参数（回调函数） * 调用 useLayoutEffect 的回调函数（上一次的销毁函数是在 mutation 阶段调用） * 调度 useEffect 的回调和销毁函数 * ReactDOM.render 的第三个参数（回调函数） */ commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes); } // 赋值 ref if (flags \u0026amp; Ref) { /** * 如果 ref 是函数形式，调用回调函数 * 如果 ref 是实例形式，赋值 ref.current */ commitAttachRef(nextEffect); } nextEffect = nextEffect.nextEffect; } } function commitLifeCycles( finishedRoot: FiberRoot, current: Fiber | null, finishedWork: Fiber, committedLanes: Lanes ): void { switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: { /** * 在 mutation 阶段，LayoutEffects 已经销毁 * 酱紫是为了防止兄弟组件的 Effects 相互干扰 * 调用 useLayoutEffect */ commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork); // 调度 useEffect schedulePassiveEffects(finishedWork); return; } case ClassComponent: { const instance = finishedWork.stateNode; if (finishedWork.flags \u0026amp; Update) { if (current === null) { // 执行 componentDidMount instance.componentDidMount(); } else { const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps); const prevState = current.memoizedState; // 执行 componentDidUpdate instance.componentDidUpdate( prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate ); } } // 执行 setState 第二个参数 const updateQueue: UpdateQueue | null = finishedWork.updateQueue; if (updateQueue !== null) { commitUpdateQueue(finishedWork, updateQueue, instance); } return; } case HostRoot: { const updateQueue: UpdateQueue | null = finishedWork.updateQueue; if (updateQueue !== null) { let instance = null; if (finishedWork.child !== null) { switch (finishedWork.child.tag) { case HostComponent: instance = getPublicInstance(finishedWork.child.stateNode); break; case ClassComponent: instance = finishedWork.child.stateNode; break; } } commitUpdateQueue(finishedWork, updateQueue, instance); } return; } case HostComponent: { const instance: Instance = finishedWork.stateNode; if (current === null \u0026amp;\u0026amp; finishedWork.flags \u0026amp; Update) { const type = finishedWork.type; const props = finishedWork.memoizedProps; commitMount(instance, type, props, finishedWork); } return; } case SuspenseComponent: { commitSuspenseHydrationCallbacks(finishedRoot, finishedWork); return; } case HostText: case HostPortal: case SuspenseListComponent: case IncompleteClassComponent: case FundamentalComponent: case ScopeComponent: case OffscreenComponent: case LegacyHiddenComponent: return; } } diff diff 发生在 update 阶段（beginWork）；通过 current 树和组件返回的 JSX 对象（VDOM），生成 workInProgress 树；并收集需要更新的 fiber 节点，以寻求更新视图的最优方案；它有以下准则：\n只对同级元素进行 diff；如果一个节点在前后两次更新中跨越了层级，那么不会复用节点； 两个不同类型的元素会产生出不同的树；卸载旧的（及其子树），创建新的（及其子树）； 通过设置 key 属性，来告知渲染哪些子元素在不同的渲染下可以保持不变； 同类型的组件元素，组件实例保持不变； 同类型的元素，保留节点，更新属性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 // 给子节点打上 effectTag 并添加到 sideEffectList function reconcileChildFibers( returnFiber, currentFirstChild, newChild, // JSX 对象 lanes ) { const isUnkeyedTopLevelFragment = typeof newChild === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; newChild !== null \u0026amp;\u0026amp; newChild.type === REACT_FRAGMENT_TYPE \u0026amp;\u0026amp; newChild.key === null; if (isUnkeyedTopLevelFragment) { // 跳过 React.Fragment newChild = newChild.props.children; } const isObject = typeof newChild === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; newChild !== null; // newChild 类型为 object，同级仅有一个节点 if (isObject) { switch (newChild.$$typeof) { case REACT_ELEMENT_TYPE: //... case REACT_PORTAL_TYPE: //... case REACT_LAZY_TYPE: //... } } // newChild 类型为 string、number，同级仅有一个节点 if (typeof newChild === \u0026#39;string\u0026#39; || typeof newChild === \u0026#39;number\u0026#39;) { return placeSingleChild( reconcileSingleTextNode( returnFiber, currentFirstChild, \u0026#39;\u0026#39; + newChild, lanes ) ); } // newChild 类型为 array，同级有多个节点 if (isArray(newChild)) { return reconcileChildrenArray( returnFiber, currentFirstChild, newChild, lanes ); } // newChild 类型为 iterator if (getIteratorFn(newChild)) { return reconcileChildrenIterator( returnFiber, currentFirstChild, newChild, lanes ); } if (isObject) { throwOnInvalidObjectType(returnFiber, newChild); } if (typeof newChild === \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; !isUnkeyedTopLevelFragment) { // ... } // 删除节点 return deleteRemainingChildren(returnFiber, currentFirstChild); } 单节点 diff 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 function reconcileSingleElement( returnFiber, currentFirstChild, element, lanes ) { const key = element.key; let child = currentFirstChild; // 判断是否存在对应的 DOM while (child !== null) { // 判断 key 是否相同 if (child.key === key) { switch (child.tag) { case Fragment: // ... case Block: // ... default: { // type 相同表示可以复用 if (child.elementType === element.type) { deleteRemainingChildren(returnFiber, child.sibling); const existing = useFiber(child, element.props); existing.ref = coerceRef(returnFiber, child, element); existing.return = returnFiber; return existing; } break; } } // key 相同，但是 type 不相同，删除 fiber 以及兄弟节点 deleteRemainingChildren(returnFiber, child); break; } else { // key 不相同，不能复用，删除 deleteChild(returnFiber, child); } // 同级兄弟节点 child = child.sibling; } // 新建 fiber 并返回 if (element.type === REACT_FRAGMENT_TYPE) { const created = createFiberFromFragment( element.props.children, returnFiber.mode, lanes, element.key ); created.return = returnFiber; return created; } else { const created = createFiberFromElement(element, returnFiber.mode, lanes); created.ref = coerceRef(returnFiber, currentFirstChild, element); created.return = returnFiber; return created; } } 多节点 diff：需要处理节点更新、节点新增/减少、节点位置变化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 function reconcileChildrenArray( returnFiber, currentFirstChild, newChildren, lanes ) { /** * 这个算法不能通过从两端搜索来优化，和 newChildren 中每个组件相比较的是 currentFiber * newChildren[0] 与 fiber 比较，newChildren[1] 与 fiber.sibling 比较 */ let resultingFirstChild = null; let previousNewFiber = null; let oldFiber = currentFirstChild; let lastPlacedIndex = 0; let newIdx = 0; let nextOldFiber = null; // 首先遍历 newChildren for (; oldFiber !== null \u0026amp;\u0026amp; newIdx \u0026lt; newChildren.length; newIdx++) { if (oldFiber.index \u0026gt; newIdx) { nextOldFiber = oldFiber; oldFiber = null; } else { nextOldFiber = oldFiber.sibling; } const newFiber = updateSlot( returnFiber, oldFiber, newChildren[newIdx], lanes ); // newChildren 与 oldFiber 同时遍历完了 if (newFiber === null) { if (oldFiber === null) { oldFiber = nextOldFiber; } break; } if (shouldTrackSideEffects) { if (oldFiber \u0026amp;\u0026amp; newFiber.alternate === null) { deleteChild(returnFiber, oldFiber); } } lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; oldFiber = nextOldFiber; } // newChildren 遍历完了，删除剩余的 oldFiber if (newIdx === newChildren.length) { deleteRemainingChildren(returnFiber, oldFiber); return resultingFirstChild; } // oldFiber 遍历完了，插入剩余的 newChildren if (oldFiber === null) { for (; newIdx \u0026lt; newChildren.length; newIdx++) { const newFiber = createChild(returnFiber, newChildren[newIdx], lanes); if (newFiber === null) { continue; } lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } return resultingFirstChild; } // newChildren 与 oldFiber 都没遍历完，将没有处理的 oldFiber 存入 map const existingChildren = mapRemainingChildren(returnFiber, oldFiber); // 遍历剩余的 newChildren，移动节点 for (; newIdx \u0026lt; newChildren.length; newIdx++) { const newFiber = updateFromMap( existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes ); if (newFiber !== null) { if (shouldTrackSideEffects) { if (newFiber.alternate !== null) { existingChildren.delete( newFiber.key === null ? newIdx : newFiber.key ); } } // 最后一个可复用的节点在 oldFiber 中的位置索引 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx); if (previousNewFiber === null) { resultingFirstChild = newFiber; } else { previousNewFiber.sibling = newFiber; } previousNewFiber = newFiber; } } if (shouldTrackSideEffects) { // 没有消耗的已经存在的 children 都删掉 existingChildren.forEach(child =\u0026gt; deleteChild(returnFiber, child)); } return resultingFirstChild; } fiber 没有 fiber 以前，reconciler 采用递归的方式创建虚拟 DOM，这个过程是不能中断的；如果组件树的层级很深，递归会占用线程很多时间，阻塞渲染造成卡顿。为了解决这个问题，React 引入 fiber，重构为了异步的可中断更新：\nfiber 的含义： 递归的数据保存在调用栈中，所以被称为 StackReconciler；基于 fiber 的 Reconciler，被称为 FiberReconciler； 作为静态的数据结构来说，每个 fiber 节点对应一个 React 元素，保存了该组件的类型（函数组件/类组件/原生组件\u0026hellip;）、对应的 DOM 节点等信息； 作为动态的工作单元来说，每个 fiber 节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新\u0026hellip;）。 fiber 的目标： 能够把可中断的任务切片处理； 能够调整优先级，重置并复用任务； 能够在父元素与子元素之间交错处理； 能够在 render 中返回多个元素； 更好地支持错误边界。 fiberNode 的生成：通过 createFiber 工厂函数生成 fiberNode 实例； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 const createFiber = function ( tag: WorkTag, pendingProps: mixed, key: null | string, mode: TypeOfMode ): Fiber { return new FiberNode(tag, pendingProps, key, mode); }; function FiberNode( tag: WorkTag, pendingProps: any, key: null | string, mode: TypeOfMode ) { // 作为静态数据结构的属性 this.elementType = null; // 元素类型，大部分情况同 type，某些情况不同，比如 React.memo(FunctionComponent) this.key = key; // key 属性 this.stateNode = null; // 对应的 DOM、FiberRoot、ComponentInstance；保存了 fiber 相关的局部状态 this.tag = tag; // 对应的组件类型 this.type = null; // 对于函数组件，指函数本身；对于类组件，指 class；对于原生组件，指 DOM 节点的 tagName；用来描述与 fiber 相关的 React 元素 // 用于连接其他 FiberNode 生成『树』形结构 this.child = null; // 指向子级 FiberNode this.index = 0; this.return = null; // 指向父级 FiberNode this.sibling = null; // 指向兄弟 FiberNode // 保存本次更新造成的状态改变相关信息，用来计算 state this.dependencies = null; this.memoizedProps = null; // 上次渲染期间对应的 props this.memoizedState = null; // 经过所有流程处理后的新 state；在处理更新的过程中，对应的是屏幕上展示的状态 this.pendingProps = pendingProps; // 新的 props，需要应用到子组件或者 DOM 元素上 this.updateQueue = null; // 更新队列（保存了 stateUpdates、回调、DOMUpdates），链表结构，用于计算本次的 state // 保存本次更新会造成的 DOM 操作，需要在 commit 阶段应用到视图上 this.deletions = null; this.flags = NoFlags; this.subtreeFlags = NoFlags; // 调度优先级相关 this.childLanes = NoLanes; this.lanes = NoLanes; /** * 双缓存：指向 current/workInProgress 中对应的 fiber 节点 * currentFiber.alternate === workInProgressFiber * workInProgressFiber.alternate === currentFiber */ this.alternate = null; // 双缓存相关 this.mode = mode; this.ref = null; } fiberTree 的生成：通过 performUnitOfWork（分为两部分：“递”和“归”）向 workInProgress 添加 fiber 节点； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 function ensureRootIsScheduled(root: FiberRoot, currentTime: number) { /** * 这个方法用来为 fiberRoot 调度任务；每个 fiberRoot 每次只有一个任务 * 如果一个任务已经被调度，将检查以确保现有任务的优先级与下一个级别的优先级相同 * 此函数在每次更新时调用，并且调用恰好发生在退出任务之前 */ const existingCallbackNode = root.callbackNode; // 检查是否有 lane 处于饥饿状态，如果有就把它标记为过期任务，需要下次更新时执行 markStarvedLanesAsExpired(root, currentTime); // 检测下一个要处理的 lane 和对应的优先级 const nextLanes = getNextLanes( root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes ); // 返回在“getNextLanes”调用期间计算的优先级 const newCallbackPriority = returnNextLanesPriority(); if (nextLanes === NoLanes) { if (existingCallbackNode !== null) { cancelCallback(existingCallbackNode); root.callbackNode = null; root.callbackPriority = NoLanePriority; } return; } // 对现存任务检查，看是否能被复用 if (existingCallbackNode !== null) { const existingCallbackPriority = root.callbackPriority; if (existingCallbackPriority === newCallbackPriority) { // 优先级没改变，可以重复使用 return; } // 不能复用任务 cancelCallback(existingCallbackNode); } // 调度回调 let newCallbackNode; if (newCallbackPriority === SyncLanePriority) { // 特殊情况：同步任务在内部队列里被调度 newCallbackNode = scheduleSyncCallback( performSyncWorkOnRoot.bind(null, root) ); } else if (newCallbackPriority === SyncBatchedLanePriority) { // 批量同步任务 newCallbackNode = scheduleCallback( ImmediateSchedulerPriority, performSyncWorkOnRoot.bind(null, root) ); } else { // 并发调用 const schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority); newCallbackNode = scheduleCallback( schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root) ); } root.callbackPriority = newCallbackPriority; root.callbackNode = newCallbackNode; } // ensureRootIsScheduled 调用 performSyncWorkOnRoot 调用 renderRootSync 调用 workLoopSync function workLoopSync() { // 已经超时了，不检查当前帧是否还有时间，执行任务 while (workInProgress !== null) { performUnitOfWork(workInProgress); } } // ensureRootIsScheduled 调用 performConcurrentWorkOnRoot（递归调用自己）调用 renderRootConcurrent 调用 workLoopConcurrent function workLoopConcurrent() { // 如果当前帧还有时间，就执行任务 while (workInProgress !== null \u0026amp;\u0026amp; !shouldYield()) { performUnitOfWork(workInProgress); } } function performUnitOfWork(unitOfWork: Fiber): void { const current = unitOfWork.alternate; // beginWork 总是返回传入节点的子节点 let next = beginWork(current, unitOfWork, subtreeRenderLanes); unitOfWork.memoizedProps = unitOfWork.pendingProps; if (next === null) { // 子节点遍历完了，开始遍历当前子树的兄弟节点并回溯到父节点 completeUnitOfWork(unitOfWork); } else { workInProgress = next; } ReactCurrentOwner.current = null; } function completeUnitOfWork(unitOfWork: Fiber): void { // 完成当前任务，并移至兄弟节点；如果没有兄弟节点，回到父级节点 let completedWork = unitOfWork; do { const current = completedWork.alternate; const returnFiber = completedWork.return; // 检测任务是否完成 if ((completedWork.flags \u0026amp; Incomplete) === NoFlags) { let next; if ((completedWork.mode \u0026amp; ProfileMode) === NoMode) { next = completeWork(current, completedWork, subtreeRenderLanes); } if (next !== null) { workInProgress = next; return; } } else { const next = unwindWork(completedWork, subtreeRenderLanes); if (next !== null) { next.flags \u0026amp;= HostEffectMask; workInProgress = next; return; } if (returnFiber !== null) { returnFiber.flags |= Incomplete; returnFiber.subtreeFlags = NoFlags; returnFiber.deletions = null; } } const siblingFiber = completedWork.sibling; if (siblingFiber !== null) { // 指向兄弟节点，开始兄弟节点的『递和归』 workInProgress = siblingFiber; return; } // 指向父节点，完成父节点的『归』 completedWork = returnFiber; workInProgress = completedWork; } while (completedWork !== null); if (workInProgressRootExitStatus === RootIncomplete) { workInProgressRootExitStatus = RootCompleted; } } “递”阶段（beginWork）：传入当前 fiberNode，创建子 fiberNode，根据 VDOM 创建 fiber 树； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /** * 从 rootFiber 开始向下深度优先遍历；为遍历到的每个 fiberNode 调用 beginWork 方法 * 该方法会根据传入的 fiberNode 创建子 fiberNode，并将这两个 fiberNode 连接起来 * 当遍历到“没有子组件的组件”时就会进入“归”阶段 */ function beginWork( current, // 上一次更新的 fiberNode（workInProgress.alternate） workInProgress, // 当前组件对应的 fiberNode renderLanes // 渲染优先级 ) { const updateLanes = workInProgress.lanes; if (current !== null) { // update 阶段，可以复用节点 const oldProps = current.memoizedProps; const newProps = workInProgress.pendingProps; /** * 节点不能复用的条件（满足任一就不能复用）: * oldProps !== newProps * hasContextChanged() * workInProgress.type !== current.type */ if ( oldProps !== newProps || hasLegacyContextChanged() || workInProgress.type !== current.type ) { didReceiveUpdate = true; // type 都不一样，复用个鸡 } else if (!includesSomeLane(renderLanes, updateLanes)) { // 当前节点优先级不够 didReceiveUpdate = false; // 可以复用子节点 switch (workInProgress.tag) { case HostRoot: // ... case HostComponent: // ... case ClassComponent: // ... case HostPortal: // ... case ContextProvider: // ... case Profiler: // ... case SuspenseComponent: // ... case SuspenseListComponent: // ... case OffscreenComponent: // ... case LegacyHiddenComponent: // ... } return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } else { if ((current.flags \u0026amp; ForceUpdateForLegacySuspense) !== NoFlags) { didReceiveUpdate = true; } else { didReceiveUpdate = false; // 可以复用子节点 } } } else { // mount 阶段，根据 tag 创建节点 didReceiveUpdate = false; } workInProgress.lanes = NoLanes; // 根据 tag 创建不同的 fiber，最终会调用 reconcileChildren switch (workInProgress.tag) { case IndeterminateComponent: // ... case LazyComponent: // ... case FunctionComponent: // ... case ClassComponent: // ... case HostRoot: // ... case HostComponent: // ... case HostText: // ... case SuspenseComponent: // ... case HostPortal: // ... case ForwardRef: // ... case Fragment: // ... case Mode: // ... case Profiler: // ... case ContextProvider: // ... case ContextConsumer: // ... case MemoComponent: // ... case SimpleMemoComponent: // ... case IncompleteClassComponent: // ... case SuspenseListComponent: // ... case FundamentalComponent: // ... case ScopeComponent: // ... case Block: // ... case OffscreenComponent: // ... case LegacyHiddenComponent: // ... } } reconcileChildren：reconcileChildFibers 与 mountChildFibers 的区别是会为 fiber 节点打上 effectTag； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 export function reconcileChildren( current, workInProgress, nextChildren, renderLanes ) { if (current === null) { /** * mount 阶段，创建子 fiberNode * 如果这是一个还没有被渲染的新组件 * 我们不会通过应用最小的副作用来更新它的子集 * 相反，我们会在子集被渲染之前将其全部加入 * 这意味着我们可以通过不跟踪副作用来优化这个调和通道 */ workInProgress.child = mountChildFibers( workInProgress, null, nextChildren, renderLanes ); } else { /** * update 阶段，diff 两棵树上的 fiberNode，进行复用 * reconcileChildFibers 会生成带有 effectTag 属性的 fiberNode * 如果当前的 current 子节点和 workInProgress 中的相同 * 这说明我们还没有开始对这些子节点进行任何操作 * 所以，我们使用克隆算法来创建所有 children */ workInProgress.child = reconcileChildFibers( workInProgress, current.child, nextChildren, renderLanes ); } } // 通过 shouldTrackSideEffects 来决定是否打上 effectTag export const mountChildFibers = ChildReconciler(false); export const reconcileChildFibers = ChildReconciler(true); effectTag：在 commit 阶段告知 renderer 对视图进行何种操作；在首次渲染时，只有 rootFiber 会被打上 Placement，在 commit 阶段进行一次插入操作； 1 2 3 4 5 export const Placement = /* */ 0b000000000000000010; export const Update = /* */ 0b000000000000000100; export const PlacementAndUpdate = /* */ 0b000000000000000110; export const Deletion = /* */ 0b000000000000001000; // ... “归”阶段（completeWork）：构建 effectList； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 /** * 当某个 fiberNode 执行完 completeWork，如果其存在兄弟 fiberNode（fiber.sibling !== null），会进入其兄弟 fiberNode 的“递”阶段 * 如果不存在兄弟 fiberNode，会进入父级 fiber 的“归”阶段 * “递”和“归”阶段会交错执行，直到“归”到 rootFiber */ function completeWork(current, workInProgress, renderLanes) { const newProps = workInProgress.pendingProps; switch (workInProgress.tag) { case IndeterminateComponent: case LazyComponent: case SimpleMemoComponent: case FunctionComponent: case ForwardRef: case Fragment: case Mode: case Profiler: case ContextConsumer: case MemoComponent: return null; case ClassComponent: { // ... return null; } case HostRoot: { // ... updateHostContainer(workInProgress); return null; } case HostComponent: { popHostContext(workInProgress); const rootContainerInstance = getRootHostContainer(); const type = workInProgress.type; // 需要考虑 fiberNode 是否有对应的 DOM 节点 if (current !== null \u0026amp;\u0026amp; workInProgress.stateNode != null) { // update 阶段，处理 props updateHostComponent( current, workInProgress, type, newProps, rootContainerInstance ); // ... } else { // mount 阶段 const currentHostContext = getHostContext(); // 为 fiberNode 生成对应的 DOM 节点 const instance = createInstance( type, newProps, rootContainerInstance, currentHostContext, workInProgress ); /** * 将子孙 DOM 节点插入刚生成的 DOM 节点中 * 每次调用 appendAllChildren 时都会将已生成的子孙 DOM 节点插入当前生成的 DOM 节点下 * 那么当“归”到 rootFiber 时，我们已经有一个构建好的离屏 DOM 树 */ appendAllChildren(instance, workInProgress, false, false); // DOM 节点赋值给 fiber.stateNode workInProgress.stateNode = instance; // 处理 props if ( finalizeInitialChildren( instance, type, newProps, rootContainerInstance, currentHostContext ) ) { markUpdate(workInProgress); } // ... } return null; } // ... } } effectList：除了构建 workInProgress，completeUnitOfWork 还会将所有存在 effectTag 中的 fiberNode 保存在 effectList 单向链表中（nextEffect 指针指向下一个 fiber，第一个节点为 firstEffect，最后一个节点为 lastEffect），在 commit 阶段，只需要遍历 effectList，执行所有 effect，执行对应的 DOM 操作就好。 1 2 3 nextEffect nextEffect nextEffect rootFiber.firstEffect ----------\u0026gt; fiber ----------\u0026gt; fiber ----------\u0026gt; ... render 阶段之后 fiberRoot 会被传递给 commitRoot，进入 commit 阶段。\nhooks 在 render 的 begin（递）的阶段，会在 mountIndeterminateComponent 中挂载组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 function mountIndeterminateComponent( _current, workInProgress, Component, renderLanes ) { // ... let value; value = renderWithHooks( null, workInProgress, Component, props, context, renderLanes ); workInProgress.flags |= PerformedWork; if ( !disableModulePatternComponents \u0026amp;\u0026amp; typeof value === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; value !== null \u0026amp;\u0026amp; typeof value.render === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; value.$$typeof === undefined ) { // 类组件逻辑... } else { // 函数组件逻辑... workInProgress.tag = FunctionComponent; reconcileChildren(null, workInProgress, value, renderLanes); return workInProgress.child; } } // 函数式组件的入口 export function renderWithHooks\u0026lt;Props, SecondArg\u0026gt;( current: Fiber | null, workInProgress: Fiber, Component: (p: Props, arg: SecondArg) =\u0026gt; any, props: Props, secondArg: SecondArg, nextRenderLanes: Lanes ): any { renderLanes = nextRenderLanes; currentlyRenderingFiber = workInProgress; /** * 类组件中，memoizedState 存放 state * 函数组件中，memoizedState 以链表的形式存放 hook */ workInProgress.memoizedState = null; workInProgress.updateQueue = null; workInProgress.lanes = NoLanes; // 只有当一个有状态的 hook 被使用时，才可以通过 memoizedState 来区分是 mount 还是 update ReactCurrentDispatcher.current = current === null || current.memoizedState === null ? HooksDispatcherOnMount // mount 时用的 hook : HooksDispatcherOnUpdate; // update 时用的 hook let children = Component(props, secondArg); // 调用函数组件，组件内 hook 执行，保存到 WIP 上 // 检测渲染阶段的 update if (didScheduleRenderPhaseUpdateDuringThisPass) { // ... } ReactCurrentDispatcher.current = ContextOnlyDispatcher; const didRenderTooFewHooks = currentHook !== null \u0026amp;\u0026amp; currentHook.next !== null; renderLanes = NoLanes; currentlyRenderingFiber = null; currentHook = null; workInProgressHook = null; didScheduleRenderPhaseUpdate = false; return children; } 内置的 hooks 都是从 ReactCurrentDispatcher.current 上拿的；组件不同阶段，给 ReactCurrentDispatcher.current 赋不同的值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 function resolveDispatcher() { const dispatcher = ReactCurrentDispatcher.current; invariant(dispatcher !== null, \u0026#39;Hooks 只能在函数组件里调用\u0026#39;); return dispatcher; } export function useState\u0026lt;S\u0026gt;( initialState: (() =\u0026gt; S) | S ): [S, Dispatch\u0026lt;BasicStateAction\u0026lt;S\u0026gt;\u0026gt;] { const dispatcher = resolveDispatcher(); return dispatcher.useState(initialState); } export function useRef\u0026lt;T\u0026gt;(initialValue: T): { current: T } { const dispatcher = resolveDispatcher(); return dispatcher.useRef(initialValue); } export function useEffect( create: () =\u0026gt; (() =\u0026gt; void) | void, deps: Array\u0026lt;mixed\u0026gt; | void | null ): void { const dispatcher = resolveDispatcher(); return dispatcher.useEffect(create, deps); } export function useMemo\u0026lt;T\u0026gt;( create: () =\u0026gt; T, deps: Array\u0026lt;mixed\u0026gt; | void | null ): T { const dispatcher = resolveDispatcher(); return dispatcher.useMemo(create, deps); } const HooksDispatcherOnMount: Dispatcher = { readContext, useCallback: mountCallback, useContext: readContext, useEffect: mountEffect, useLayoutEffect: mountLayoutEffect, useMemo: mountMemo, useReducer: mountReducer, useRef: mountRef, useState: mountState // ... }; const HooksDispatcherOnUpdate: Dispatcher = { readContext, useCallback: updateCallback, useContext: readContext, useEffect: updateEffect, useLayoutEffect: updateLayoutEffect, useMemo: updateMemo, useReducer: updateReducer, useRef: updateRef, useState: updateState // ... }; 函数组件在挂载阶段，内部的每个 hook 都会产生一个对象绑定在 workInProgress.memoizedState 属性上，并形成循环链表结构；挂载阶段对应的 hooks：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 function mountState\u0026lt;S\u0026gt;( initialState: (() =\u0026gt; S) | S ): [S, Dispatch\u0026lt;BasicStateAction\u0026lt;S\u0026gt;\u0026gt;] { const hook = mountWorkInProgressHook(); // 如果初始状态是一个函数，函数的返回值作为初始状态 if (typeof initialState === \u0026#39;function\u0026#39;) { initialState = initialState(); } // 保存初始状态 hook.memoizedState = hook.baseState = initialState; const queue = (hook.queue = { pending: null, dispatch: null, // 提交 action 的函数 lastRenderedReducer: basicStateReducer, // 用于状态更新的 reducer lastRenderedState: initialState // 自从上次渲染过后，最新的 state }); const dispatch: Dispatch\u0026lt;BasicStateAction\u0026lt;S\u0026gt;\u0026gt; = (queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber, queue)); return [hook.memoizedState, dispatch]; } // 组件第一次渲染，hooks 都会调用 mountWorkInProgressHook function mountWorkInProgressHook(): Hook { const hook: Hook = { memoizedState: null, // 保存 hooks 信息（state、effect、dep、ref 等） baseState: null, // 当前最新 state baseQueue: null, // 当前最新更新队列 queue: null, // 待更新队列 next: null // 链表指针，链表的存在导致 hooks 不能在条件语句中调用 }; if (workInProgressHook === null) { currentlyRenderingFiber.memoizedState = workInProgressHook = hook; } else { workInProgressHook = workInProgressHook.next = hook; } return workInProgressHook; } // mountState 内的 dispatch function dispatchAction\u0026lt;S, A\u0026gt;( fiber: Fiber, queue: UpdateQueue\u0026lt;S, A\u0026gt;, action: A ) { const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); const update: Update\u0026lt;S, A\u0026gt; = { lane, action, // 新提交的状态 eagerReducer: null, eagerState: null, next: null }; // 将更新添加到链表最后 const pending = queue.pending; if (pending === null) { // 这是第一个更新，创建循环链表 update.next = update; } else { update.next = pending.next; pending.next = update; } queue.pending = update; const alternate = fiber.alternate; if ( fiber === currentlyRenderingFiber || (alternate !== null \u0026amp;\u0026amp; alternate === currentlyRenderingFiber) ) { // 发生在渲染阶段的更新 didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true; } else { if ( fiber.lanes === NoLanes \u0026amp;\u0026amp; (alternate === null || alternate.lanes === NoLanes) ) { /** * 队列当前是空的；在进入下一次渲染之前，可以计算下一个状态 * 如果新的状态和当前状态一致，可以跳过更新（两次 useState 值相等就不渲染） */ const lastRenderedReducer = queue.lastRenderedReducer; if (lastRenderedReducer !== null) { let prevDispatcher; try { const currentState: S = queue.lastRenderedState; const eagerState = lastRenderedReducer(currentState, action); update.eagerReducer = lastRenderedReducer; update.eagerState = eagerState; if (is(eagerState, currentState)) { return; } } catch (error) { } finally { } } } // 调度更新 scheduleUpdateOnFiber(fiber, lane, eventTime); } } function mountEffect( create: () =\u0026gt; (() =\u0026gt; void) | void, deps: Array\u0026lt;mixed\u0026gt; | void | null ): void { // 内部也会调用 mountWorkInProgressHook return mountEffectImpl( PassiveEffect | PassiveStaticEffect, HookPassive, create, deps ); } // mountEffect 内的 mountEffectImpl 还是会调用 mountWorkInProgressHook function mountEffectImpl(fiberFlags, hookFlags, create, deps): void { const hook = mountWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; currentlyRenderingFiber.flags |= fiberFlags; hook.memoizedState = pushEffect( HookHasEffect | hookFlags, create, // 副作用函数 undefined, nextDeps // Dep 依赖 ); } // mountEffect 内的 mountEffectImpl 也会调用 pushEffect function pushEffect(tag, create, destroy, deps) { const effect: Effect = { tag, create, destroy, deps, next: null, }; let componentUpdateQueue: null | FunctionComponentUpdateQueue = (currentlyRenderingFiber.updateQueue: any); if (componentUpdateQueue === null) { // 第一个 useEffect，创建更新队列 componentUpdateQueue = createFunctionComponentUpdateQueue(); currentlyRenderingFiber.updateQueue = (componentUpdateQueue: any); componentUpdateQueue.lastEffect = effect.next = effect; } else { // 多个 useEffect const lastEffect = componentUpdateQueue.lastEffect; if (lastEffect === null) { componentUpdateQueue.lastEffect = effect.next = effect; } else { const firstEffect = lastEffect.next; lastEffect.next = effect; effect.next = firstEffect; componentUpdateQueue.lastEffect = effect; } } return effect; } function mountMemo\u0026lt;T\u0026gt;( nextCreate: () =\u0026gt; T, deps: Array\u0026lt;mixed\u0026gt; | void | null ): T { const hook = mountWorkInProgressHook(); // 创建一个 hook const nextDeps = deps === undefined ? null : deps; const nextValue = nextCreate(); // 获取传入函数的返回值 hook.memoizedState = [nextValue, nextDeps]; // 在 hook 上保存新的值就好 return nextValue; } function mountRef\u0026lt;T\u0026gt;(initialValue: T): { current: T } { const hook = mountWorkInProgressHook(); // 保存初始化的值，反正后续更新，需要手动给 current 赋值 const ref = { current: initialValue }; hook.memoizedState = ref; return ref; } 更新阶段对应的 hooks：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 // 在更新或者渲染阶段，更新触发的重新渲染都会调用此函数 function updateWorkInProgressHook(): Hook { let nextCurrentHook: null | Hook; if (currentHook === null) { const current = currentlyRenderingFiber.alternate; if (current !== null) { nextCurrentHook = current.memoizedState; } else { nextCurrentHook = null; } } else { nextCurrentHook = currentHook.next; } let nextWorkInProgressHook: null | Hook; if (workInProgressHook === null) { nextWorkInProgressHook = currentlyRenderingFiber.memoizedState; } else { nextWorkInProgressHook = workInProgressHook.next; } if (nextWorkInProgressHook !== null) { // 复用 workInProgressHook = nextWorkInProgressHook; nextWorkInProgressHook = workInProgressHook.next; currentHook = nextCurrentHook; } else { currentHook = nextCurrentHook; const newHook: Hook = { memoizedState: currentHook.memoizedState, baseState: currentHook.baseState, baseQueue: currentHook.baseQueue, queue: currentHook.queue, next: null }; if (workInProgressHook === null) { currentlyRenderingFiber.memoizedState = workInProgressHook = newHook; } else { workInProgressHook = workInProgressHook.next = newHook; } } return workInProgressHook; } function updateState\u0026lt;S\u0026gt;( initialState: (() =\u0026gt; S) | S ): [S, Dispatch\u0026lt;BasicStateAction\u0026lt;S\u0026gt;\u0026gt;] { // 内部也会调用 updateWorkInProgressHook return updateReducer(basicStateReducer, initialState); } function updateReducer\u0026lt;S, I, A\u0026gt;( reducer: (S, A) =\u0026gt; S, initialArg: I, init?: (I) =\u0026gt; S ): [S, Dispatch\u0026lt;A\u0026gt;] { const hook = updateWorkInProgressHook(); const queue = hook.queue; queue.lastRenderedReducer = reducer; const current: Hook = currentHook; let baseQueue = current.baseQueue; // 上次还没处理完的待处理更新 const pendingQueue = queue.pending; if (pendingQueue !== null) { // 还没来得及处理的新的更新，将他们添加到『基』队列 if (baseQueue !== null) { // 合并待处理队列和『基』队列 const baseFirst = baseQueue.next; const pendingFirst = pendingQueue.next; baseQueue.next = pendingFirst; pendingQueue.next = baseFirst; } current.baseQueue = baseQueue = pendingQueue; queue.pending = null; } if (baseQueue !== null) { // 有个队列需要处理 const first = baseQueue.next; let newState = current.baseState; let newBaseState = null; let newBaseQueueFirst = null; let newBaseQueueLast = null; let update = first; do { const updateLane = update.lane; if (!isSubsetOfLanes(renderLanes, updateLane)) { // 优先级不够，跳过更新 const clone: Update\u0026lt;S, A\u0026gt; = { lane: updateLane, action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: null }; if (newBaseQueueLast === null) { newBaseQueueFirst = newBaseQueueLast = clone; newBaseState = newState; } else { newBaseQueueLast = newBaseQueueLast.next = clone; } // 更新队列优先级 currentlyRenderingFiber.lanes = mergeLanes( currentlyRenderingFiber.lanes, updateLane ); markSkippedUpdateLanes(updateLane); } else { // 更新有足够的优先级 if (newBaseQueueLast !== null) { const clone: Update\u0026lt;S, A\u0026gt; = { // 更新将被提交 lane: NoLane, // 所有掩码的子集 action: update.action, eagerReducer: update.eagerReducer, eagerState: update.eagerState, next: null }; newBaseQueueLast = newBaseQueueLast.next = clone; } // 处理更新 if (update.eagerReducer === reducer) { newState = update.eagerState; } else { const action = update.action; newState = reducer(newState, action); } } update = update.next; } while (update !== null \u0026amp;\u0026amp; update !== first); if (newBaseQueueLast === null) { newBaseState = newState; } else { newBaseQueueLast.next = newBaseQueueFirst; } if (!is(newState, hook.memoizedState)) { markWorkInProgressReceivedUpdate(); } hook.memoizedState = newState; hook.baseState = newBaseState; hook.baseQueue = newBaseQueueLast; queue.lastRenderedState = newState; } const dispatch: Dispatch\u0026lt;A\u0026gt; = queue.dispatch; return [hook.memoizedState, dispatch]; } function updateEffect( create: () =\u0026gt; (() =\u0026gt; void) | void, deps: Array\u0026lt;mixed\u0026gt; | void | null ): void { // 内部也会调用 updateWorkInProgressHook return updateEffectImpl(PassiveEffect, HookPassive, create, deps); } function updateEffectImpl(fiberFlags, hookFlags, create, deps): void { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; let destroy = undefined; if (currentHook !== null) { const prevEffect = currentHook.memoizedState; destroy = prevEffect.destroy; if (nextDeps !== null) { const prevDeps = prevEffect.deps; if (areHookInputsEqual(nextDeps, prevDeps)) { // 相等就不更新 pushEffect(hookFlags, create, destroy, nextDeps); return; } } } currentlyRenderingFiber.flags |= fiberFlags; hook.memoizedState = pushEffect( HookHasEffect | hookFlags, create, destroy, nextDeps ); } function updateMemo\u0026lt;T\u0026gt;( nextCreate: () =\u0026gt; T, deps: Array\u0026lt;mixed\u0026gt; | void | null ): T { const hook = updateWorkInProgressHook(); const nextDeps = deps === undefined ? null : deps; const prevState = hook.memoizedState; if (prevState !== null) { if (nextDeps !== null) { const prevDeps: Array\u0026lt;mixed\u0026gt; | null = prevState[1]; if (areHookInputsEqual(nextDeps, prevDeps)) { // 相等就返回上一个状态 return prevState[0]; } } } // 重新计算新值 const nextValue = nextCreate(); hook.memoizedState = [nextValue, nextDeps]; return nextValue; } function updateRef\u0026lt;T\u0026gt;(initialValue: T): { current: T } { const hook = updateWorkInProgressHook(); return hook.memoizedState; } 组件类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 有状态组件 export const ClassComponent = 1; export const ContextConsumer = 9; export const ContextProvider = 10; // 无状态组件 export const FunctionComponent = 0; export const IndeterminateComponent = 2; // 不确定（是函数还是类）组件（一个函数返回了一个带 render 方法与其他生命周期的对象） export const ForwardRef = 11; export const MemoComponent = 14; export const SimpleMemoComponent = 15; // MemoComponent 退化过来的，指没有自定义比较方法的 MemoComponent // 原生组件 export const HostRoot = 3; // 渲染起点，可以嵌套在别的节点 export const HostPortal = 4; // 切换渲染起点，可以将子节点渲染到到父节点之外的 DOM 节点上 export const HostComponent = 5; // 元素节点 export const HostText = 6; // 文本节点 // 虚拟组件 export const Fragment = 7; // 数组的语法糖，React 可以直接渲染数组 export const Mode = 8; // 对应的 fiber 都通过 createFiberFromMode 生成的 export const Profiler = 12; // 性能检测，配合 ReactDevTools 工作 // 懒加载组件，有点像之前用的 ReactLoadable 的官方版 export const SuspenseComponent = 13; export const LazyComponent = 16; // 返回 Promise export const SuspenseListComponent = 19; // 其他组件，我还没搞清楚 export const IncompleteClassComponent = 17; export const DehydratedFragment = 18; export const FundamentalComponent = 20; export const ScopeComponent = 21; export const Block = 22; export const OffscreenComponent = 23; // React 版本的 keep-alive，保存失活组件状态 export const LegacyHiddenComponent = 24; 状态更新 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 // 初始化更新队列 export function initializeUpdateQueue\u0026lt;State\u0026gt;(fiber: Fiber): void { /** * 假设 fiber 刚完成 commit 阶段 * 有两个优先级很低的 update（u1、u2）在 render 阶段没有处理 * u1、u2 就成为了下次更新的 baseUpdate * u1.next = u2，fiber.updateQueue.baseUpdate = u1 -\u0026gt; u2 */ const queue: UpdateQueue\u0026lt;State\u0026gt; = { baseState: fiber.memoizedState, // 更新前该 fiber 节点的 state /** * 更新前该 fiber 节点已保存的 update（链表） * 更新前就存在 update 是因为上次 render 阶段 * 可能有优先级较低的 update 被跳过 */ firstBaseUpdate: u1, // 链表头，指向第一个 update 对象 lastBaseUpdate: u2, // 链表尾，指向最后一个 update 对象 shared: { /** * 触发更新时，产生的 update 保存在 shared.pending 中，形成单项环状链表 * 在计算 state 时，链表被剪开，拼接在 lastBaseUpdate 后面 * 假设触发了两次更新，u3、u4（u3 比 u4 先插入） * fiber.updateQueue.shared.pending === u4; * u4.next === u3; * u3.next === u4; * u3、u4 组成了一个环形链表 * 在计算 state 时，shared.pending 被剪开并拼在 lastBaseUpdate 之后 * 实际上 shared.pending 会被同时连接在（current/workInProgress）updateQueue.lastBaseUpdate 之后 * u1 -\u0026gt; u2 -\u0026gt; u3 -\u0026gt; u4（可能会跳过优先级较低的 update），计算出本次更新的 state（memoizedState） */ pending: null // 始终指向最后触发的更新 u4 }, effects: null // 保存 update.callback !== null 的 update }; fiber.updateQueue = queue; } // setState 会调用 enqueueSetState 生成一个 update 并调度 Component.prototype.setState = function (partialState, callback) { if (!(typeof partialState === \u0026#39;object\u0026#39; || typeof partialState === \u0026#39;function\u0026#39; || partialState == null)) { // ... } this.updater.enqueueSetState(this, partialState, callback, \u0026#39;setState\u0026#39;); }; // 触发更新优先级 enqueueSetState(inst, payload, callback) { // 通过组件实例获取对应 fiber const fiber = getInstance(inst); const eventTime = requestEventTime(); const suspenseConfig = requestCurrentSuspenseConfig(); // 获取优先级（根据事件的优先级来决定 update 优先级） const lane = requestUpdateLane(fiber, suspenseConfig); // 创建 update const update = createUpdate(eventTime, lane, suspenseConfig); update.payload = payload; // 部分 state // 确认回调函数，状态确定之后会调用 if (callback !== undefined \u0026amp;\u0026amp; callback !== null) { update.callback = callback; } // 将 setSate 产生的 update 插入 updateQueue enqueueUpdate(fiber, update); // 调度 update scheduleUpdateOnFiber(fiber, lane, eventTime); } // forceUpdate 会调用 enqueueForceUpdate 生成 update 并调度 Component.prototype.forceUpdate = function(callback) { this.updater.enqueueForceUpdate(this, callback, \u0026#39;forceUpdate\u0026#39;); }; enqueueForceUpdate(inst, callback) { const fiber = getInstance(inst); const eventTime = requestEventTime(); const lane = requestUpdateLane(fiber); const update = createUpdate(eventTime, lane); update.tag = ForceUpdate; // 2，forceUpdate 没有 payload if (callback !== undefined \u0026amp;\u0026amp; callback !== null) { update.callback = callback; } enqueueUpdate(fiber, update); scheduleUpdateOnFiber(fiber, lane, eventTime); }; // update 结构（ClassComponent/HostRoot） export function createUpdate(eventTime, lane) { // 表示一个需要进行变更的动作 const update = { // 若优先级不够导致 update 一直没执行；React 会在任务超时后，调度 update eventTime, // 任务时间（update 生成时间） lane, // update 优先级 tag: UpdateState, // UpdateState、ReplaceState、ForceUpdate、CaptureUpdate payload: null, // 更新挂载的数据 /** * 更新后的回调函数，如果这个回调有返回值 * 就会在 updateQueue 的副作用链表中挂在当前 update * 具体逻辑在 processUpdateQueue 函数中 */ callback: null, // update 回调，setState 的第二个参数 // 多次 setState 会有多个 update，他们之间通过 next 链接 next: null // 指向下一个 update，所有 update 链接形成链表保存在 fiber.updateQueue }; return update; } // 将 update 添加到 fiber 的 update 链表 export function enqueueUpdate\u0026lt;State\u0026gt;(fiber: Fiber, update: Update\u0026lt;State\u0026gt;) { const updateQueue = fiber.updateQueue; // 获取 fiber 节点的 update 队列 if (updateQueue === null) { // 当节点被卸载之后才会出现这种情况 return; } const sharedQueue: SharedQueue\u0026lt;State\u0026gt; = (updateQueue: any).shared; const pending = sharedQueue.pending; if (pending === null) { // 链表是空的 update.next = update; } else { update.next = pending.next; pending.next = update; } sharedQueue.pending = update; } export function scheduleUpdateOnFiber( fiber: Fiber, lane: Lane, eventTime: number ) { checkForNestedUpdates(); // 从 fiber 遍历到 root const root = markUpdateLaneFromFiberToRoot(fiber, lane); if (root === null) { return null; } // 标记 root 有一个正在进行的更新 markRootUpdated(root, lane, eventTime); if (root === workInProgressRoot) { /** * 如果渲染中间，收到了对树的更新 * 那就是说，对于树，有交错更新的任务 * 除非『推迟渲染阶段更新到下一个批处理』是 off，并且是渲染阶段的更新 * 在这种情况下，出于向后兼容的原因 * 不会将渲染阶段的更新视为要交错进行的任务 */ if ( deferRenderPhaseUpdateToNextBatch || (executionContext \u0026amp; RenderContext) === NoContext ) { workInProgressRootUpdatedLanes = mergeLanes( workInProgressRootUpdatedLanes, lane ); } if (workInProgressRootExitStatus === RootSuspendedWithDelay) { /** * root 已经挂起，渲染肯定没有结束 * 既然有一个更新，在被标记为新的更新之前，那就先标记为『挂起』 * 这会中断当前渲染并切换到新的更新 */ markRootSuspended(root, workInProgressRootRenderLanes); } } const priorityLevel = getCurrentPriorityLevel(); if (lane === SyncLane) { if ( // 检查是否在『unbatchedUpdates』 (executionContext \u0026amp; LegacyUnbatchedContext) !== NoContext \u0026amp;\u0026amp; // 检查是否已经在渲染 (executionContext \u0026amp; (RenderContext | CommitContext)) === NoContext ) { // root 的初始化渲染应该是同步的，布局更新应该推迟到批处理结束 schedulePendingInteractions(root, lane); performSyncWorkOnRoot(root); } else { ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); if (executionContext === NoContext) { /** * 刷新同步工作，除非正在进行刷新或在批处理内 * 这在『scheduleUpdateOnFiber』而不是在 scheduleCallbackForFiber 是故意的 * 这会保留调度但不刷新回调的能力 * 仅对用户发起的更新执行此操作，以保留传统模式的历史行为 */ resetRenderTimer(); flushSyncCallbackQueue(); } } } else { // 非同步的情况下，调度离散更新 if ( (executionContext \u0026amp; DiscreteEventContext) !== NoContext \u0026amp;\u0026amp; /** * 只有用户阻塞或更高优先级的更新才被视为离散的 * 即使在离散事件中也是如此 */ (priorityLevel === UserBlockingSchedulerPriority || priorityLevel === ImmediateSchedulerPriority) ) { // 追踪最低优先级的离散更新 if (rootsWithPendingDiscreteUpdates === null) { rootsWithPendingDiscreteUpdates = new Set([root]); } else { rootsWithPendingDiscreteUpdates.add(root); } } ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, lane); } mostRecentlyUpdatedRoot = root; } export function processUpdateQueue\u0026lt;State\u0026gt;( workInProgress: Fiber, props: any, instance: any, renderLanes: Lanes ): void { const queue: UpdateQueue\u0026lt;State\u0026gt; = workInProgress.updateQueue; hasForceUpdate = false; let firstBaseUpdate = queue.firstBaseUpdate; let lastBaseUpdate = queue.lastBaseUpdate; let pendingQueue = queue.shared.pending; if (pendingQueue !== null) { queue.shared.pending = null; // 剪开 pendingQueue 环状链表 const lastPendingUpdate = pendingQueue; const firstPendingUpdate = lastPendingUpdate.next; lastPendingUpdate.next = null; // 将 pendingUpdate 添加到 baseQueue if (lastBaseUpdate === null) { firstBaseUpdate = firstPendingUpdate; } else { lastBaseUpdate.next = firstPendingUpdate; } lastBaseUpdate = lastPendingUpdate; const current = workInProgress.alternate; if (current !== null) { const currentQueue: UpdateQueue\u0026lt;State\u0026gt; = current.updateQueue; const currentLastBaseUpdate = currentQueue.lastBaseUpdate; if (currentLastBaseUpdate !== lastBaseUpdate) { if (currentLastBaseUpdate === null) { currentQueue.firstBaseUpdate = firstPendingUpdate; } else { currentLastBaseUpdate.next = firstPendingUpdate; } currentQueue.lastBaseUpdate = lastPendingUpdate; } } } if (firstBaseUpdate !== null) { // 迭代更新列表以计算结果 let newState = queue.baseState; let newLanes = NoLanes; let newBaseState = null; let newFirstBaseUpdate = null; let newLastBaseUpdate = null; let update = firstBaseUpdate; do { const updateLane = update.lane; const updateEventTime = update.eventTime; if (!isSubsetOfLanes(renderLanes, updateLane)) { // 优先级不够，跳过更新，跳过的更新的前一个状态就是新的『基态』 const clone: Update\u0026lt;State\u0026gt; = { eventTime: updateEventTime, lane: updateLane, tag: update.tag, payload: update.payload, callback: update.callback, next: null }; if (newLastBaseUpdate === null) { newFirstBaseUpdate = newLastBaseUpdate = clone; newBaseState = newState; } else { newLastBaseUpdate = newLastBaseUpdate.next = clone; } newLanes = mergeLanes(newLanes, updateLane); } else { // 优先级足够 if (newLastBaseUpdate !== null) { // 即将被提交的 update const clone: Update\u0026lt;State\u0026gt; = { eventTime: updateEventTime, lane: NoLane, // 0 是所有位掩码的子集 tag: update.tag, payload: update.payload, callback: update.callback, next: null }; newLastBaseUpdate = newLastBaseUpdate.next = clone; } // 处理 update，计算新的 state newState = getStateFromUpdate( workInProgress, queue, update, newState, props, instance ); const callback = update.callback; if (callback !== null) { workInProgress.flags |= Callback; const effects = queue.effects; if (effects === null) { queue.effects = [update]; } else { effects.push(update); } } } update = update.next; if (update === null) { pendingQueue = queue.shared.pending; if (pendingQueue === null) { break; } else { const lastPendingUpdate = pendingQueue; const firstPendingUpdate = lastPendingUpdate.next; lastPendingUpdate.next = null; update = firstPendingUpdate; queue.lastBaseUpdate = lastPendingUpdate; queue.shared.pending = null; } } } while (true); if (newLastBaseUpdate === null) { newBaseState = newState; } queue.baseState = newBaseState; queue.firstBaseUpdate = newFirstBaseUpdate; queue.lastBaseUpdate = newLastBaseUpdate; /** * 将剩余过期时间设置为队列中剩余的时间 * 影响过期时间的另外两个因素就是 props 和 context */ markSkippedUpdateLanes(newLanes); workInProgress.lanes = newLanes; workInProgress.memoizedState = newState; } } // 最终由 getStateFromUpdate 计算出 state function getStateFromUpdate\u0026lt;State\u0026gt;( workInProgress: Fiber, queue: UpdateQueue\u0026lt;State\u0026gt;, update: Update\u0026lt;State\u0026gt;, prevState: State, nextProps: any, instance: any ): any { switch (update.tag) { case ReplaceState: { const payload = update.payload; if (typeof payload === \u0026#39;function\u0026#39;) { const nextState = payload.call(instance, prevState, nextProps); return nextState; } return payload; } case CaptureUpdate: { workInProgress.flags = (workInProgress.flags \u0026amp; ~ShouldCapture) | DidCapture; } case UpdateState: { const payload = update.payload; let partialState; if (typeof payload === \u0026#39;function\u0026#39;) { partialState = payload.call(instance, prevState, nextProps); } else { partialState = payload; } if (partialState === null || partialState === undefined) { return prevState; } return Object.assign({}, prevState, partialState); } case ForceUpdate: { hasForceUpdate = true; return prevState; } } return prevState; } legacy 模式：\n1 ReactDOM.render(\u0026lt;App /\u0026gt;, rootNode); 在同步操作中，setState 是异步的； 在异步操作中，setState 是同步的； 创建的任务/更新均为同样的优先级。 concurrent 模式：\n1 ReactDOM.createRoot(rootNode).render(\u0026lt;App /\u0026gt;); 更急迫的更新可以中断已经开始的渲染； 创建的任务/更新有不同的优先级； 渲染过程可以被打断； setState 是异步。 生命周期 reconciler 阶段（render 阶段）；生成新的 fiber 树并收集本次要更新的点；对应的钩子为：\nconstructor static getDerivedStateFromProps static getDerivedStateFromError（发生错误的组件不会触发自身的钩子） shouldComponentUpdate render commit 阶段（renderer 阶段）；将要更新的点 patch 到 DOM 上并切换 fiber 树；对应的钩子为：\ngetSnapshotBeforeUpdate componentDidMount componentDidUpdate componentDidCatch（发生错误的组件不会触发自身的钩子） componentWillUnmount 为什么要对生命周期钩子大换血？ 组件在挂载过程中会调三次钩子（constructor、componentWillMount、render），组件在更新过程中会调四次钩子（componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render）；总不能每个方法都用 try\u0026hellip;catch 包起来，这样会性能很差；而 constructor、render 是不可避免的，于是对三个 willXXX 动刀了。\n在早期版本中，componentWillMount 与 componentWillReceiveProps 会做内部优化，执行多次 setState 都会延后到 render 时进行合并处理；因此用户就肆意 setState 了。这些 willXXX 还可以让用户任意操作 DOM；操作 DOM 会可能 reflow，这是官方不愿意看到的。于是官方推出了 getDerivedStateFromProps，让你在 render 设置新 state，你主要返回一个新对象，它就主动帮你 setState。由于这是一个静态方法，你不能操作 instance，这就阻止了你多次操作 setState。由于没有 instance，也就没有 instance.refs.xxx，你也没有机会操作 DOM 了。这样一来，getDerivedStateFromProps 的逻辑应该会很简单，这样就不会出错，就不会打断 DFS 过程。\ngetDerivedStateFromProps 取代了原来的 componentWillMount 与 componentWillReceiveProps 方法，而 componentWillUpdate 本来就是可有可无，以前完全是为了对称好看。在即使到来的异步更新中，render 阶段可能执行多次，才执行一次 commit；这样也会导致 willXXX 钩子执行多次，违反它们的语义，它们的废弃是不可逆转的。在进入 commit 阶段时，组件多了一个新钩子叫 getSnapshotBeforeUpdate，它与 commit 阶段的钩子一样只执行一次。如果出错呢，在 componentDidMount/Update 后，我们可以使用 componentDidCatch 方法。\nrender 阶段的钩子都不应该操作 DOM，最好也不要 setState，我们称之为轻量钩子；commit 阶段的钩子则对应称之为重量钩子。\nconstructor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 /** * 以下情况会调用 constructClassInstance（构建类组件实例）： * 1. updateClassComponent（如果 instance 为 null） * 2. mountIncompleteClassComponent */ function constructClassInstance( workInProgress: Fiber, ctor: any, props: any ): any { // 处理上下文 const contextType = ctor.contextType; let isLegacyContextConsumer = false; let unmaskedContext = emptyContextObject; // {} let context = emptyContextObject; // {} if (typeof contextType === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; contextType !== null) { context = readContext(contextType); } else if (!disableLegacyContext) { unmaskedContext = getUnmaskedContext(workInProgress, ctor, true); const contextTypes = ctor.contextTypes; isLegacyContextConsumer = contextTypes !== null \u0026amp;\u0026amp; contextTypes !== undefined; context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject; } // 创建组件实例 const instance = new ctor(props, context); const state = (workInProgress.memoizedState = instance.state !== null \u0026amp;\u0026amp; instance.state !== undefined ? instance.state : null); /** * 实例需要访问到 fiber，以便可以安排更新 * instance.updater = classComponentUpdater * workInProgress.stateNode = instance * instance._reactInternals = workInProgress */ adoptClassInstance(workInProgress, instance); /** * 缓存 unmasked context，可以避免在不必要的情况下重新创建 masked context * ReactFiberContext 通常更新此缓存，但不能更新新创建的实例 */ if (isLegacyContextConsumer) { cacheContext(workInProgress, unmaskedContext, context); } return instance; } getDerivedStateFromProps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * 以下情况会调用 applyDerivedStateFromProps： * 1. mountClassInstance：挂载组件实例 * 2. resumeMountClassInstance：复用组件实例 * 3. updateClassInstance：更新组件实例 * 可以通过 props 派生出一个 state，constructor 也可以执行这个逻辑 * 但是 constructor 只会在初始化时执行 * getDerivedStateFromProps 会在每次 render 函数调用前执行 */ export function applyDerivedStateFromProps( workInProgress: Fiber, ctor: any, getDerivedStateFromProps: (props: any, state: any) =\u0026gt; any, nextProps: any, ) { // 更新前/初始状态 const prevState = workInProgress.memoizedState; // getDerivedStateFromProps 接受新的 props 和旧的 state，返回变化的 state const partialState = getDerivedStateFromProps(nextProps, prevState); // 合并为更新后的/挂载后的状态 const memoizedState = partialState === null || partialState === undefined ? prevState : Object.assign({}, prevState, partialState); // 保存在 workInProgress 中 workInProgress.memoizedState = memoizedState; // 更新队列空了之后，将新的状态持久化到基本状态 if (workInProgress.lanes === NoLanes) { // 对于类，队列始终为非 null const updateQueue: UpdateQueue\u0026lt;any\u0026gt; = (workInProgress.updateQueue: any); updateQueue.baseState = memoizedState; } } shouldComponentUpdate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /** * shouldUpdate 会在以下情况求值，来确定是否更新： * 1. resumeMountClassInstance * 2. updateClassInstance */ const shouldUpdate = // this.forceUpdate 会将 hasForceUpdate 置为 true，所以组件一定会更新 checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext ); function checkShouldComponentUpdate( workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext ) { const instance = workInProgress.stateNode; if (typeof instance.shouldComponentUpdate === \u0026#39;function\u0026#39;) { // 如果用户引入了 shouldComponentUpdate，计算组件是否应该更新 const shouldUpdate = instance.shouldComponentUpdate( newProps, newState, nextContext ); return shouldUpdate; } if (ctor.prototype \u0026amp;\u0026amp; ctor.prototype.isPureReactComponent) { // 如果继承了 PureComponent，对 props 和 state 做浅比较 return ( !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) ); } return true; } render 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * 以下情况会调用 updateClassComponent： * 1. mountIncompleteClassComponent * 2. mountIndeterminateComponent */ function finishClassComponent( current: Fiber | null, workInProgress: Fiber, Component: any, shouldUpdate: boolean, hasContext: boolean, renderLanes: Lanes ) { // 即使 shouldComponentUpdate 返回的是 false，refs 也得更新 markRef(current, workInProgress); const didCaptureError = (workInProgress.flags \u0026amp; DidCapture) !== NoFlags; if (!shouldUpdate \u0026amp;\u0026amp; !didCaptureError) { if (hasContext) { invalidateContextProvider(workInProgress, Component, false); } return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes); } const instance = workInProgress.stateNode; ReactCurrentOwner.current = workInProgress; let nextChildren; if ( didCaptureError \u0026amp;\u0026amp; typeof Component.getDerivedStateFromError !== \u0026#39;function\u0026#39; ) { /** * 如果捕获到错误，但是没有 getDerivedStateFromError 钩子，卸载所有子组件 * componentDidCatch 将安排更新来重新渲染 fallback */ nextChildren = null; } else { nextChildren = instance.render(); } workInProgress.flags |= PerformedWork; if (current !== null \u0026amp;\u0026amp; didCaptureError) { /** * 如果我们正在从错误中恢复，请在不重用任何现有子节点的情况下进行协调 * 从概念上讲，正常的子节点和因错而显示的子节点是两个不同的集合 * 即使它们的身份匹配，我们也不应该重用正常的子节点 */ forceUnmountCurrentAndReconcile( current, workInProgress, nextChildren, renderLanes ); } else { reconcileChildren(current, workInProgress, nextChildren, renderLanes); } // 保存刚刚用来渲染的状态 workInProgress.memoizedState = instance.state; // 重新计算可能发生改变的 context 传过来的值 if (hasContext) { invalidateContextProvider(workInProgress, Component, true); } return workInProgress.child; } getSnapshotBeforeUpdate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /** * 会在 commitBeforeMutationLifeCycles 里调用（就是在最终 commit 之前被调用） * 之后便会 commitMutationEffects 执行 commitWork */ function commitBeforeMutationLifeCycles( current: Fiber | null, finishedWork: Fiber ): void { switch (finishedWork.tag) { case FunctionComponent: case ForwardRef: case SimpleMemoComponent: case Block: { return; } case ClassComponent: { if (finishedWork.flags \u0026amp; Snapshot) { if (current !== null) { const prevProps = current.memoizedProps; const prevState = current.memoizedState; const instance = finishedWork.stateNode; // snapshot 会作为 componentDidUpdate 的第三个参数 const snapshot = instance.getSnapshotBeforeUpdate( finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState ); instance.__reactInternalSnapshotBeforeUpdate = snapshot; } } return; } case HostRoot: { if (supportsMutation) { if (finishedWork.flags \u0026amp; Snapshot) { const root = finishedWork.stateNode; clearContainer(root.containerInfo); } } return; } case HostComponent: case HostText: case HostPortal: case IncompleteClassComponent: return; } } componentDidMount/componentDidUpdate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * 在 commitRoot 里循环调用 commitLayoutEffects 直到 nextEffect 为 null * commitLifeCycles 会在 commitLayoutEffects 里被调用 */ function commitLifeCycles( finishedRoot: FiberRoot, current: Fiber | null, finishedWork: Fiber, committedLanes: Lanes, ): void { switch (finishedWork.tag) { // ... case ClassComponent: { const instance = finishedWork.stateNode; if (finishedWork.flags \u0026amp; Update) { // 根据是否是初次渲染，选择调用 componentDidMount 还是 componentDidUpdate if (current === null) { instance.componentDidMount(); } else { const prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps); const prevState = current.memoizedState; instance.componentDidUpdate( prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate, ); } } const updateQueue = (finishedWork.updateQueue: any); if (updateQueue !== null) { commitUpdateQueue(finishedWork, updateQueue, instance); } return; } // ... } } componentWillUnmount 1 2 3 4 5 6 7 8 9 10 /** * 组件卸载时会调用 commitUnmount，其中包含了不同类型的组件的卸载方式 * 对于 ClassComponent 会先解绑 ref（safelyDetachRef）再调用 safelyCallComponentWillUnmount * safelyCallComponentWillUnmount 会在 try...catch 里调用 callComponentWillUnmountWithTimer */ const callComponentWillUnmountWithTimer = function (current, instance) { instance.props = current.memoizedProps; instance.state = current.memoizedState; instance.componentWillUnmount(); }; getDerivedStateFromError/componentDidCatch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 /** * 在 renderRootSync 的过程中，如果 workLoopSync/workLoopConcurrent 执行出错，会执行 handleError * throwException 会将 createClassErrorUpdate 的返回值通过 enqueueCapturedUpdate 加入更新队列 */ function createClassErrorUpdate( fiber: Fiber, errorInfo: CapturedValue\u0026lt;mixed\u0026gt;, lane: Lane ): Update\u0026lt;mixed\u0026gt; { const update = createUpdate(NoTimestamp, lane); update.tag = CaptureUpdate; const getDerivedStateFromError = fiber.type.getDerivedStateFromError; if (typeof getDerivedStateFromError === \u0026#39;function\u0026#39;) { const error = errorInfo.value; update.payload = () =\u0026gt; { logCapturedError(fiber, errorInfo); return getDerivedStateFromError(error); }; } const inst = fiber.stateNode; if (inst !== null \u0026amp;\u0026amp; typeof inst.componentDidCatch === \u0026#39;function\u0026#39;) { update.callback = function callback() { if (typeof getDerivedStateFromError !== \u0026#39;function\u0026#39;) { /** * 为了保留错误边界的先前存在的重试行为 * 我们跟踪在这一批中哪些已经失败 * 在我们返回到浏览器之前，它会被重置 */ markLegacyErrorBoundaryAsFailed(this); // log 一下，如果 componentDidCatch 是唯一被定义的错误边界方法 logCapturedError(fiber, errorInfo); } const error = errorInfo.value; const stack = errorInfo.stack; this.componentDidCatch(error, { componentStack: stack !== null ? stack : \u0026#39;\u0026#39; }); }; } return update; } export function captureCommitPhaseError(sourceFiber: Fiber, error: mixed) { if (sourceFiber.tag === HostRoot) { // 错误在根组件被抛出，没有父级，需要根组件捕获 captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error); return; } let fiber = sourceFiber.return; while (fiber !== null) { // 向上查找 if (fiber.tag === HostRoot) { captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error); return; } else if (fiber.tag === ClassComponent) { const ctor = fiber.type; const instance = fiber.stateNode; if ( typeof ctor.getDerivedStateFromError === \u0026#39;function\u0026#39; || (typeof instance.componentDidCatch === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; !isAlreadyFailedLegacyErrorBoundary(instance)) ) { const errorInfo = createCapturedValue(error, sourceFiber); const update = createClassErrorUpdate(fiber, errorInfo, SyncLane); enqueueUpdate(fiber, update); const eventTime = requestEventTime(); const root = markUpdateLaneFromFiberToRoot(fiber, SyncLane); if (root !== null) { markRootUpdated(root, SyncLane, eventTime); ensureRootIsScheduled(root, eventTime); schedulePendingInteractions(root, SyncLane); } else { // 组件已经被卸载，为了错误不被吞掉，可以调用 log 边界 if ( typeof instance.componentDidCatch === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; !isAlreadyFailedLegacyErrorBoundary(instance) ) { try { instance.componentDidCatch(error, errorInfo); } catch (errorToIgnore) { // 边缘情况 } } } return; } } fiber = fiber.return; } } 参考 React 的组件类型 React Fiber 架构 React 技术揭秘 ","date":"2021-10-10T00:00:00Z","image":"https://vikingama.github.io/img/cover/react.png","permalink":"https://vikingama.github.io/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8B%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A0%81/","title":"React 复习笔记（下，基于源码）"},{"content":"多态 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果；给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈；多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 不变的部分 function makeSound(animal) { animal.sound(); } // 可变的部分，将行为分布在各个对象中，并让这些对象各自负责自己的行为 const Chicken = function () {}; const Duck = function () {}; Chicken.prototype.sound = function () { console.log(\u0026#39;咯咯咯\u0026#39;); }; Duck.prototype.sound = function () { console.log(\u0026#39;嘎嘎嘎\u0026#39;); }; makeSound(new Chicken()); // 咯咯咯 makeSound(new Duck()); // 嘎嘎嘎 面向接口编程 “在系统分析和架构中，分清层次和依赖关系；每个层次不是直接向其上层提供服务，而是通过定义一组接口，仅向上层暴露其接口功能；上层对于下层仅仅是接口依赖，而不依赖具体类”是设计模式中最重要的思想。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Duck { makeSound() { console.log(\u0026#39;嘎嘎嘎\u0026#39;); } } class Chicken { makeSound() { console.log(\u0026#39;咯咯咯\u0026#39;); } } class AnimalSound { makeSound(animal) { animal.makeSound(); } } const duck = new Duck(); const chicken = new Chicken(); const animalSound = new AnimalSound(); animalSound.makeSound(duck); // 嘎嘎嘎 animalSound.makeSound(chicken); // 咯咯咯 把客户的业务逻辑线提取出来，作为接口；业务具体实现通过该接口的实现类来完成；当客户需求变化时，只需编写该业务逻辑的新的实现类：\n降低程序的耦合性； 易于程序的扩展； 有利于程序的维护。 面向切面编程（AOP） 把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Function.prototype.before = function (beforeFn) { const originalFn = this; return function () { beforeFn.call(this, arguments); const originalResult = originalFn.call(this, arguments); return originalResult; }; }; Function.prototype.after = function (afterFn) { const originalFn = this; return function () { const originalResult = originalFn.call(this, arguments); afterFn.call(this, arguments); return originalResult; }; }; let fn = function () { console.log(\u0026#39;fn\u0026#39;); }; // before -\u0026gt; fn -\u0026gt; after fn = fn .before(function () { console.log(\u0026#39;before\u0026#39;); }) .after(function () { console.log(\u0026#39;after\u0026#39;); }); fn(); 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const Single = (function () { let instance; return function () { if (instance) { return instance; } instance = this; return instance; }; })(); console.log(new Single() === new Single()); // 创建全局唯一的登录弹窗 function getSingle(fn) { let instance; return function () { return instance || (instance = fn.apply(this, arguments)); }; } function LoginLayer() { const div = document.createElement(\u0026#39;div\u0026#39;); div.innerHTML = \u0026#39;登录\u0026#39;; div.style.display = \u0026#39;none\u0026#39;; document.body.appendChild(div); return div; } getSingle(LoginLayer)(); 策略模式 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const strategies = { S(salary) { return salary * 4; }, A(salary) { return salary * 3; }, B(salary) { return salary * 2; } }; const calculateBonus = function (level, salary) { return strategies[level](salary); }; console.log(calculateBonus(\u0026#39;S\u0026#39;, 20000)); 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句； 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作； 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的替代方案； 策略模式提供了对开放—封闭原则的完美支持，将算法独立封装，使得它们易于切换，易于理解，易于扩展。 代理模式 为一个对象提供一个代用品或占位符，以便控制对它的访问。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 使用虚拟代理懒加载图片 const myImage = (function () { const imgNode = document.createElement(\u0026#39;img\u0026#39;); document.body.appendChild(imgNode); return { setSrc(src) { imgNode.src = src; } }; })(); const proxyImage = (function () { const temp = new Image(); temp.onload = function () { myImage.setSrc(this.src); }; return { setSrc(src) { myImage.setSrc(\u0026#39;./loading.gif\u0026#39;); temp.src = src; } }; })(); proxyImage.setSrc( \u0026#39;https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png\u0026#39; ); 代理和本体接口的一致性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function syncFile(id) { console.log(`同步文件：${id}`); } const proxySyncFile = (function () { let temp = []; let timer; return function (id) { temp.push(id); if (timer) { return; } timer = setTimeout(() =\u0026gt; { syncFile(temp.join(\u0026#39;,\u0026#39;)); clearTimeout(timer); timer = null; temp = []; }, 2000); }; })(); 缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function mult() { let temp = 1; for (let i = 0; i \u0026lt; arguments.length; i++) { temp *= arguments[i]; } return temp; } const proxtMult = (function (fn) { const cache = {}; return function () { const key = [...arguments].join(\u0026#39;,\u0026#39;); if (!cache[key]) { cache[key] = fn.apply(this, arguments); } return cache[key]; }; })(mult); 迭代器模式 提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n1 2 3 4 5 6 7 function Iterator(o) { let current = 0; const next = () =\u0026gt; (current += 1); const isDone = () =\u0026gt; current \u0026gt;= o.length; const getCurrent = () =\u0026gt; o[current]; return [next, isDone, getCurrent]; } 发布订阅模式 可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const event = { clientList: {}, listen(key, fn) { this.clientList[key] ? this.clientList[key].push(fn) : (this.clientList[key] = [fn]); }, trigger(key, ...rest) { const fns = this.clientList[key]; if (Array.isArray(fns) \u0026amp;\u0026amp; fns.length \u0026gt; 0) { for (let i = 0; i \u0026lt; fns.length; i++) { fns[i].apply(this, rest); } } }, remove(key, fn) { const fns = this.clientList[key]; if (Array.isArray(fns) \u0026amp;\u0026amp; fns.length \u0026gt; 0) { const index = fns.findIndex(fn); this.clientList[key].splice(index, 1); } } }; 命令模式 命令指的是一个执行某些特定事情的指令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const btn1 = document.getElementById(\u0026#39;btn1\u0026#39;); const btn2 = document.getElementById(\u0026#39;btn2\u0026#39;); const btn3 = document.getElementById(\u0026#39;btn3\u0026#39;); const MenuBar = { refresh() { console.log(\u0026#39;refresh\u0026#39;); } }; const RefreshCommand = function (receiver) { return { execute() { receiver.refresh(); } }; }; const refreshMenuBarCommand = RefreshCommand(MenuBar); function setCommand(ele, command) { ele.onclick = function () { command.execute(); }; } setCommand(btn1, refreshMenuBarCommand); setCommand(btn2, refreshMenuBarCommand); setCommand(btn3, refreshMenuBarCommand); 组合模式 将对象组合成树形结构，以表示“部分 - 整体”的层次结构；通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 const openAcCommand = { add() { throw new Error(\u0026#39;add 无效\u0026#39;); }, execute() { console.log(\u0026#39;打开空调\u0026#39;); } }; const openTvCommand = { add() { throw new Error(\u0026#39;add 无效\u0026#39;); }, execute() { console.log(\u0026#39;打开电视\u0026#39;); } }; const openSoundCommand = { add() { throw new Error(\u0026#39;add 无效\u0026#39;); }, execute() { console.log(\u0026#39;打开音响\u0026#39;); } }; const openPcCommand = { add() { throw new Error(\u0026#39;add 无效\u0026#39;); }, execute() { console.log(\u0026#39;打开电脑\u0026#39;); } }; const closeDoorCommand = { add() { throw new Error(\u0026#39;add 无效\u0026#39;); }, execute() { console.log(\u0026#39;关门\u0026#39;); } }; function MacroCommand() { return { commandList: [], add(command) { this.commandList.push(command); }, execute() { for (var i = 0, command; (command = this.commandList[i++]); ) { command.execute(); } } }; } const macroCommand1 = MacroCommand(); macroCommand1.add(openTvCommand); macroCommand1.add(openSoundCommand); const macroCommand2 = MacroCommand(); macroCommand2.add(openPcCommand); macroCommand2.add(closeDoorCommand); const macroCommand = MacroCommand(); macroCommand.add(openAcCommand); macroCommand.add(macroCommand1); macroCommand.add(macroCommand2); macroCommand.execute(); 组合对象包含一组叶对象，但 Leaf 并不是 Composite 的子类；组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。\n组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。\n模板方法 由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类；通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序；子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。\n享元模式（flyweight） 运用共享技术来有效支持大量细粒度的对象；如果系统中因为创建了大量类似的对象而导致内存占用过高，享元模式就非常有用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Model(sex) { this.sex = sex; // 内部状态存储于对象内部，可以被一些对象共享，独立于具体的场景 } Model.prototype.takePhoto = function () { console.log(`sex: ${this.sex}, underwear: ${this.underwear}`); }; const maleModel = new Model(\u0026#39;male\u0026#39;); const femaleModel = new Model(\u0026#39;female\u0026#39;); for (let i = 0; i \u0026lt; 50; i++) { maleModel.underwear = `underwear${i}`; // 外部状态 maleModel.takePhoto(); } for (let j = 0; j \u0026lt; 50; j++) { femaleModel.underwear = `underwear${j}`; // 取决于具体的场景，并根据场景而变化，不能被共享 femaleModel.takePhoto(); } 实现享元模式的关键是把内部状态和外部状态分离开来，有多少种内部状态的组合，系统中便最多存在多少个共享对象；而外部状态储存在共享对象的外部，在必要时被传入共享对象来组装成一个完整的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const toopTipFactory = (function () { const toolTipPool = []; // toolTip 对象池 return { create() { if (toolTipPool.length === 0) { const div = document.createElement(\u0026#39;div\u0026#39;); document.body.appendChild(div); return div; } else { return toolTipPool.shift(); } }, recover(toolTipDom) { return toolTipPool.push(toolTipDom); } }; })(); 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系；将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止；我们把这些对象称为链中的节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 function Chain(fn) { this.fn = fn; this.successor = null; } Chain.prototype.setNextSuccessor = function (successor) { return (this.successor = successor); }; // 下一个节点 Chain.prototype.passRequest = function () { const ret = this.fn.apply(this, arguments); if (ret === \u0026#39;nextSuccessor\u0026#39;) { return ( this.successor \u0026amp;\u0026amp; this.successor.passRequest.apply(this.successor, arguments) ); } return ret; }; // 传递请求给某个节点 Chain.prototype.next = function () { return ( this.successor \u0026amp;\u0026amp; this.successor.passRequest.apply(this.successor, arguments) ); }; // 可以用来异步传递 function order500(orderType, pay, stock) { if (orderType === 1 \u0026amp;\u0026amp; pay \u0026amp;\u0026amp; stock \u0026gt; 0) { console.log(\u0026#39;500 元定金，返 100 元优惠券\u0026#39;); } else { return \u0026#39;nextSuccessor\u0026#39;; // 处理不了，传给下一个 } } function order200(orderType, pay, stock) { if (orderType === 2 \u0026amp;\u0026amp; pay \u0026amp;\u0026amp; stock \u0026gt; 0) { console.log(\u0026#39;200 元定金，返 50 元优惠券\u0026#39;); } else { return \u0026#39;nextSuccessor\u0026#39;; // 处理不了，传给下一个 } } function orderNormal(orderType, pay, stock) { if (stock \u0026gt; 0) { console.log(\u0026#39;无优惠券\u0026#39;); } else { console.log(\u0026#39;库存不足\u0026#39;); } } const chainOrder500 = new Chain(order500); const chainOrder200 = new Chain(order200); const chainOrderNormal = new Chain(orderNormal); chainOrder500.setNextSuccessor(chainOrder200); chainOrder200.setNextSuccessor(chainOrderNormal); chainOrder500.passRequest(1, true, 1000); chainOrder500.passRequest(2, true, 1000); chainOrder500.passRequest(3, true, 1000); chainOrder500.passRequest(1, true, 0); 职责链模式的最大优点就是解耦了请求发送者和 N 个接收者之间的复杂关系；由于不知道链中的哪个节点可以处理你发出的请求，所以你只需把请求传递给第一个节点即可。\n用 AOP 实现职责链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Function.prototype.after = function (fn) { const self = this; return function () { const ret = self.apply(this, arguments); if (ret === \u0026#39;nextSuccessor\u0026#39;) { return fn.apply(this, arguments); } return ret; }; }; const order = order500.after(order200).after(orderNormal); order(1, true, 1000); order(2, true, 1000); order(3, true, 1000); order(1, true, 0); 中介者模式 解除对象与对象之间的紧耦合关系；增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用；所以当一个对象发生改变时，只需要通知中介者对象即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 const playerDirector = (function () { const players = {}; // 保存所有玩家 const operations = {}; // 中介者可以执行的操作 operations.addPlayer = function (player) { const teamColor = player.teamColor; players[teamColor] = players[teamColor] || []; players[teamColor].push(player); }; operations.removePlayer = function (player) { const teamColor = player.teamColor; const teamPlayers = players[teamColor] || []; for (var i = teamPlayers.length - 1; i \u0026gt;= 0; i--) { if (teamPlayers[i] === player) { teamPlayers.splice(i, 1); } } }; operations.changeTeam = function (player, teamColor) { operations.removePlayer(player); player.teamColor = teamColor; operations.addPlayer(player); }; operations.playerDead = function (player) { const teamColor = player.teamColor; const teamPlayers = players[teamColor] || []; let allDead = true; player.state = \u0026#39;dead\u0026#39;; for (var i = 0, player; (player = teamPlayers[i++]); ) { if (player.state !== \u0026#39;dead\u0026#39;) { allDead = false; break; } } if (allDead === true) { // 全部死亡 for (var i = 0, player; (player = teamPlayers[i++]); ) { player.lose(); // 本队所有玩家 lose } for (var color in players) { if (color !== teamColor) { var otherTeamPlayers = players[color]; // 其他队伍的玩家 for (var i = 0, player; (player = otherTeamPlayers[i++]); ) { player.win(); // 其他队伍所有玩家 win } } } } }; return { reciveMessage(msg, ...rest) { operations[msg].apply(this, rest); } }; })(); function Player(name, teamColor) { this.name = name; this.state = \u0026#39;alive\u0026#39;; this.teamColor = teamColor; } Player.prototype.win = function () { console.log(`${this.name} won`); }; Player.prototype.lose = function () { console.log(`${this.name} lose`); }; Player.prototype.die = function () { this.state = \u0026#39;die\u0026#39;; // 给中介者发送“玩家死亡” playerDirector.reciveMessage(\u0026#39;playerDead\u0026#39;, this); }; Player.prototype.remove = function () { // 给中介者发送“移除玩家” playerDirector.reciveMessage(\u0026#39;removePlayer\u0026#39;, this); }; Player.prototype.changeTeam = function (teamColor) { // 给中介者发送“玩家换队” // this.teamColor = teamColor; playerDirector.reciveMessage(\u0026#39;changeTeam\u0026#39;, this, teamColor); }; function playerFactory(name, teamColor) { var player = new Player(name, teamColor); // 创造一个新的玩家对象 playerDirector.reciveMessage(\u0026#39;addPlayer\u0026#39;, player); // 给中介者发送消息，新增玩家 return player; } 中介者模式使各个对象之间得以解耦，以中介者和对象之间的一对多关系取代了对象之间的网状多对多关系；各个对象只需关注自身功能的实现，对象之间的交互关系交给了中介者对象来实现和维护。\n最大的缺点是系统中会新增一个中介者对象，因为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的；中介者对象自身往往就是一个难以维护的对象。\n装饰者模式 给对象动态地增加职责的方式称为装饰者模式；能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责；跟继承相比，装饰者是一种更轻便灵活的做法，这是一种“即用即付”的方式；他没有真正地改动对象自身，而是将对象放入另一个对象之中，这些对象以一条链的方式进行引用，形成一个聚合对象。\n状态模式 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变；状态模式的关键是把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function OffLightState(light) { this.light = light; } function WeakLightState() { this.light = light; } function StrongLightState() { this.light = light; } OffLightState.prototype.buttonWasPressed = function () { console.log(\u0026#39;关灯-\u0026gt;弱光\u0026#39;); this.light.setState(this.light.weakLightState); }; WeakLightState.prototype.buttonWasPressed = function () { console.log(\u0026#39;弱光-\u0026gt;强光\u0026#39;); this.light.setState(this.light.strongLightState); }; StrongLightState.prototype.buttonWasPressed = function () { console.log(\u0026#39;强光-\u0026gt;关灯\u0026#39;); this.light.setState(this.light.offLightState); }; function Light() { this.button = null; this.offLightState = new OffLightState(this); this.weakLightState = new WeakLightState(this); this.strongLightState = new StrongLightState(this); } Light.prototype.setState = function (state) { this.currentState = state; }; Light.prototype.init = function () { const button = document.createElement(\u0026#39;button\u0026#39;); const self = this; this.button = document.body.appendChild(button); this.button.innerHTML = \u0026#39;开关\u0026#39;; this.currentState = this.offLightState; this.button.onclick = function () { self.currentState.buttonWasPressed(); }; }; 状态模式定义了状态与行为之间的关系，并将它们封装在一个类里；通过增加新的状态类，很容易增加新的状态和转换； 避免 Context 无限膨胀，状态切换的逻辑被分布在状态类中； 用对象代替字符串来记录当前状态，使得状态的切换更加一目了然； Context 中的请求动作和状态类中封装的行为可以非常容易地独立变化而互不影响。 状态模式的缺点是会在系统中定义许多状态类，编写多个状态类是一项枯燥乏味的工作，而且系统中会因此而增加不少对象；由于逻辑分散在状态类中，虽然避开了条件分支语句，但也造成了逻辑分散的问题；我们无法在一个地方就看出整个状态机的逻辑。\n适配器模式 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化；适配器模式不需要改变已有的接口，就能够使它们协同作用。\n","date":"2021-07-27T00:00:00Z","image":"https://vikingama.github.io/img/cover/patterns.png","permalink":"https://vikingama.github.io/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E7%AC%94%E8%AE%B0/","title":"《设计模式与开发实践》笔记"},{"content":"monorepo 公司的主要业务是混合云管，所以除了官网这种 ToC 的项目之外，其余均是 ToB 的管理后台项目；根据具体业务分为了：容器服务、镜像管理、服务商监控、应用管理等等。这些子项目有统一的 UI 风格、相近的交互逻辑、耦合的业务逻辑；所以非常适合 monorepo 的项目管理方式。\nLerna 是前端 monorepo 比较好的解决方案，搭配 yarn 可以非常好的管理项目外部与项目之间的依赖。每个项目都是一个独立的 package，每个 package 都有自己的 workspace，可以将自己的 APIs 通过 lib 暴露并 publish 到内部 npm 仓库，这样每个 package 既是独立的项目也是其他 package 的依赖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // lerna.json { \u0026#34;packages\u0026#34;: [ \u0026#34;packages/@cli/*\u0026#34;, // 脚手架依赖，放置 linters 规则和配置 \u0026#34;packages/@common/*\u0026#34;, // 公共依赖，放置工具函数和组件 \u0026#34;packages/@project/*\u0026#34; // 业务代码，放置具体的业务实现 ], \u0026#34;version\u0026#34;: \u0026#34;independent\u0026#34;, // 独立模式，每个 package 有独立的版本号 \u0026#34;useWorkspaces\u0026#34;: true, // 启用 workspace 模式 \u0026#34;npmClient\u0026#34;: \u0026#34;yarn\u0026#34;, // 使用 yarn 取代 npm \u0026#34;command\u0026#34;: { \u0026#34;publish\u0026#34;: { \u0026#34;ignoreChanges\u0026#34;: [\u0026#34;ignored-file\u0026#34;, \u0026#34;*.temp\u0026#34;, \u0026#34;*.md\u0026#34;], // 不会包含在更改/发布中的文件，防止为不必要地更改发布新版本，例如修复 ReadMe 拼写错误 \u0026#34;message\u0026#34;: \u0026#34;chore(release): publish\u0026#34;, // 发布新版本时，自定义的提交消息 \u0026#34;registry\u0026#34;: \u0026#34;https://npm.pkg.github.com\u0026#34;, // 包发在哪里，一般是公司内部的 npm 服务器 \u0026#34;conventionalCommits\u0026#34;: true // 自动生成 ChangeLog }, \u0026#34;bootstrap\u0026#34;: { \u0026#34;ignore\u0026#34;: \u0026#34;component-*\u0026#34;, \u0026#34;npmClientArgs\u0026#34;: [\u0026#34;--no-package-lock\u0026#34;, \u0026#34;--production\u0026#34;] } } } // package.json { \u0026#34;name\u0026#34;: \u0026#34;lerna\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;workspaces\u0026#34;: [ \u0026#34;packages/@cli/*\u0026#34;, \u0026#34;packages/@common/*\u0026#34;, \u0026#34;packages/@project/*\u0026#34; ], // ... } Lerna 两种模式：\n固定模式，项目统一单个版本（所有的包使用一个版本号，Babel 使用的这种模式），版本信息保存在根目录下的 lerna.json 中；如果主版本号为 0，任何更新都将被视为不兼容更新； 独立模式，每个包的版本号是独立的（公司使用的这种模式，因为每个包是一个独立的项目、不是一个完整功能的一部分）；发包时，需要指定此次更新的粒度（修复、小版本、大版本？）。 Lerna 常用命令：\nlerna init 创建/升级为 Lerna 仓库； \u0026ndash;independent/-i 使用独立的版本控制模式 lerna bootstrap 进入引导流程，安装所有依赖并链接交叉依赖； lerna create [name] [loc] 创建新的包，名字为 name，位置在 loc； lerna import [pathToRepo] 导入本地路径中的 repo 并提交 commit； lerna exec \u0026ndash; [command] [..args] 对每个包中执行任意命令； \u0026ndash; rm -rf ./node_modules 删除每个包下的 node_modules lerna publish 发布自上次发布之后有更新的包（private 为 true 的除外），提示“输入新版本号”并更新 git 和 npm 上的所有包； \u0026ndash;force-publish [packages] 强制发布“一个、多个（以逗号分隔）或全部（*）”软件包 \u0026ndash;npm-tag [tagname] — 使用给定的 npm dist-tag（默认 latest）发布到 npm \u0026ndash;canary/-c 创建一个 canary 版本 \u0026ndash;skip-git 不运行 git 命令 lerna changed 检查自上次发布以来哪些软件包被修改过； lerna clean 移除所有包的 node_modules 目录（不会移除根目录的 node_modules，即使加上 \u0026ndash;hoist 参数）； lerna diff [package?] 列出所有或某个软件包自上次发布以来的修改情况； lerna info 打印本地环境信息； lerna run [script] 在每一个包含 [script] 脚本的包中运行此 NpmScript； lerna run build\u0026ndash;concurrency 5 对所有包进行打包，最大并行数为 5 lerna list/ls 列出当前 Lerna 仓库中的所有公共软件包； \u0026ndash;json 以 Array JSON 的形式输出 \u0026ndash;ndjson 以 Newline Delimited JSON 的形式输出 \u0026ndash;all 列出 private 为 true 的包（默认不输出） \u0026ndash;long 展示更多信息 \u0026ndash;parseable 展示可解析输出，而不是列化视图 \u0026ndash;toposort 按拓扑顺序进行排序输出 \u0026ndash;graph 以图的形式输出 lerna link 为所有依赖彼此的包软连接在一起。 lerna link convert 将公用的 devDependencies 放到根目录的 package.json commit 对于需要多人维护的复杂项目，相同的代码样式和具体的提交信息是必要的；借助 husky 和 lint-staged（相似的工具还有 pretty-quick，不过只能调用 Prettier，不能调用 Lints），可以对待提交的文件进行校验、格式化，也可以对 commit message 进行约束。\n提交工作流钩子 pre-commit：在提交信息前运行；它用于检查即将提交的快照；例如，检查是否有所遗漏，确保测试运行，以及核查代码；不过你可以用 git commit \u0026ndash;no-verify 来绕过这个环节。你可以利用该钩子来检查代码风格是否一致（运行类似 lint 的程序）等； prepare-commit-msg：在启动提交信息编辑器之前，默认信息被创建之后运行；它允许你编辑提交者所看到的默认信息。它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用； commit-msg：接收一个参数（存有当前提交信息的临时文件的路径）。可以用来在提交通过前验证项目状态或提交信息； post-commit：在整个提交过程完成后运行；该钩子一般用于通知之类的事情。 workspace 信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 const { execSync } = require(\u0026#39;child_process\u0026#39;); // 将 yarn workspaces info 输出为对象 const getWorkspacesInfo = () =\u0026gt; { let temp; try { const yarnStdout = execSync(\u0026#39;yarn workspaces info\u0026#39;, { encoding: \u0026#39;utf8\u0026#39; }) .replace(/^yarn workspaces.*$/m, \u0026#39;\u0026#39;) .replace(/^Done.*$/m, \u0026#39;\u0026#39;) .replace(/\\n/g, \u0026#39;\u0026#39;); temp = JSON.parse(yarnStdout); } catch (error) { throw new Error( `执行 yarn workspaces info 命令时出错，具体如下：\\n${error}` ); } if (Object.prototype.toString.call(temp) !== \u0026#39;[object Object]\u0026#39;) { return {}; } return temp; }; const getWorkspaces = () =\u0026gt; { let temp; try { temp = getWorkspacesInfo(); } catch (error) { throw new Error(`获取不到 workspaces 信息。\\n${error}`); } if (Object.prototype.toString.call(temp) !== \u0026#39;[object Object]\u0026#39;) { return []; } return Object.keys(temp).map(name =\u0026gt; ({ name, ...temp[name] })); }; const getWorkspacesName = () =\u0026gt; { let temp; try { temp = getWorkspacesInfo(); } catch (error) { throw new Error(`获取不到 workspaces name 信息。\\n${error}`); } if (Object.prototype.toString.call(temp) !== \u0026#39;[object Object]\u0026#39;) { return []; } return Object.keys(temp); }; exports.getWorkspaces = getWorkspaces; exports.getWorkspacesInfo = getWorkspacesInfo; exports.getWorkspacesName = getWorkspacesName; git 信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const { execSync } = require(\u0026#39;child_process\u0026#39;); const { getWorkspacesName } = require(\u0026#39;./workspace\u0026#39;); // 获取当前所在 git 分支 const getCurrentBranch = () =\u0026gt; { try { const gitStatus = execSync(\u0026#39;git status\u0026#39;, { encoding: \u0026#39;utf8\u0026#39; }); return gitStatus.split(\u0026#39;\\n\u0026#39;)[0].replace(\u0026#39;On branch \u0026#39;, \u0026#39;\u0026#39;); } catch (error) { throw new Error(`执行 git 命令时出错，具体如下：\\n${error.toString()}`); } }; const getCommitScopes = () =\u0026gt; { const temp = getWorkspacesName(); if (Array.isArray(temp)) { return temp.map(name =\u0026gt; name.charAt(0) === \u0026#39;@\u0026#39; ? name.split(\u0026#39;/\u0026#39;)[1] : name ); } return []; }; exports.getCurrentBranch = getCurrentBranch; exports.getCommitScopes = getCommitScopes; stylelint 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 module.exports = { defaultSeverity: \u0026#39;error\u0026#39;, extends: [ \u0026#39;stylelint-config-standard\u0026#39;, \u0026#39;stylelint-config-rational-order\u0026#39;, \u0026#39;stylelint-config-prettier\u0026#39; ], ignoreDisables: true, ignoreFiles: [\u0026#39;**/*.json\u0026#39;], plugins: [ \u0026#39;stylelint-declaration-block-no-ignored-properties\u0026#39;, \u0026#39;stylelint-declaration-strict-value\u0026#39;, \u0026#39;stylelint-scss\u0026#39; ], rules: { \u0026#39;at-rule-no-unknown\u0026#39;: null, \u0026#39;scss/at-rule-no-unknown\u0026#39;: true, \u0026#39;plugin/declaration-block-no-ignored-properties\u0026#39;: true, \u0026#39;scale-unlimited/declaration-strict-value\u0026#39;: [ [\u0026#39;/color$/\u0026#39;, \u0026#39;z-index\u0026#39;], { ignoreKeywords: { \u0026#39;/color$/\u0026#39;: [\u0026#39;currentColor\u0026#39;, \u0026#39;inherit\u0026#39;, \u0026#39;transparent\u0026#39;], \u0026#39;z-index\u0026#39;: [\u0026#39;auto\u0026#39;] }, disableFix: true } ] } }; eslint 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 module.exports = { globals: { __PRERENDER__INJECTED__: \u0026#39;readonly\u0026#39;, __PROJECT__: \u0026#39;readonly\u0026#39; }, env: { browser: true, node: true }, extends: [ \u0026#39;airbnb-base\u0026#39;, // 剔除 react 规则 的 eslint-config-airbnb \u0026#39;plugin:vue/essential\u0026#39;, // vue 2.x 规则 \u0026#39;plugin:promise/recommended\u0026#39;, // promise 规则 \u0026#39;plugin:markdown/recommended\u0026#39;, // markdown 规则 \u0026#39;plugin:prettier/recommended\u0026#39; // prettier 冲突规则 ], plugins: [\u0026#39;html\u0026#39;], root: true, // 根配置 rules: { \u0026#39;import/prefer-default-export\u0026#39;: \u0026#39;off\u0026#39;, // 不强制使用默认导出 \u0026#39;no-param-reassign\u0026#39;: [ \u0026#39;error\u0026#39;, { props: false // 禁止对函数参数进行重新赋值，形参属性除外 } ], \u0026#39;no-plusplus\u0026#39;: [ \u0026#39;error\u0026#39;, { allowForLoopAfterthoughts: true // 允许在 for 循环中使用 ++ } ], \u0026#39;no-restricted-syntax\u0026#39;: [\u0026#39;error\u0026#39;, \u0026#39;WithStatement\u0026#39;], // 可以使用函数表达式和 in 操作符号，不能用 with \u0026#39;no-shadow\u0026#39;: [ \u0026#39;error\u0026#39;, { allow: [\u0026#39;state\u0026#39;, \u0026#39;series\u0026#39;] // 禁止变量声明与外层作用域的变量同名 } ], \u0026#39;no-underscore-dangle\u0026#39;: \u0026#39;off\u0026#39;, // 标识符中可以有下划线 \u0026#39;no-unused-expressions\u0026#39;: [ \u0026#39;error\u0026#39;, { allowShortCircuit: true // 允许在表达式中使用逻辑短路求值 } ], \u0026#39;no-use-before-define\u0026#39;: [ \u0026#39;error\u0026#39;, { functions: false // 禁止在变量定义之前使用它们，函数声明除外 } ], \u0026#39;prefer-destructuring\u0026#39;: [ \u0026#39;error\u0026#39;, // 不强制使用数组解构 { array: false, object: true } ], \u0026#39;promise/always-return\u0026#39;: \u0026#39;off\u0026#39;, // then 方法可以没有返回值 \u0026#39;promise/catch-or-return\u0026#39;: [ \u0026#39;error\u0026#39;, { allowFinally: true // 允许使用 finally } ], \u0026#39;vue/require-default-prop\u0026#39;: \u0026#39;off\u0026#39;, // 不要求 prop 有默认值 \u0026#39;vue/require-prop-types\u0026#39;: \u0026#39;off\u0026#39; // 不要求必须规定 prop 类型 } }; prettier 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;arrowParens\u0026#34;: \u0026#34;avoid\u0026#34;, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;embeddedLanguageFormatting\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;endOfLine\u0026#34;: \u0026#34;lf\u0026#34;, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;strict\u0026#34;, \u0026#34;jsxBracketSameLine\u0026#34;: true, \u0026#34;jsxSingleQuote\u0026#34;: true, \u0026#34;printWidth\u0026#34;: 120, \u0026#34;proseWrap\u0026#34;: \u0026#34;preserve\u0026#34;, \u0026#34;quoteProps\u0026#34;: \u0026#34;consistent\u0026#34;, \u0026#34;semi\u0026#34;: false, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;tabWidth\u0026#34;: 2, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;useTabs\u0026#34;: false, \u0026#34;vueIndentScriptAndStyle\u0026#34;: true } husky 配置 .husky/commit-msg 钩子：\n1 2 3 4 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npx --no-install commitlint --edit \u0026#34;$1\u0026#34; .husky/pre-commit 钩子：\n1 2 3 4 #!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npx lint-staged commitlint 配置 commitlint.rules:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function customSubjectActionEnum({ subject }, when = \u0026#39;never\u0026#39;, value = []) { const always = when === \u0026#39;always\u0026#39;; if (!always) { return [true]; } if ( typeof subject !== \u0026#39;string\u0026#39; || (typeof subject === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; subject.length === 0) ) { return [false, `提交的简要描述不能为空`]; } const action = subject.slice(0, 2); if (!value.find(item =\u0026gt; action === item)) { return [ false, `提交的简要描述应该以中文动词加一个空格起头，动词可选值为 [${value}]，当前值为 \u0026#39;${action}\u0026#39;` ]; } if (!subject.startsWith(`${action} `) || subject.slice(3, 4) === \u0026#39; \u0026#39;) { return [false, `提交的简要描述中动词后需且仅需添加一个空格`]; } return [true]; } function customScopeEnum({ scope }, when = \u0026#39;never\u0026#39;, value = []) { const always = when === \u0026#39;always\u0026#39;; if (!always) { return [true]; } return [ value.find(item =\u0026gt; scope === item), `scope 必须为 [${value}] 其中之一，当前为 ${scope}` ]; } module.exports = { \u0026#39;custom-subject-action-enum\u0026#39;: customSubjectActionEnum, \u0026#39;custom-scope-enum\u0026#39;: customScopeEnum }; commitlint.config:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 const { getCommitScopes } = require(\u0026#39;./git\u0026#39;); const rules = require(\u0026#39;./commitlint.rules\u0026#39;); const commitScopes = getCommitScopes(); /* * type(scope?): subject * body? * footer? */ module.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], plugins: [ { rules } ], /* * Level-[0.1.2]: 0-disables、1-warning、2-error * Applicable-always|never: never-inverts the rule * Value: value to use for this rule */ rules: { \u0026#39;body-full-stop\u0026#39;: [0], \u0026#39;body-leading-blank\u0026#39;: [2, \u0026#39;always\u0026#39;], \u0026#39;body-empty\u0026#39;: [0], \u0026#39;body-max-length\u0026#39;: [2, \u0026#39;always\u0026#39;, 144], \u0026#39;body-max-line-length\u0026#39;: [0], \u0026#39;body-min-length\u0026#39;: [0], \u0026#39;body-case\u0026#39;: [0], \u0026#39;footer-leading-blank\u0026#39;: [2, \u0026#39;always\u0026#39;], \u0026#39;footer-empty\u0026#39;: [0], \u0026#39;footer-max-length\u0026#39;: [0], \u0026#39;footer-max-line-length\u0026#39;: [2, \u0026#39;always\u0026#39;, 1], \u0026#39;footer-min-length\u0026#39;: [0], \u0026#39;header-case\u0026#39;: [0], \u0026#39;header-full-stop\u0026#39;: [0], \u0026#39;header-max-length\u0026#39;: [0], \u0026#39;header-min-length\u0026#39;: [0], \u0026#39;references-empty\u0026#39;: [0], \u0026#39;scope-enum\u0026#39;: [0], \u0026#39;scope-case\u0026#39;: [2, \u0026#39;always\u0026#39;, \u0026#39;lower-case\u0026#39;], \u0026#39;scope-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], \u0026#39;scope-max-length\u0026#39;: [0], \u0026#39;scope-min-length\u0026#39;: [0], \u0026#39;subject-case\u0026#39;: [0], \u0026#39;subject-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], \u0026#39;subject-full-stop\u0026#39;: [0], \u0026#39;subject-max-length\u0026#39;: [0], \u0026#39;subject-min-length\u0026#39;: [2, \u0026#39;always\u0026#39;, 5], \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [\u0026#39;build\u0026#39;, \u0026#39;ci\u0026#39;, \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;st\u0026#39;, \u0026#39;sit\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;version\u0026#39;] ], \u0026#39;type-case\u0026#39;: [2, \u0026#39;always\u0026#39;, \u0026#39;lower-case\u0026#39;], \u0026#39;type-empty\u0026#39;: [2, \u0026#39;never\u0026#39;], \u0026#39;type-max-length\u0026#39;: [0], \u0026#39;type-min-length\u0026#39;: [0], \u0026#39;signed-off-by\u0026#39;: [0], \u0026#39;custom-subject-action-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;添加\u0026#39;, \u0026#39;完善\u0026#39;, \u0026#39;修复\u0026#39;, \u0026#39;解决\u0026#39;, \u0026#39;删除\u0026#39;, \u0026#39;禁用\u0026#39;, \u0026#39;修改\u0026#39;, \u0026#39;调整\u0026#39;, \u0026#39;优化\u0026#39;, \u0026#39;重构\u0026#39;, \u0026#39;发布\u0026#39;, \u0026#39;合并\u0026#39; ] ], \u0026#39;custom-scope-enum\u0026#39;: [2, \u0026#39;always\u0026#39;, [\u0026#39;root\u0026#39;, ...commitScopes]] } }; commitizen 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 const { getCommitScopes } = require(\u0026#39;./git\u0026#39;); const scopes = getCommitScopes(); module.exports = { subjectLimit: 72, subjectSeparator: \u0026#39;: \u0026#39;, typePrefix: \u0026#39;\u0026#39;, typeSuffix: \u0026#39;\u0026#39;, scopes: [{ name: \u0026#39;root\u0026#39; }, ...scopes.map(name =\u0026gt; ({ name }))], scopeOverrides: {}, allowCustomScopes: false, allowBreakingChanges: [\u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;st\u0026#39;, \u0026#39;sit\u0026#39;], skipQuestions: [], appendBranchNameToCommitMessage: false, // ticketNumberPrefix: \u0026#39;\u0026#39;, // breakingPrefix: \u0026#39;\u0026#39;, // footerPrefix: \u0026#39;\u0026#39;, breaklineChar: \u0026#39;|\u0026#39;, upperCaseSubject: false, askForBreakingChangeFirst: false, types: [ { name: \u0026#39;build: 涉及构建系统及与其相关的外部依赖变动\u0026#39;, value: \u0026#39;build\u0026#39; }, { name: \u0026#39;ci: 涉及 CI 配置文件或脚本修改的变动\u0026#39;, value: \u0026#39;ci\u0026#39; }, { name: \u0026#39;feat: 增加了新的功能特征，对应 action 只能为“添加”\u0026#39;, value: \u0026#39;feat\u0026#39; }, { name: \u0026#39;fix: 修复 bug，对应 action 只能为“修复”\u0026#39;, value: \u0026#39;fix\u0026#39; }, { name: \u0026#39;st: 解决 ST 单子，仅限 release 分支，对应 action 只能为“修复”\u0026#39;, value: \u0026#39;st\u0026#39; }, { name: \u0026#39;sit: 解决 SIT 单子，仅限 release 分支，对应 action 只能为“修复”\u0026#39;, value: \u0026#39;sit\u0026#39; }, { name: \u0026#39;style: 不影响代码含义的风格修改，比如空格、格式化、缺失的分号等，对应 action 只能为“调整”\u0026#39;, value: \u0026#39;style\u0026#39; }, { name: \u0026#39;version: 发布版本，一般由脚本自动化发布，对应 action 只能为“发布”\u0026#39;, value: \u0026#39;version\u0026#39; } ], messages: { type: \u0026#39;选择本次更改的提交类型：\\n\u0026#39;, scope: \u0026#39;选择本次更改涉及模块：\\n\u0026#39;, subject: \u0026#39;输入针对本次更改的简要说明：\\n\u0026#39;, body: \u0026#39;输入针对本次更改的详细描述（非必须），使用\u0026#34; | \u0026#34;进行换行，每行长度不要超过 72: \\n\u0026#39;, // 这里有问题 breaking: \u0026#39;如果本次更改存在不兼容的修改，则须对更改的内容进行详细描述，否则无需填写：\\n\u0026#39;, footer: \u0026#39;列举本次更改对应的 Tapd 缺陷 ID（比如 #31、#34）: \\n\u0026#39;, confirmCommit: \u0026#39;是否使用以上提交信息进行提交？\u0026#39; } }; package.json 对应配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;lint-staged\u0026#34;: { \u0026#34;**/*.{js,ts,vue,htm,html,md}\u0026#34;: \u0026#34;eslint --format=codeframe\u0026#34;, \u0026#34;**/*.{css,scss,sass,vue}\u0026#34;: \u0026#34;stylelint --formatter verbose\u0026#34;, \u0026#34;**/*\u0026#34;: \u0026#34;prettier --check\u0026#34; }, \u0026#34;config\u0026#34;: { \u0026#34;commitizen\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;cz-customizable\u0026#34; } }, \u0026#34;scripts\u0026#34;: { \u0026#34;commit\u0026#34;: \u0026#34;git add . \u0026amp;\u0026amp; cz\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write .\u0026#34;, \u0026#34;eslint:fix\u0026#34;: \u0026#34;eslint --fix . --ext .js,.ts,.vue,.htm,.html,.md\u0026#34;, \u0026#34;stylelint:fix\u0026#34;: \u0026#34;stylelint --fix **/*.{css,scss,sass,vue}\u0026#34;, } // ... } 整个提交流程 注意：git add . 相比 git add \u0026ndash;all，不处理删除文件；仅提交当前目录或者后代目录下的文件。\nverdaccio 私有仓库使用 Verdaccio 搭建并使用 pm2 守护（找运维小哥）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 安装 wget yum install -y wget # 下载 node wget https://nodejs.org/dist/v10.6.0/node-v10.6.0-linux-x64.tar.xz # 解压 node tar -xvf node-v10.6.0-linux-x64.tar.xz # 重命名安装目录 mv node-v10.6.0-linux-x64.tar.xz nodejs # 建立软连接 ln -s /usr/local/node/nodejs/bin/npm /usr/local/bin ln -s /usr/local/node/nodejs/bin/node /usr/local/bin # 安装 verdaccio npm install -g verdaccio # 建立软连接 ln -s /usr/local/node/nodejs/bin/verdaccio /usr/local/bin # 安装 pm2 npm install -g pm2 # 建立软连接 ln -s /usr/local/node/nodejs/bin/pm2 /usr/local/bin # 使用 pm2 运行 verdaccio pm2 start verdaccio 配置 .npmrc、.yarnrc：\n1 registry \u0026#34;http://npm.inner.com/\u0026#34; 配置 package.json：\n1 2 3 4 5 6 { \u0026#34;publishConfig\u0026#34;: { \u0026#34;registry\u0026#34;: \u0026#34;http://npm.inner.com/\u0026#34; } // ... } 安装依赖时，会向私服请求 package，如果找不到，服务器就会向 npmjs.org 请求并缓存。\nrequest 后端数据会通过无渲染组件请求，组件通过 props 接受请求参数，再将返回数据通过作用域插槽暴露。\nRlApiRequest 的 render 函数返回了 $scopedSlots.default(this.cSlotScopeProps)；继承了 RlApiRequest 的组件通过传入不同的 props 和 aSlotScopeProps（会改写 cSlotScopeProps），达到不同的目的。\npipes 对于数据的处理都会交给管道层，组件通过 props 接受原始数据，处理过的数据通过默认的作用域插槽返回。\n多个 pipe 共同组成了 pipes 总管道，通过传入 enablePipeFormat、enablePipeFilter 等 props 控制对应管道的开闭；本质上是作用域插槽的应用。\n","date":"2021-07-19T00:00:00Z","image":"https://vikingama.github.io/img/cover/engineering.png","permalink":"https://vikingama.github.io/p/%E5%81%B7%E5%B8%88%E5%AD%A6%E8%89%BA/","title":"偷“师”学“艺”"},{"content":"SEO 就是让搜索引擎了解网站，在用户进行关键词搜索时，网站能出现在搜索结果中比较靠前的位置。\n搜索引擎如何工作 找出存在的网页：跟踪已知网页上的链接、与网站托管服务合作、站长提交站点地图； 编入索引：解析网页内容并构建搜索索引，网页的标题、关键词和描述可以改善编入效果； 呈现：根据搜索内容和其他因素（位置、语言、设备等）从索引中找到最相关的信息返回给用户； 排名：提高网页加载速度并保持一定的更新频率有利于网站排名。 搜索引擎蜘蛛 蜘蛛是搜索引擎抓用来页面信息和构建信息索引的工具，例如： Baiduspider 和 Googlebot ；蜘蛛在访问页面的过程中，处理文字内容、关键内容标记和属性，例如网站标题、Alt 属性、图片、视频等；此外，蜘蛛还会查找页面上的链接，并将这些链接添加到它要抓取的网页的列表中；这张列表记录着新建立的网站、对现有网站进行的更改以及无效链接，并据此更新索引。\n百度曾发布过一个 公告 ，提到 Baiduspider 会访问页面的 CSS、JS 和图片资源，但是 JS 会不会执行、JS 的执行结果会不会被编入索引则没有明说；Google 在 文档 中指出：Googlebot 支持对 SPA 和动态内容的抓取，在抓取过程中会使用 Chrome 加载网页并运行 JS。\n显然，搜索引擎更喜欢“有内容的”HTML。\nSPA 如何产生“有内容的”HTML 预渲染 在客户端访问之前提前渲染好 HTML（一般是在打包阶段）；在客户端初次访问页面时，会从静态服务器请求事先渲染好的 HTML；之后 JS 会接管交互、渲染和路由等工作；这是一种混合模式，从客户端来看，页面的行为就像 SPA 一样。\n优点：\n更好的 SEO，爬虫可以直接抓取页面内容； 更快的（非用户相关内容的）首屏渲染。 缺点：\n无法实时更新静态服务器端 HTML 的内容（除非在数据发生变动时重新打包部署）； 无法用于不可穷举的动态路由场景； 不支持哈希路由。 服务端同构渲染 在客户端发起请求时实时渲染 HTML，服务端总会请求最新的数据完成渲染；加载完第一个页面之后，客户端还是会进入 JS 渲染的模式（混合渲染，例如：Nuxt 和 Next）；这种方式和预渲染模式的差别在于渲染 HTML 的时机不同。\n优点：\n更好的 SEO，爬虫可以直接抓取页面内容； 更快的首屏渲染。 缺点：\n需要动态服务，不能 CDN 部署，有可能出现服务只能部署在 A 地，但用户却在 B 地的情况； 不是所有的开发依赖都支持在服务端运行； 动态服务器比静态服务器更耗资源； 客户端与服务端的状态同步； 不支持哈希路由。 基于 UA 的动态渲染 Google 搜索中心提到的一种模式，根据 UA 判断，客户端是不是“蜘蛛”；蜘蛛访问的是渲染之后（不一定是动态渲染）的 HTML，普通用户访问的还是一个 SPA。这种模式将客户端分为“用户”和“蜘蛛”两种，可以减轻服务器压力、对搜索引擎抓取的内容进行针对性的优化。\n预渲染配置 通过 HtmlWebpackPlugin 配置项目 TWD：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const title = \u0026#39;我是标题...\u0026#39;; const meta = { keywords: \u0026#39;我是，关键词，...\u0026#39;, description: \u0026#39;我是描述...\u0026#39; }; module.exports = { plugins: [ new HtmlWebpackPlugin({ entry: \u0026#39;src/project/home/main.js\u0026#39;, template: \u0026#39;public/main.html\u0026#39;, filename: \u0026#39;index.html\u0026#39;, chunks: [\u0026#39;chunk-vendors\u0026#39;, \u0026#39;chunk-common\u0026#39;, \u0026#39;home\u0026#39;], title, meta }) ] }; 配置 main.js 触发预渲染事件：\n1 2 3 4 5 6 7 8 9 new Vue({ el: \u0026#39;#app\u0026#39;, router, store, render: h =\u0026gt; h(App), mounted() { document.dispatchEvent(new Event(\u0026#39;render-event\u0026#39;)); } }); 预渲染完成之后，根结点会被替换掉；需要在项目根组件添加对应的 id，否则会报“Cannot find element: #xxx”错误：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; class=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;top-header :isHome=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;router-view\u0026#34;\u0026gt; \u0026lt;transition name=\u0026#34;rv\u0026#34;\u0026gt; \u0026lt;router-view /\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;bottom-footer /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 引入 PrerenderSPAPlugin 插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 const PrerenderSPAPlugin = require(\u0026#39;prerender-spa-plugin\u0026#39;); const Renderer = PrerenderSPAPlugin.PuppeteerRenderer; module.exports = { plugins: [ // 在非开发环境下执行 !process.env.LOCAL_DEVELOP \u0026amp;\u0026amp; new PrerenderSPAPlugin({ // 打包输出目录，也可以配置 outputDir 将预渲染文件输出到单独的目录 staticDir: path.join(__dirname, \u0026#39;dist\u0026#39;), // 对输出的 HTML 压缩配置（html-minifier） minify: { collapseBooleanAttributes: true, removeEmptyAttributes: false, removeComments: true, minifyCSS: true, minifyJS: true }, // 渲染器配置 renderer: new Renderer({ // 挂载在 window 上属性 injectProperty: \u0026#39;__PRERENDER__INJECTED__\u0026#39;, // 挂载在 window.__PRERENDER__INJECTED__ 的对象 inject: { hostname: prerenderHostname() }, // 是否显示浏览器（多用于调试，开启之后部分打包环境会打包失败） headless: true, // 在预渲染之前等待的时间 renderAfterTime: 500, // 最多同时渲染多少个路由 maxConcurrentRoutes: 1, // 触发渲染的事件名称 renderAfterDocumentEvent: \u0026#39;render-event\u0026#39;, // 浏览器运行参数 args: [\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;] }), // 请求代理配置 proxy: { \u0026#39;^/api/exp\u0026#39;: { target: \u0026#39;https://www.example.com\u0026#39; }, changeOrigin: true }, // 要预渲染的路由 routes: [ \u0026#39;/\u0026#39;, \u0026#39;/introduction/service-one\u0026#39;, \u0026#39;/introduction/service-two\u0026#39;, \u0026#39;/solution/way-one\u0026#39;, \u0026#39;/solution/way-two\u0026#39;, \u0026#39;/support/ask\u0026#39;, \u0026#39;/about/us\u0026#39; ] }) ] }; 为了 SEO，你可能需要 extract-text-webpack-plugin 将样式单独打包；减少 HTML 中的无语意字符。\nPrerenderSPAPlugin 逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 function PrerenderSPAPlugin(...args) { // 对入参做处理 this._options = args[0] || {}; } PrerenderSPAPlugin.prototype.apply(compiler =\u0026gt; { // apply 方法在安装插件时，会被 Webpack 编译器调用一次，在异步操作完成之后调用 callback const afterEmit = (compilation, callback) =\u0026gt; { // Prerenderer 会开启 express 服务器和 puppeteer 实例 const prender = new Prerenderer(this._options); prender .initialize() // express 会代理静态目录，通过 puppeteer 访问页面并将页面保存 .then(() =\u0026gt; prender.renderRoutes(this._options.routes || [])) .then(renderedRoutes =\u0026gt; { /** * [{ * originalRoute: route, * route: await page.evaluate(\u0026#39;window.location.pathname\u0026#39;), * html: await page.content() * }, {...}...] */ const isValid = renderedRoutes.every(r =\u0026gt; typeof r === \u0026#39;object\u0026#39;); if (isValid) { return renderedRoutes; } else { throw new Error(\u0026#39;...\u0026#39;); } }) .then(renderedRoutes =\u0026gt; { if (this._options.minify) { // minify... return renderedRoutes; } return renderedRoutes; }) .then(renderedRoutes =\u0026gt; Promise.all( renderedRoutes.map( renderedRoute =\u0026gt; new Promise((resolve, reject) =\u0026gt; { // write files... resolve(); }) ) ) ) .then(() =\u0026gt; { // 完成文件写入之后退出 prender.destory(); callback(); }) .catch(error =\u0026gt; { prender.destory(); // 如果有报错，在编译过程抛出 compilation.errors.push(new Error(error)); callback(); }); }; const plugin = { name: \u0026#39;PrerenderSPAPlugin\u0026#39; }; // 向编译器的钩子上注册异步方法，可以对当前编译实例（过程）做操作 compiler.hooks.afterEmit.tapAsync(plugin, afterEmit); }); 两种文件 公司的 SEO 服务商让在服务器根目录放了几个“文件”，最有用的是两种是 Sitemap 和 robots。\nSitemap 是用来告诉蜘蛛网站上有哪些可供抓取的网页；Sitemap 可以是 XML、TXT、HTML 文件，其中包含了站点中的网址以及关于每个网址的元数据（更新时间、更新频率、重要程度、语言版本等），以便搜索引擎可以更加智能地抓取网站；Sitemap 并不能保证网页会被蜘蛛抓取，但可向蜘蛛提供一些提示以便网站被更有效地抓取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?xml version=\u0026#39;1.0\u0026#39; encoding=\u0026#39;UTF-8\u0026#39;?\u0026gt; \u0026lt;urlset\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com/about/contact]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com/about/us]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com/solution/agriculture]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com/solution/hybrid]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;url\u0026gt; \u0026lt;loc\u0026gt;\u0026lt;![CDATA[https://www.example.com/support/ask]]\u0026gt;\u0026lt;/loc\u0026gt; \u0026lt;lastmod\u0026gt;2020-10-28\u0026lt;/lastmod\u0026gt; \u0026lt;changefreq\u0026gt;weekly\u0026lt;/changefreq\u0026gt; \u0026lt;/url\u0026gt; \u0026lt;/urlset\u0026gt; Sitemap 适用情形：\n网站规模很大，蜘蛛有可能在抓取时漏掉部分新网页或最近更新的网页； 有大量内容页归档，并且内容页之间互不关联或缺少有效链接； 网站为新网站且指向该网站的外部链接不多； 您的网站包含大量媒体内容（视频、图片）。 robots 文件是用来告诉搜索引擎，网站上的哪些页面可以抓取，哪些页面不能抓取；User-agent、Allow、Disallow 等字段精确地对不同搜索引擎的抓取工作进行控制：\n1 2 3 4 5 6 7 8 9 User-agent: Googlebot Disallow: / Allow: /content/ User-agent: Baiduspider Disallow: /admin/ Sitemap: https://www.example.com/sitemap.txt Sitemap: https://www.example.com/sitemap.html robots 适用情形：\n在某个阶段不公开某些网页 (例如：在搭建网站雏形时)； 防止抓取内部搜索页面； 防止抓取重复页面； 防止服务器过载。 参考 关于 Robots.txt 和 SEO：你所需要知道的一切 什么是 Sitemap？ Google 搜索中心 百度站长平台 ","date":"2020-11-15T00:00:00Z","image":"https://vikingama.github.io/img/cover/seo.png","permalink":"https://vikingama.github.io/p/spa-%E7%9A%84-seo-%E5%AE%9E%E8%B7%B5/","title":"SPA 的 SEO 实践"},{"content":"Node 简介 Node 的结构与 Chrome 十分相似，它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node 通过事件驱动来服务 I/O；作为后端 JS 的运行平台，Node 没有改写语言本身的任何特性，它将前端中广泛运用的思想迁移到了服务器端。\nNode 特点：异步输入输出、回调函数、单线程、基于 libuv 实现跨平台。\n模块化 Node 中模块分为两类：核心模块和文件模块；核心模块在 Node 启动时被直接加载进内存中，文件模块则是在运行时动态加载。Node 对引入过的模块都会进行缓存，同浏览器缓存文件一样，不同的是 Node 缓存的是编译和执行之后的对象。\nNode 在对 JS 模块编译的过程中对文件内容进行了头尾包装，这样每个模块文件之间都进行了作用域隔离。包装之后的代码会通过原生模块的 runInThisContext 方法执行，返回一个 function 对象。\n1 2 3 4 5 6 (function (exports, require, module, __filename, __dirname) { var math = require(\u0026#39;math\u0026#39;); exports.area = function (radius) { return Math.PI * radius * radius; }; }); Node 对 C/C++模块调用 process.dlopen 进行加载和执行，dlopen 方法在 Windows 和 *nix 平台下分别有不同的实现，通过 libuv 兼容层进行了封装。\nNode 在对 JSON 文件编译时，利用 fs 模块同步读取 JSON 文件的内容之后，调用 JSON.parse 得到对象，然后将它赋给模块对象的 exports，以供外部调用。\nNode 最初采用的是 CommonJS 规范，从 v13.2 版本开始，Node 默认支持 ES6 模块；ES6 的模块规范和 CommonJS 规范的差别在于：\nCommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用； CommonJS 模块是运行时加载，ES6 模块是编译时输出接口； CommonJS 模块的顶层 this 指向当前模块，ES6 模块中，顶层的 this 指向 undefined； ES6 模块中不存在：arguments、require、module、exports、__filename、__dirname。 CommonJS 加载的是一个对象，该对象只有在脚本运行完才会生成；而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，Webpack 的 TreeShaking 就利用了 ES6 模块可以静态分析的特点。\nNode 要求 ES6 模块采用 .mjs 文件扩展名；Node 遇到 .mjs 文件，就认为它是 ES6 模块，默认启用严格模式；如果不希望将后缀名改成 .mjs，可以在项目的 package.json 文件中，指定 type 字段为 module；如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成 .cjs。\n总之，.mjs 文件总是以 ES6 模块加载，.cjs 文件总是以 CommonJS 模块加载，.js 文件的加载取决于 package.json 里面 type 字段的设置。\n异步 I/O Node 利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞，以更好地使用 CPU。为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了子进程，子进程可以通过工作进程高效地利用 CPU。\n操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞；阻塞 I/O 的一个特点是调用之后一定要等到系统内核层面完成所有操作后，调用才结束。非阻塞 I/O 则不带数据直接返回，返回之后，CPU 的时间片可以用来处理其他事务，性能提升是明显的；但由于完整的 I/O 并没有完成，立即返回的并不是业务层期望的数据，而仅仅是当前调用的状态；为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。\n由于 Windows 平台和 *nix 平台的差异，Node 提供了 libuv 作为抽象封装层，使得所有平台兼容性的判断都由这一层来完成，并保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。Node 在编译期间会判断平台条件，选择性编译 *nix 目录或是 Win 目录下的源文件到目标程序中。\n事件循环、观察者、请求对象、I/O 线程池这四者共同构成了异步 I/O 模型的基本要素。事实上，在 Node 中，除了 JS 是单线程外，Node 自身其实是多线程的；除了用户代码无法并行执行外，所有的 I/O（磁盘 I/O 和网络 I/O 等）则是可以并行的。\n事件循环 事件循环对观察者的检查是有先后顺序的，process.nextTick 属于 idle 观察者，setImmediate 属于 check 观察者。在每一个轮循环检查中，idle 观察者先于 I/O 观察者，I/O 观察者先于 check 观察者。\nprocess.nextTick 的回调函数保存在一个数组中，setImmediate 的结果则是保存在链表中；在行为上，process.nextTick 在每轮循环中会将数组中的回调函数全部执行完，而 setImmediate 在每轮循环中执行链表中的一个回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 console.log(\u0026#39;start\u0026#39;); setTimeout(function () { console.log(\u0026#39;setTimeout one\u0026#39;); }, 0); process.nextTick(function () { console.log(\u0026#39;process.nextTick one\u0026#39;); }); setImmediate(function () { console.log(\u0026#39;setImmediate one\u0026#39;); process.nextTick(function () { console.log(\u0026#39;process.nextTick in setImmediate\u0026#39;); }); }); setTimeout(function () { console.log(\u0026#39;setTimeout two\u0026#39;); }, 0); process.nextTick(function () { console.log(\u0026#39;process.nextTick two\u0026#39;); }); setImmediate(function () { console.log(\u0026#39;setImmediate two\u0026#39;); }); console.log(\u0026#39;end\u0026#39;); /** * start * end * process.nextTick one * process.nextTick two * setTimeout one * setTimeout two * setImmediate one * process.nextTick in setImmediate * setImmediate two */ 垃圾回收 调用 process.memoryUsage() 可以看到 Node 进程的内存占用情况，每个属性值的单位为字节：\n1 2 3 4 5 6 { rss: 27152384, // 常驻内存，为进程分配了多少物理内存，包含所有的 C++ 和 JS 对象与代码 heapTotal: 5959680, // 堆中总共『申请』的内存量 heapUsed: 3728776, // 堆中『使用中』的内存量 external: 1393760 // V8 管理的、绑定到 JS 的 C++ 对象的内存量 } 当在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制为止。V8 限制堆的大小的原因是 V8 的垃圾回收机制的限制；V8 做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上；这是垃圾回收中引起 JS 线程暂停执行的时间，在这样的时间花销下，应用的性能和响应能力都会直线下降；因此，在当时的考虑下直接限制堆内存是一个好的选择。\nV8 提供了选项让我们使用更多的内存；Node 在启动时可以传递 max_old_space_size 或 max_new_space_size 来调整内存限制的大小：\n1 2 3 4 // 设置老生代内存空间的最大值，单位为 MB node --max_old_space_size=2048 test.js // 设置新生代内存空间的最大值，单位为 KB node --max_new_space_size=1024 test.js V8 的垃圾回收策略主要基于分代式垃圾回收机制；按照对象的存活时间将内存进行不同的分代，然后分别对不同分代的内存施以不同的算法。\n在 V8 中，主要将内存分为新生代和老生代两代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。V8 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。\n对于新生代内存，主要通过 Scavenge 算法进行垃圾回收；将堆内存一分为二，在这两个 semispace 空间中，只有一个处于使用中（From 空间），另一个处于闲置状态（To 空间）。当分配对象时，先是在 From 中进行分配；当开始进行垃圾回收时，会检查 From 中的存活对象，存活对象将被复制到 To 中，而非存活对象占用的空间将会被释放；完成复制后，From 和 To 的角色发生对换。简而言之，就是将存活对象在两个 semispace 空间之间进行复制。\nScavenge 的缺点是只能使用堆内存中的一半，但在时间效率上有优异的表现。\n当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象；这种对象随后会被移动到老生代中，采用新的算法进行管理；对象从新生代中移动到老生代中的过程称为晋升。对象晋升的条件主要有两个：一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。\n对于老生代中的对象，采用标记清除算法；在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。Scavenge 中只复制活着的对象，而 Mark-Sweep 只清理死亡对象；活对象在新生代中只占较小部分，死对象在老生代中只占较小部分。\nMark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态；这种内存碎片会对后续的内存分配造成问题，为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出来。标记整理是在 Mark-Sweep 的基础上演变而来的，它们的差别在于对象在标记为死亡后，在整理的过程中将活着的对象往一端移动，移动完成后直接清理掉边界外的内存。\n由于 Mark-Compact 需要移动对象，它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时才使用 Mark-Compact。\n在 V8 的回收策略中两者是结合使用的，目前介绍到的 3 种主要垃圾回收算法的简单对比：\n垃圾回收的 3 种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”；由于新生代内存默认配置得较小，且其中存活对象通常较少，所以即便全停顿影响也不大；老生代内存通常配置得较大，且存活对象较多，垃圾回收的标记、清理、整理等动作造成的停顿就会比较可怕；为此，V8 从标记阶段入手，引入增量标记（从行为上看很像 React Fiber），将原本要一口气停顿完成的动作是拆分为许多小“步进”，垃圾回收与应用逻辑交替执行直到标记阶段完成。\n内存指标 os.totalmem() 和 os.freemem() 这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，单位为字节：\n1 2 3 4 \u0026gt; os.totalmem() 17179869184 \u0026gt; os.freemem() 1706803200 通过 process.momoryUsage() 的结果可以看到，堆中的内存用量总是小于进程的常驻内存用量；这意味着 Node 中的内存使用并非都是通过 V8 进行分配的；那些不是通过 V8 分配的内存称为堆外内存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 var total = []; for (var j = 0; j \u0026lt; 15; j++) { showMem(); total.push(useMem()); } showMem(); function showMem() { var mem = process.memoryUsage(); var format = function (bytes) { return (bytes / 1024 / 1024).toFixed(2) + \u0026#39; MB\u0026#39;; }; console.log( \u0026#39;Process: heapTotal \u0026#39; + format(mem.heapTotal) + \u0026#39; heapUsed \u0026#39; + format(mem.heapUsed) + \u0026#39; rss \u0026#39; + format(mem.rss) ); console.log(\u0026#39;---------------------------------------\u0026#39;); } function useMem() { const size = 200 * 1024 * 1024; const buffer = new Buffer.alloc(size); for (var i = 0; i \u0026lt; size; i++) { buffer[i] = 0; } return buffer; } 在 node 中运行以上代码，输出以下结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Process: heapTotal 4.05 MB heapUsed 2.06 MB rss 21.72 MB --------------------------------------- Process: heapTotal 5.48 MB heapUsed 2.72 MB rss 225.77 MB --------------------------------------- Process: heapTotal 5.48 MB heapUsed 2.73 MB rss 425.98 MB --------------------------------------- ... ... ... Process: heapTotal 4.48 MB heapUsed 2.03 MB rss 2624.34 MB --------------------------------------- Process: heapTotal 4.48 MB heapUsed 2.03 MB rss 2824.34 MB --------------------------------------- Process: heapTotal 4.48 MB heapUsed 1.95 MB rss 3024.34 MB --------------------------------------- heapTotal 与 heapUsed 的变化极小，rss 的值已经超过 V8 的限制值；原因是 Buffer 对象不同于其他对象，它不经过 V8 的内存分配机制，不会有堆内存的大小限制；这意味着利用堆外内存可以突破内存限制的问题。\n内存泄漏 造成内存泄漏的原因有：\n缓存； 队列消费不及时； 作用域未释放。 缓存的访问效率要比 I/O 的效率高，一旦命中缓存，就可以节省一次 I/O 的时间；一旦一个对象被当做缓存来使用，那它将会常驻在老生代内存中；这将影响垃圾回收的效率。对象不同于严格意义的缓存，缓存有着完善的过期策略，而普通对象并没有；所以在 Node 中，任何试图拿内存当缓存的行为都应当被限制。\n目前比较好的解决方案是采用进程外的缓存（例如：Redis），进程自身不存储状态；外部的缓存有着良好的缓存过期淘汰策略以及内存管理，不影响 Node 进程的性能：\n将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效； 进程之间可以共享缓存。 EventEmitter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const EventEmitter = require(\u0026#39;events\u0026#39;).EventEmitter; const AudioDevice = { play: function (track) { console.log(\u0026#39;play\u0026#39;, track); }, stop: function () { console.log(\u0026#39;stop\u0026#39;); } }; class MusicPlayer extends EventEmitter { constructor() { super(); this.playing = false; } } const musicPlayer = new MusicPlayer(); musicPlayer.on(\u0026#39;play\u0026#39;, function (track) { this.playing = true; AudioDevice.play(track); }); musicPlayer.on(\u0026#39;stop\u0026#39;, function () { this.playing = false; AudioDevice.stop(); }); /** * EventEmitter 实例发生错误会发出一个 error 事件 * 如果没有监听器，默认动作是打印一个堆栈并退出程序 */ musicPlayer.on(\u0026#39;error\u0026#39;, function (err) { console.error(\u0026#39;Error:\u0026#39;, err); }); musicPlayer.emit(\u0026#39;play\u0026#39;, \u0026#39;The Roots - The Fire\u0026#39;); setTimeout(function () { musicPlayer.emit(\u0026#39;stop\u0026#39;); }, 1000); Buffer Buffer 是一个类数组对象，它的元素为 16 进制的两位数，即 0 到 255 的数值，主要用于操作字节；它将性能相关的部分用 C++ 实现（node_buffer），将非性能相关的部分用 JS 实现（Buffer/SlowBuffer）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 var str = \u0026#39;深入浅出 node.js\u0026#39;; var buf = Buffer.from(str, \u0026#39;utf-8\u0026#39;); console.log(buf); // \u0026lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 20 6e 6f 64 65 2e 6a 73\u0026gt; console.log(buf.length); // 20 // 如果是小数，舍弃小数部分，只保留整数部分 buf[0] = 3.1415; console.log(buf[0]); // 3 // 赋值如果小于 0，就将该值逐次加 256，直到得到一个 0 到 255 之间的整数 buf[1] = -1; console.log(buf[1]); // 255 // 如果得到的数值大于 255，就逐次减 256，直到得到一个 0 到 255 之间的整数 buf[2] = 256; console.log(buf[2]); // 0 Node 在内存的使用上应用的是在 C++ 层面『申请』内存、在 JS 中『分配』内存的策略；Node 采用动态内存管理机制（slab）高效地使用申请来的内存；slab 是一块申请好的固定大小的内存区域，具有如下 3 种状态：\nfull，完全分配状态； partial，部分分配状态； empty，没有被分配状态。 Buffer 的内存分配是在 Node 的 C++ 层面实现的；Node 以 8KB（每个 slab 的大小）为界限来区分 Buffer 是大对象还是小对象。\nBuffer 对象可以与字符串之间相互转换，Node 当前支持 utf8、utf16le、latin1、base64、hex、ascii、binary（latin1 的别名）、ucs2（utf16le 的别名）字符编码。\n1 2 3 4 5 6 7 8 // 判断编码是否支持转换 Buffer.isEncoding(\u0026#39;GB2312\u0026#39;); // false // utf8 是默认编码 const buf = Buffer.from(\u0026#39;hello world\u0026#39;, \u0026#39;utf8\u0026#39;); console.log(buf.toString(\u0026#39;hex\u0026#39;)); // 68656c6c6f20776f726c64 console.log(buf.toString(\u0026#39;base64\u0026#39;)); // aGVsbG8gd29ybGQ= console.log(Buffer.from(\u0026#39;fhqwhgads\u0026#39;, \u0026#39;utf8\u0026#39;)); // \u0026lt;Buffer 66 68 71 77 68 67 61 64 73\u0026gt; console.log(Buffer.from(\u0026#39;fhqwhgads\u0026#39;, \u0026#39;utf16le\u0026#39;)); // \u0026lt;Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00\u0026gt; Buffer 在使用场景中，通常是以一段一段的方式传输：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 var fs = require(\u0026#39;fs\u0026#39;); var rs = fs.createReadStream(\u0026#39;ThinkInSilence.md\u0026#39;); { // 设置可读流编码可以解决乱码问题；这里的 highWaterMark 是指每次读取的长度，其大小决定会触发系统调用和 data 事件的次数 var rs = fs.createReadStream(\u0026#39;ThinkInSilence.md\u0026#39;, { highWaterMark: 11 }); /** * 可读流在内部设置了一个 decoder 对象（来自 StringDecoder 的实例） * 每次 data 事件都通过该 decoder 对象进行 Buffer 到字符串的解码 * data 不再收到原始的 Buffer 对象 */ rs.setEncoding(\u0026#39;utf8\u0026#39;); } var data = \u0026#39;\u0026#39;; rs.on(\u0026#39;data\u0026#39;, function (chunk) { // 这里暗含了 toString 操作，一旦输入流中有宽字节编码时，就会出现乱码 data += chunk; }); rs.on(\u0026#39;end\u0026#39;, function () { // toString 方法默认以 UTF-8 为编码，中文字在 UTF-8 下占 3 个字节，Buffer 大小可能会造成乱码 console.log(data); // 床前明���光，疑���地上霜；举头���明月，���头思故乡。 }); Buffer 正确的拼接方式并不是『+=』，而是使用 Buffer.concat(Array) 的方式：\n1 2 3 4 5 6 7 8 9 10 11 var chunks = []; var size = 0; res.on(\u0026#39;data\u0026#39;, function (chunk) { chunks.push(chunk); size += chunk.length; }); res.on(\u0026#39;end\u0026#39;, function () { var buf = Buffer.concat(chunks, size); var str = iconv.decode(buf, \u0026#39;utf8\u0026#39;); console.log(str); }); Cookie HTTP 是一个无状态的协议，Cookie 用来记录服务器与客户端之间的状态；Cookie 的处理分为如下几步：\n服务器向客户端发送 Cookie； 浏览器将 Cookie 保存； 每次发生请求都会将 Cookie 发向服务器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Cookie 格式是 key1=value2;key2=value2 形式的 function parseCookie(cookie) { if (!cookie) { return; } const entries = cookie.split(\u0026#39;;\u0026#39;); const temp = {}; entries.forEach(item =\u0026gt; { const arr = item.split(\u0026#39;=\u0026#39;); const key = arr[0].trim(); const value = arr[1] || \u0026#39;\u0026#39;; temp[key] = value; }); return temp; } Session Session 只保留在服务器端，数据的安全性得到一定的保障，数据也无须在每次请求中都被传递；如何将客户端和服务器中的 Session 对应呢：\n基于 Cookie 来实现用户和数据的映射； 通过查询字符串来实现客户端和服务器数据的对应。 一旦服务器端启用了 Session，它将约定一个键值作为 Session 口令；将 Session 口令放在 Cookie 中；如果用户请求 Cookie 中没有携带口令，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间；如果口令被篹改，客户端就丢失了与 Session 的映射关系，也无法修改服务器端存在的数据了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 const EXPIRES = 20 * 60 * 1000; const sessions = {}; // 将所有 Session 保存在内存中，会有性能问题 const key = \u0026#39;session_id\u0026#39;; // 生成 Session function generate() { const session = {}; session.id = Date.now() + Math.random(); session.cookie = { // 设置过期时间 expire: Date.now() + EXPIRES }; sessions[session.id] = session; return session; } // 处理请求，检查 Cookie 口令与服务端数据 function handler(req, res) { let id = req.cookies[key]; if (!id) { req.session = generate(); } else { let session = sessions[id]; if (!session) { req.session = generate(); } else { if (session.cookie.expire \u0026gt; Date.now()) { session.cookie.expire = Date.now() + EXPIRES; req.session = session; } else { delete sessions[id]; req.session = generate(); } } } if (!req.session.isVisit) { res.session.isVisit = true; res.writeHead(200); res.end(\u0026#39;欢迎『首次』访问\u0026#39;); } else { res.writeHead(200); res.end(\u0026#39;欢迎『再次』访问\u0026#39;); } } // 响应请求时，设置 Session var writeHead = res.writeHead; res.writeHead = () =\u0026gt; { let cookies = res.getHeader(\u0026#39;Set-Cookie\u0026#39;); let session = serialize(\u0026#39;Set-Cookie\u0026#39;, req.session.id); cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session]; res.setHeader(\u0026#39;Set-Cookie\u0026#39;, cookies); return writeHead.apply(this, arguments); }; 文件上传 通过报头的 Transfer-Encoding 或 Content-Length 可判断请求中是否带有内容：\n1 2 3 function hasBody(req) { return \u0026#39;transfer-encoding\u0026#39; in req.headers || \u0026#39;content-length\u0026#39; in req.headers; } 报文内容部分会通过 data 事件触发，我们需要以流的方式处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function handler(req, res) { if (hasBody(req)) { var bufs = []; req.on(\u0026#39;data\u0026#39;, chunk =\u0026gt; { bufs.push(chunk); }); req.on(\u0026#39;end\u0026#39;, () =\u0026gt; { req.rawBody = Buffer.concat(bufs).toString(); // ... }); } else { // ... } } RESTful RESTful 设计哲学是将服务器端提供的内容实体看作一个资源，并表现在 URL 上；一个用户的地址『/users/jacksontian』代表了一个资源，对这个资源的操作，主要体现在 HTTP 请求方法上，不是体现在 URL 上：\n1 2 3 4 5 6 7 8 9 10 11 过去的设计：操作行为主要体现在行为上，主要使用的请求方法是 POST 和 GET POST /user/add?username=jacksontian 增 GET /user/remove?username=jacksontian 删 POST /user/update?username=jacksontian 改 GET /user/get?username=jacksontian 查 RESTful：通过 URL 设计资源、通过请求方法定义资源的操作、通过 Accept 决定资源的表现形式 POST /user/jacksontian DELETE /user/jacksontian PUT /user/jacksontian GET /user/jacksontian 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 const express = require(\u0026#39;express\u0026#39;); const routes = require(\u0026#39;./routes\u0026#39;); const app = express(); app.use(express.json()); app.use(express.methodOverride()); app.get(\u0026#39;/pages\u0026#39;, routes.pages.index); app.get(\u0026#39;/pages/:id\u0026#39;, routes.pages.show); app.post(\u0026#39;/pages\u0026#39;, routes.pages.create); app.patch(\u0026#39;/pages/:id\u0026#39;, routes.pages.patch); app.put(\u0026#39;/pages/:id\u0026#39;, routes.pages.update); app.del(\u0026#39;/pages/:id\u0026#39;, routes.pages.remove); modules.exports = app; 中间件 中间件的行为比较类似 Java 中的过滤器，在进入具体的业务处理之前，先让过滤器处理一些与业务无关的技术细节；由于 Node 异步的原因，我们需要提供一种机制，在当前中间件处理完成后，通知下一个中间件执行：\n中间件往往先于业务逻辑执行，为了让业务逻辑提早执行，中间件的编写和使用需要注意两点：\n编写高效的中间件：尽早调用 next 执行后续逻辑、缓存需要重复计算的结果、避免不必要的计算（比如『报文体解析』对于 GET 是不必要的）； 合理利用路由，避免不必要的中间件执行。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function staticFile(req, res, next) { const pathname = url.parse(req.url).pathname; fs.readFile(path.join(ROOT, pathname), (err, file) =\u0026gt; { if (err) { return next(err); } res.writeHead(200); res.end(file); }); } functon xmlMiddleware(req,res,next){ if(!req.is(\u0026#34;xml\u0026#34;)){ return next() } let body = \u0026#34;\u0026#34;; req.on(\u0026#34;data\u0026#34;,str=\u0026gt;{ body+=str; }) req.on(\u0026#34;end\u0026#34;,()=\u0026gt;{ req.body = xml2json.toJson(body.toString(),{ object:true, sanitize:false }) next(); }) } // 对所有路径都会使用中间件 app.use(staticFile); // 仅对静态目录使用中间件，提升匹配效率 app.use(\u0026#39;/public/xml\u0026#39;, xmlMiddleware); 响应客户端 服务器端响应的报文，最终都要被客户端处理；服务器端的响应从一定程度上决定或指示了客户端该如何处理响应的内容；在内容响应的过程中，响应报头中的 Content-* 字段会告知客户端响应的内容信息：\n1 2 3 4 5 6 内容以 gzip 编码 Content-Encoding: gzip 内容长度为 21170 个字节 Content-Length: 21170 内容类型为 JS，字符集为 UTF-8 Content-Type: text/javascript; charset=utf-8 客户端在接收到这个报文后，正确的处理过程是通过 gzip 来解码报文体中的内容，用长度校验报文体内容是否正确，然后再以字符集 UTF-8 将解码后的脚本插入到文档节点中。\n浏览器通过不同的 Content-Type 的值来决定何种渲染方式，这个值我们简称为 MIME 值：\n1 2 3 4 5 6 7 8 9 10 11 12 // 纯文本 res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Hello World\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\\n\u0026#39;); // HTML res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/html\u0026#39; }); res.end(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;body\u0026gt;Hello World\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\\n\u0026#39;); // 使用 mime 模块获知文件的 MIME 值 var mime = require(\u0026#39;mime\u0026#39;); mime.lookup(\u0026#39;/path/to/file.txt\u0026#39;); // =\u0026gt; \u0026#39;text/plain\u0026#39; mime.lookup(\u0026#39;file.txt\u0026#39;); // =\u0026gt; \u0026#39;text/plain\u0026#39; mime.lookup(\u0026#39;.TXT\u0026#39;); // =\u0026gt; \u0026#39;text/plain\u0026#39; mime.lookup(\u0026#39;htm\u0026#39;); // =\u0026gt; \u0026#39;text/html\u0026#39; 在附件下载场景下，无论响应内容是什么 MIME 值，需要客户端去下载它；为了满足这种需求，需要设置 Content-Disposition 字段，客户端会根据它的值判断是应该将报文数据解析还是下载；当内容只需即时查看时，它的值为 inline，当数据可以存为附件时，它的值为 attachment；Content-Disposition 字段还能通过参数指定保存时应该使用的文件名。\n1 Content-Disposition: attachment; filename=\u0026#34;filename.ext\u0026#34; 响应附件下载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 res.sendfile = filepath =\u0026gt; { // 检查文件是否存在 fs.stat(filepath, (err, stat) =\u0026gt; { if (err) return; var stream = fs.createReadStream(filepath); // 设置内容 res.setHeader(\u0026#39;Content-Type\u0026#39;, mime.lookup(filepath)); // 设置大小 res.setHeader(\u0026#39;Content-Length\u0026#39;, stat.size); // 设置为附件 res.setHeader( \u0026#39;Content-Disposition\u0026#39;, `attachment; filename=${path.basename(filepath)}` ); res.writeHead(200); stream.pipe(res); }); }; 响应 JSON：\n1 2 3 4 5 res.json = json =\u0026gt; { res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); res.writeHead(200); res.end(JSON.stringify(json)); }; 响应跳转：\n1 2 3 4 5 res.redirect = url =\u0026gt; { res.setHeader(\u0026#39;Location\u0026#39;, url); res.writeHead(302); res.end(url); }; 响应 HTML：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 res.render = (view, data) =\u0026gt; { res.setHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;text/html\u0026#39;); res.writeHead(200); // 通过模板引擎（Pug、Mustache...）将数据渲染为 HTML var html = render(view, data); res.end(html); }; function render(view, data) { let template = view.replace( /\u0026lt;%=([\\s\\S]+?)%\u0026gt;/g, (match, code) =\u0026gt; `obj.${code}` ); template = `var tpl = ${template}\\nreturn tpl;`; let complied = new Function(\u0026#39;obj\u0026#39;, template); return complied(data); } 主从模式 Node 决定在 V8 上构建时就不得不面对两个问题：如何充分利用多核 CPU？如何保证主进程的健壮性和稳定性？Node 的 child_process 模块提供了衍生子进程，可以实现对多个进程的控制。\nMaster-Worker 主从模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // master.js const fork = require(\u0026#39;child_process\u0026#39;).fork; const cpus = require(\u0026#39;os\u0026#39;).cpus(); for (let i = 0; i \u0026lt; cpus.length; i++) { /** * 通过 fork 复制的进程都是一个独立的进程，有着独立而全新的 V8 实例 * 这里启动多个进程只是为了充分将 CPU 资源利用起来，而不是为了解决并发问题 */ fork(\u0026#39;./worker.js\u0026#39;); } // worker.js const http = require(\u0026#39;http\u0026#39;); http .createServer((req, res) =\u0026gt; { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;i am worker\u0026#39;); }) .listen(Math.round((1 + Math.random()) * 1000), \u0026#39;127.0.0.1\u0026#39;); 运行 node master.js 将会复制多个 Node 进程；主进程仅负责调度或管理工作进程，工作进程负责具体的业务处理。\nchild_process 模块给予 Node 随意创建子进程的能力；它提供了 4 个方法用于创建子进程：\nchild_process.spawn 使用给定的命令衍生新的进程，并传入 args 中的命令行参数（默认为空数组）； child_process.fork 是 child_process.spawn 的特例，专门用于衍生新的进程；与 child_process.spawn 一样返回 ChildProcess 对象；返回的 ChildProcess 会内置额外的通信通道，允许消息在父进程和子进程之间来回传递； child_process.exec 与 child_process.spawn 不同的是其接口不同，它有一个回调函数获知子进程的状况； child_process.execFile 类似于 child_process.exec 但默认情况下不会衍生 shell；比 child_process.exec 稍微更高效。 1 2 3 4 5 var cp = require(\u0026#39;child_process\u0026#39;); cp.spawn(\u0026#39;node\u0026#39;, [\u0026#39;worker.js\u0026#39;]); cp.fork(\u0026#39;./worker.js\u0026#39;); cp.exec(\u0026#39;node worker.js\u0026#39;, function (err, stdout, stderr) {}); cp.execFile(\u0026#39;worker.js\u0026#39;, function (err, stdout, stderr) {}); 父子进程之间会创建 IPC 通道进行通信：\n1 2 3 4 5 6 7 8 9 10 11 12 // parent const cp = require(\u0026#39;child_process\u0026#39;); const sub = cp.fork(__dirname + \u0026#39;/sub.js\u0026#39;); sub.on(\u0026#39;message\u0026#39;, m =\u0026gt; { console.log(\u0026#39;parent got msg from child: \u0026#39; + m); }); sub.send({ msg: \u0026#39;hello son\u0026#39; }); // child process.on(\u0026#39;message\u0026#39;, m =\u0026gt; { console.log(\u0026#39;child got msg from parent: \u0026#39; + m); }); process.send({ msg: \u0026#39;hello papa\u0026#39; }); IPC 的目的是为了让不同的进程能够互相访问资源并进行协调工作，Node 中 IPC 是由管道（pipe）技术实现的（libuv 提供）；在 Windows 下由命名管道实现，在 *nix 下由 Unix Domain Socket 实现。\n父进程在实际创建子进程之前，会创建 IPC 通道并监听它，然后才真正创建出子进程，并通过环境变量 NODE_CHANNEL_FD 告诉子进程这个 IPC 通道的文件描述符；子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道，从而完成父子进程之间的连接。\n由于 IPC 通道与 socket 的行为比较类似，属于双向通信；不同的是它们在系统内核中就完成了进程间的通信，而不用经过实际的网络层，非常高效；只有启动的子进程是 Node 进程时，子进程才会根据环境变量去连接 IPC 通道，对于其他类型的子进程则无法实现进程间通信，除非其他进程也按约定去连接这个已经创建好的 IPC 通道。\n句柄 句柄（标识符）是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符；句柄可以用来标识一个 socket 对象、一个 UDP 套接字、一个管道等。通过进程间发送句柄可以实现多个进程监听同一端口；主进程接收到 socket 请求后，将这个 socket 直接发送给工作进程，而不是重新与工作进程之间建立新的 socket 连接来转发数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 主进程 const child_one = require(\u0026#39;child_process\u0026#39;).fork(\u0026#39;./child.js\u0026#39;); const child_two = require(\u0026#39;child_process\u0026#39;).fork(\u0026#39;./child.js\u0026#39;); const server = require(\u0026#39;net\u0026#39;).createServer(); server.on(\u0026#39;connection\u0026#39;, socket =\u0026gt; { socket.end(\u0026#39;handled by parent\\n\u0026#39;); }); server.listen(1337, () =\u0026gt; { child_one.send(\u0026#39;server\u0026#39;, server); child_two.send(\u0026#39;server\u0026#39;, server); }); // 子进程 process.on(\u0026#39;message\u0026#39;, (m, server) =\u0026gt; { m === \u0026#39;server\u0026#39; \u0026amp;\u0026amp; server.on(\u0026#39;connection\u0026#39;, socket =\u0026gt; { socket.end(\u0026#39;handled by child\\n pid is \u0026#39; + process.pid + \u0026#39;\\n\u0026#39;); }); }); 对于主进程而言，我们甚至想要它更轻量一点，那么是否将服务器句柄发送给子进程之后，就可以关掉服务器的监听，让子进程来处理请求呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 主进程 const child_one = require(\u0026#39;child_process\u0026#39;).fork(\u0026#39;./child.js\u0026#39;); const child_two = require(\u0026#39;child_process\u0026#39;).fork(\u0026#39;./child.js\u0026#39;); const server = require(\u0026#39;net\u0026#39;).createServer(); server.listen(1337, () =\u0026gt; { child_one.send(\u0026#39;server\u0026#39;, server); child_two.send(\u0026#39;server\u0026#39;, server); server.close(); }); // 子进程 const http = require(\u0026#39;http\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;text/plain\u0026#39; }); res.end(\u0026#39;handled by child\\n pid is \u0026#39; + process.pid + \u0026#39;\\n\u0026#39;); }); process.on(\u0026#39;message\u0026#39;, (m, tcp) =\u0026gt; { m === \u0026#39;server\u0026#39; \u0026amp;\u0026amp; tcp.on(\u0026#39;connection\u0026#39;, socket =\u0026gt; { server.emit(\u0026#39;connection\u0026#39;, socket); }); }); 子进程对象 send 方法可以发送的句柄类型包括如下几种：\nnet.Socket TCP 套接字； net.Server TCP 服务器； net.Native C++ 层面的 TCP 套接字或 IPC 管道； dgram.Socket UDP 套接字； dgram.Native C++ 层面的 UDP 套接字。 send 方法在将消息发送到 IPC 管道前，将消息组装成两个对象，一个参数是 handle，另一个是 message；发送到 IPC 管道中的实际上是我们要发送的句柄文件描述符。message 对象在写入到 IPC 管道时也会通过 JSON.stringify 进行序列化，最终发送到 IPC 通道中的信息都是字符串。\n1 2 3 4 5 { cmd: \u0026#39;NODE_HANDLE\u0026#39;, // 如果以 NODE_ 为前缀，它将响应一个内部事件 internalMessage；NODE_HANDLE 表示它将取出 message.type 值和得到的文件描述符一起还原出一个对应的对象 type: \u0026#39;net.Server\u0026#39;, msg: message } Node 进程之间只有消息传递，不会真正地传递对象，这种错觉是抽象封装的结果。\n自动重启 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // master.js const fork = require(\u0026#39;child_process\u0026#39;).fork; const cpus = require(\u0026#39;os\u0026#39;).cpus(); const server = require(\u0026#39;net\u0026#39;).createServer(); const workers = {}; server.listen(1337); for (let i = 0; i \u0026lt; cpus.length; i++) { createWorker(); } function createWorker() { let worker = fork(__dirname + \u0026#39;./worker.js\u0026#39;); worker.on(\u0026#39;exit\u0026#39;, () =\u0026gt; { console.log(\u0026#39;worker: \u0026#39; + worker.pid + \u0026#39; exited.\u0026#39;); delete workers[worker.pid]; createWorker(); }); worker.send(\u0026#39;server\u0026#39;, server); workers[worker.pid] = worker; console.log(\u0026#39;create worker. pid: \u0026#39; + worker.pid); } // worker.js process.on(\u0026#39;exit\u0026#39;, () =\u0026gt; { for (let pid in workers) { workers[pid].kill(); } }); process.on(\u0026#39;uncaughtException\u0026#39;, err =\u0026gt; { logger.error(err); process.send({ act: \u0026#39;suicide\u0026#39; }); // 如果有未捕获的异常，退出进程 worker.close(() =\u0026gt; { process.exit(1); }); }); 限量重启 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 let limit = 10; let duration = 60000; const restart = []; const workers = {}; function createWorker() { if (isTooFrequently()) { // 如果重启太过频繁，不再重启 process.emit(\u0026#39;giveup\u0026#39;, length, duration); return; } let worker = fork(__dirname + \u0026#39;/work.js\u0026#39;); worker.on(\u0026#39;exit\u0026#39;, () =\u0026gt; { console.log(\u0026#39;worker \u0026#39; + worker.pid + \u0026#39; exited.\u0026#39;); delete workers[worker.pid]; }); worker.on(\u0026#39;message\u0026#39;, message =\u0026gt; { message.act === \u0026#39;suicide\u0026#39; \u0026amp;\u0026amp; createWorker(); }); worker.send(\u0026#39;server\u0026#39;, server); workers[worker.pid] = worker; console.log(\u0026#39;create worker. pid: \u0026#39; + worker.pid); } function isTooFrequently() { let time = Date.now(); let length = restart.push(time); if (length \u0026gt; limit) { restart = restart.slice(limit * -1); } return ( restart.length \u0026gt;= limit \u0026amp;\u0026amp; restart[restart.length - 1] - restart[0] \u0026lt; duration ); } // 监听自定义 giveup 事件 process.on(\u0026#39;giveup\u0026#39;, (count, time) =\u0026gt; { process.close(() =\u0026gt; { process.exit(1); }); setTimeout(() =\u0026gt; { process.exit(1); }, 5000); }); // 监听主进程退出，退出所有子进程 process.on(\u0026#39;exit\u0026#39;, () =\u0026gt; { for (let key in workers) { workers[key].kill(); } }); 负载均衡 Node 默认提供的负载均衡机制是采用操作系统的抢占式策略，各个进程可以根据自己的繁忙度（CPU、I/O）来进行抢占；影响抢占的是 CPU 繁忙度。Node 在 v0.11.2 新增了轮叫调度（Round-Robin），可以通过设置 NODE_CLUSTER_SCHED_POLICY 环境变量来实现；轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作进程。\n1 2 3 4 cluster.schedulingPolicy = cluster.SCHED_RR; cluster.schedulingPolicy = cluster.SCHED_NONE; export NODE_CLUSTER_SCHED_POLICY=rr; export NODE_CLUSTER_SCHED_POLICY=none; cluster 模块用以解决多核 CPU 的利用率问题，它的底层实现还是 child_process，同时提供了较完善的 API 用以处理进程的健壮性问题，允许简易的创建共享服务器端口的子进程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const http = require(\u0026#39;http\u0026#39;); const cluster = require(\u0026#39;cluster\u0026#39;); const numCPUs = require(\u0026#39;os\u0026#39;).cpus().length; // cluster.isWorker = (\u0026#39;NODE_UNIQUE_ID\u0026#39; in process.env); // cluster.isMaster = (cluster.isWorker === false); // 如果是主进程 if (cluster.isMaster) { console.log(`主进程 ${process.pid} 正在运行`); // 修改 fork 默认行为 cluster.setupMaster({ // some config... }); // 衍生工作进程 for (let i = 0; i \u0026lt; numCPUs; i++) { cluster.fork(); } cluster.on(\u0026#39;exit\u0026#39;, (worker, code, signal) =\u0026gt; { console.log(`工作进程 ${worker.process.pid} 已退出`); }); } else { http .createServer((req, res) =\u0026gt; { res.writeHead(200); res.end(\u0026#39;你好世界\\n\u0026#39;); }) .listen(8000); console.log(`工作进程 ${process.pid} 已启动`); } 最佳实践 动静分离：将动态请求和静态请求分离后，Node 专注于处理动态请求； 启用缓存：消减同步 I/O 带来的时间浪费； 多进程架构：使用工具进行进程管理； 读写分离：将数据库进行主从设计，减少读写操作的相互影响； 记录日志：记录那些意外产生的异常错误； 文件分组：按照业务角色分组比按技术角色分组更好。 参考 The Node.js Best Practices List 构建自己的 Node.js 知识体系 ","date":"2020-08-02T00:00:00Z","image":"https://vikingama.github.io/img/cover/node.png","permalink":"https://vikingama.github.io/p/%E9%87%8D%E8%AF%BB%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-node.js/","title":"重读《深入浅出 Node.js》"},{"content":"回来一查，原来是作用域插槽的高阶（算是吧）用法；插槽就插槽呗，你给我装什么大尾巴狼。\n普通插槽与作用域插槽 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- NavigationLink 组件 --\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34; class=\u0026#34;nav-link\u0026#34;\u0026gt; \u0026lt;slot name=\u0026#34;icon\u0026#34; /\u0026gt; \u0026lt;slot\u0026gt;默认链接\u0026lt;/slot\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;!-- 使用 NavigationLink --\u0026gt; \u0026lt;navigation-link url=\u0026#34;/profile\u0026#34;\u0026gt; \u0026lt;template #icon\u0026gt; \u0026lt;font-awesome-icon name=\u0026#34;user\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;span\u0026gt;用户信息\u0026lt;/span\u0026gt; \u0026lt;/navigation-link\u0026gt; 作用域插槽就是给普通插槽添加了传递参数的能力；作用域插槽会被编译为一个返回 VNode 的函数，通过函数调用，可以将子组件的变量传递到父组件；很像 React 的 RenderProps 模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!-- ContactList 组件 --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex items-center spaced-y-6\u0026#34; v-for=\u0026#34;contact in contacts\u0026#34; :key=\u0026#34;contact.id\u0026#34; \u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;font-bold\u0026#34;\u0026gt; \u0026lt;!-- render-props --\u0026gt; {{ pseudoSlot({ contact }) }} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;font-bold\u0026#34;\u0026gt; \u0026lt;!-- scoped-slots --\u0026gt; \u0026lt;slot :item=\u0026#34;contact\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#39;ContactList\u0026#39;, props: [\u0026#39;pseudo-slot\u0026#39;], data() { return { contacts: [] }; }, created() { fetch(\u0026#39;/contacts.json\u0026#39;) .then(res =\u0026gt; res.json()) .then(data =\u0026gt; { this.contacts = data; }) .catch(console.error); } }; \u0026lt;/script\u0026gt; \u0026lt;!-- 使用 ContactList --\u0026gt; \u0026lt;contact-list :pseudo-slot=\u0026#34;({ contact }) =\u0026gt; contact.name.first\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;{ item }\u0026#34;\u0026gt; \u0026lt;a :href=\u0026#34;`/contacts/${item.id}`\u0026#34;\u0026gt;{{ item.name.last }}\u0026lt;/a\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/contact-list\u0026gt; 实现 Renderless 组件 Renderless 组件不会渲染具体内容，它仅仅管理一些状态和行为；将这些状态和行为通过作用域插槽暴露给父组件，由父组件对渲染内容进行控制。举个别人的 例子 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 \u0026lt;!-- Renderless 组件 --\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;value\u0026#39;], data() { return { tag: \u0026#39;\u0026#39; }; }, methods: { add() { if (!this.tag || this.tag.trim().length === 0) { return; } this.$emit(\u0026#39;input\u0026#39;, [...this.value, this.tag.trim()]); this.tag = \u0026#39;\u0026#39;; }, remove(tag) { this.$emit( \u0026#39;input\u0026#39;, this.value.filter(v =\u0026gt; v !== tag) ); } }, render() { return this.$scopedSlots.default({ list: this.value, add: this.add, // 传了不一定会用，只是为了适应多种业务场景 remove: this.remove, inputAttrs: { value: this.tag }, inputEvents: { input: e =\u0026gt; { this.tag = e.target.value; }, keydown: e =\u0026gt; { if (e.keyCode === 13) { e.preventDefault(); this.add(); } } } }); } }; \u0026lt;/script\u0026gt; \u0026lt;!-- 使用 Renderless --\u0026gt; \u0026lt;template\u0026gt; \u0026lt;renderless-component v-model=\u0026#34;tags\u0026#34;\u0026gt; \u0026lt;template #default=\u0026#34;{list, remove, inputAttrs, inputEvents}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;tags-input\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;tags-input-tag\u0026#34;\u0026gt; \u0026lt;span v-for=\u0026#34;item in list\u0026#34; :key=\u0026#34;item\u0026#34;\u0026gt;{{ item }}\u0026lt;/span\u0026gt; \u0026lt;button class=\u0026#34;tags-input-remove\u0026#34; @click=\u0026#34;remove\u0026#34;\u0026gt;\u0026amp;times;\u0026lt;/button\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;input class=\u0026#34;tags-input-text\u0026#34; placeholder=\u0026#34;add tag\u0026#34; v-bind=\u0026#34;inputAttrs\u0026#34; v-on=\u0026#34;inputEvents\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/renderless-component\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { tags: [\u0026#39;Testing\u0026#39;, \u0026#39;Design\u0026#39;] }; } }; \u0026lt;/script\u0026gt; 当项目中有很多逻辑层相同展示层不同的组件时，Renderless 组件可以很好地实现逻辑复用。\n使用 Renderless 请求数据（Vue） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 var CancelToken = axios.CancelToken; var source = CancelToken.source(); Vue.component(\u0026#39;fetch-data\u0026#39;, { props: { url: { type: String, required: true }, method: { type: String, default: \u0026#39;GET\u0026#39; }, params: { type: Object, default: {} }, body: { type: Object, default: {} } }, data() { return { loading: false, response: null, error: null }; }, watch: { url() { this.handleRequest(); }, params: { handler: this.handleRequest, deep: true }, body: { handler: this.handleRequest, deep: true } }, methods: { handleRequest() { source.cancel(); this.loading = true; axios({ url: this.url, method: this.method.toUpperCase(), params: this.params, data: this.body, cancelToken: source.token }) .then(({ data }) =\u0026gt; { this.response = data; }) .catch(error =\u0026gt; { this.error = error; }) .finally(() =\u0026gt; { this.loading = false; }); } }, created() { this.handleRequest(); }, render() { if (this.loading) { return this.$scopedSlots.default({ loading: true, response: null, error: null }); } return this.$scopedSlots.default({ loading: false, response: this.response, error: this.error }); } }); 使用 RederProps 请求数据（React） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class FetchData extends React.PureComponent { ct = axios.CancelToken.source(); state = { loading: true, data: null, error: null }; handleRequest = () =\u0026gt; { this.setState({ loading: true }); const cancelToken = this.ct.token; const { conf } = this.props; axios(...conf, cancelToken) .then(({ data }) =\u0026gt; this.setState({ data }) ) .catch(error =\u0026gt; this.setState({ error }) ) .finally(() =\u0026gt; { this.setState({ loading: false }); }); }; componentDidMount() { this.handleRequest(); } componentDidUpdate() { this.setState({ loading: true, data: null, error: null }); this.handleRequest(); } componentWillUnmount() { if (this.props.conf.methods.toLowerCase() === \u0026#39;get\u0026#39;) { this.ct.cancel(); } } render() { const { children } = this.props; // 需要判断是否为函数 return typeof children === \u0026#39;function\u0026#39; ? children(this.state) : children; } } const RenderWithFetchData = props =\u0026gt; ( \u0026lt;FetchData {...props}\u0026gt; {({ loading, data, error }) =\u0026gt; { if (loading) { return \u0026lt;Loading /\u0026gt;; } if (data) { return \u0026lt;UserProfile {...data} /\u0026gt;; } if (error) { return \u0026lt;Error {...error} /\u0026gt;; } }} \u0026lt;/FetchData\u0026gt; ); 参考 Renderless Components In Vue.js ","date":"2020-04-29T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/%E5%9F%BA%E4%BA%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E7%9A%84-renderless-%E7%BB%84%E4%BB%B6/","title":"基于作用域插槽的 Renderless 组件"},{"content":"编译上下文 tsconfig.json 用来给文件分组，告诉 TS 哪些文件是有效的，哪些是无效的；还包含有正在被使用的编译选项的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 { // 编译相关选项 \u0026#34;compilerOptions\u0026#34;: { /* 基础选项 */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, // 目标版本：\u0026#39;es3(default)\u0026#39;, \u0026#39;es5\u0026#39;, \u0026#39;es2015\u0026#39;, \u0026#39;es2016\u0026#39;, \u0026#39;es2017\u0026#39;, or \u0026#39;esnext\u0026#39; \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // 指定使用模块：\u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39;, \u0026#39;es2015\u0026#39; or \u0026#39;esnext\u0026#39; \u0026#34;lib\u0026#34;: [], // 指定要包含在编译中的库文件 \u0026#34;allowJs\u0026#34;: true, // 允许编译 js 文件 \u0026#34;checkJs\u0026#34;: true, // 报告 js 文件中的错误 \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // 指定 jsx 代码的生成：\u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, or \u0026#39;react\u0026#39; \u0026#34;declaration\u0026#34;: true, // 生成相应的 \u0026#39;.d.ts\u0026#39; 文件 \u0026#34;sourceMap\u0026#34;: true, // 生成相应的 \u0026#39;.map\u0026#39; 文件 \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, // 将输出文件合并为一个文件 \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, // 指定输出目录 \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, // 用来控制输出目录结构 --outDir \u0026#34;removeComments\u0026#34;: true, // 删除编译后的所有的注释 \u0026#34;noEmit\u0026#34;: true, // 不生成输出文件 \u0026#34;importHelpers\u0026#34;: true, // 从 tslib 导入辅助工具函数 \u0026#34;isolatedModules\u0026#34;: true, // 将每个文件做为单独的模块（与 \u0026#39;ts.transpileModule\u0026#39; 类似） /* 严格的类型检查选项 */ \u0026#34;strict\u0026#34;: true, // 启用所有严格类型检查选项 \u0026#34;noImplicitAny\u0026#34;: true, // 在表达式和声明上有隐含的 any 类型时报错 \u0026#34;strictNullChecks\u0026#34;: true, // 启用严格的 null 检查 \u0026#34;noImplicitThis\u0026#34;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \u0026#34;alwaysStrict\u0026#34;: true, // 以严格模式检查每个模块，并在每个文件里加入 \u0026#39;use strict\u0026#39; /* 额外的检查 */ \u0026#34;noUnusedLocals\u0026#34;: true, // 有未使用的变量时，抛出错误 \u0026#34;noUnusedParameters\u0026#34;: true, // 有未使用的参数时，抛出错误 \u0026#34;noImplicitReturns\u0026#34;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, // 不允许 switch 的 case 语句贯穿 /* 模块解析选项 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // 模块解析策略：\u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript) \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 用于解析非相对模块名称的基目录 \u0026#34;paths\u0026#34;: {}, // 模块名到基于 baseUrl 的路径映射的列表 \u0026#34;rootDirs\u0026#34;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \u0026#34;typeRoots\u0026#34;: [], // 包含类型声明的文件列表 \u0026#34;types\u0026#34;: [], // 需要包含的类型声明文件名列表 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \u0026#34;sourceRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到 TS 文件而不是源文件的位置 \u0026#34;mapRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到映射文件而不是生成文件的位置 \u0026#34;inlineSourceMap\u0026#34;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \u0026#34;inlineSources\u0026#34;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \u0026#34;experimentalDecorators\u0026#34;: true, // 启用装饰器 \u0026#34;emitDecoratorMetadata\u0026#34;: true // 为装饰器提供元数据的支持 }, // 显式指定需要编译的文件 \u0026#34;files\u0026#34;: [ \u0026#34;./some/file.ts\u0026#34; ], // 指定需要编译的文件，支持路径模式匹配 \u0026#34;include\u0026#34;: [ \u0026#34;./folder\u0026#34; ], // 指定不需要编译的文件，支持路径模式匹配 \u0026#34;exclude\u0026#34;: [ \u0026#34;./folder/**/*.spec.ts\u0026#34;, \u0026#34;./folder/someSubFolder\u0026#34; ] } 声明空间 在 TS 里存在两种声明空间：类型声明空间与变量声明空间。类型声明空间包含用来当做类型注解的内容：\n1 2 3 4 5 6 class Foo {} interface Bar {} type Bas = {}; let foo: Foo; let bar: Bar; let bas: Bas; 变量声明空间包含可用作变量的内容，在上文中 Foo 提供了一个类型 Foo 到类型声明空间，此外它同样提供了一个变量 Foo 到变量声明空间：\n1 2 3 4 5 class Foo {} const someVar = Foo; const someOtherVar = 123; const foo = 123; const bar: foo; // Error，foo 只能用在变量声明空间 类型兼容 类型兼容性用于确定一个类型是否能赋值给其他类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 两者类型不兼容 let str: string = \u0026#39;hello\u0026#39;; let num: number = 123; str = num; // Error num = str; // Error // 结构化类型只要求结构匹配 interface Point { x: number; y: number; } class Point2D { x: number; y: number; constructor(x, y) {} } let p: Point = new Point2D(1, 2); // Point2D 类型可以赋值给 Point 类型 interface Point3D { x: number; y: number; z: number; } let point: Point = { x: 0, y: 10 }; let point3D: Point3D = { x: 0, y: 10, z: 20 }; point = point3D; // OK point3D = point; // Error, Property \u0026#39;z\u0026#39; is missing in type \u0026#39;Point\u0026#39; but required in type \u0026#39;Point3D\u0026#39; 模块 在默认情况下，当你开始在一个新的 TS 文件中写下代码时，它处于全局命名空间中。如果你在相同的项目里创建了一个新的文件 bar.ts，TS 类型系统将会允许你使用变量 foo，就好像它在全局可用一样：\n1 2 3 4 // foo.ts const foo = 123; // bar.ts const bar = foo; // 可以获取到 foo 全局模块是危险的，推荐使用文件模块；文件模块也被称为外部模块，如果在你的 TS 文件的根级别位置含有 import 或者 export，那么它会在这个文件中创建一个本地的作用域。\n1 2 3 4 // foo.ts export const foo = 123; // bar.ts const bar = foo; // Error，找不到 foo 在项目中，一般会建立一个全局类型模块 global.d.ts，可以将通用的类型提取出来作为 lib.d.ts 的扩充。\ninterface 与 type 都可以描述一个对象或者函数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface User { name: string; age: number; eat(food: string): string; } interface NewUser { new (name: string, age?: number): User; } type User = { name: string; age: number; eat(food: string): string; }; type NewUser = new (name: string, age?: number): User; 都允许拓展，type 使用 \u0026ldquo;\u0026amp;\u0026quot;，interface 使用 extends： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // interface extends interface interface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } // type extends type type PartialPointX = { x: number }; type Point = PartialPointX \u0026amp; { y: number }; // interface extends type type PartialPointX = { x: number }; interface Point extends PartialPointX { y: number; } // type extends interface interface PartialPointX { x: number; } type Point = PartialPointX \u0026amp; { y: number }; 类都可以实现 interface 和 type： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface Point1 { x: number; y: number; } type Point2 = { x: number; y: number; }; class SomePoint1 implements Point1 { x = 1; y = 2; } class SomePoint2 implements Point2 { x = 1; y = 2; } type 可以声明基本类型别名、联合类型、元组等类型： 1 2 3 4 5 6 7 8 9 10 11 12 // 基本类型别名，给 string 类型起了一个叫 Name 的别名 type Name = string; // 联合类型 interface Dog { wong(); } interface Cat { miao(); } type Pet = Dog | Cat; // 具体定义数组每个位置的类型 type PetList = [Dog, Pet]; type 语句中可以使用 typeof 获取实例的类型进行赋值： 1 2 3 // 当你想获取一个变量的类型时，使用 typeof let div = document.createElement(\u0026#39;div\u0026#39;); type DivType = typeof div; // HTMLDivElement interface 能够声明合并（接口可以定义多次）： 1 2 3 4 5 6 7 interface User { name: string; age: number; } interface User { sex: string; } undefined、null、never 与 void 默认情况下 never、null 和 undefined 是所有类型的子类型；就是说你可以把 never、null 和 undefined 赋值给任何类型的变量。只有 never 可以赋值给 never 类型；当你指定了 strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自。void 表示没有任何类型，never 表示永远不存在的值的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function error(message: string): undefined; function error(message: string): null; function error(message: string): void; function error(message: string): never { throw new Error(message); } function infiniteLoop(): undefined; function infiniteLoop(): null; function infiniteLoop(): void; function infiniteLoop(): never { while (true) { // ... } } any 与 unknown any 类型本质上是类型系统的一个逃逸舱；允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。\n1 2 3 4 5 6 7 8 9 10 let value: any; value = \u0026#39;hello\u0026#39;; // OK value = true; // OK value = 42; // OK value = []; // OK value = {}; // OK value = null; // OK value = undefined; // OK value = Symbol(\u0026#39;type\u0026#39;); // OK value = new Error(); // OK 就像所有类型都可以被归为 any，所有类型也都可以被归为 unknown；这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型。\n1 2 3 4 5 6 7 8 9 10 let value: unknown; value = \u0026#39;hello\u0026#39;; // OK value = true; // OK value = 42; // OK value = []; // OK value = {}; // OK value = null; // OK value = undefined; // OK value = Symbol(\u0026#39;type\u0026#39;); // OK value = new Error(); // OK 对 value 变量的所有赋值都被认为是类型正确的。\n1 2 3 4 5 6 7 let value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error unknown 类型只能被赋值给 any 类型和 unknown 类型本身，只有能够保存任意类型值的容器才能保存 unknown（未知）类型的值。\n1 2 3 4 5 6 let value: unknown; value.foo.bar; // Error value.trim(); // Error value(); // Error new value(); // Error value[0][1]; // Error TS 不允许我们对类型为 unknown 的值执行任意操作；我们必须通过类型保护、断言类型等方式缩小 unknown 的类型范围，才能对其进行操作。\n1 2 3 4 5 6 7 8 9 10 11 let unknownValue: unknown; let stringValue: string; let numberValue: number; if (isObject(unknownValue)) { unknownValue.valueOf(); } stringValue = unknownValue as string; numberValue = \u0026lt;number\u0026gt;unknownValue; function isObject(value: any): value is object { return Object.prototype.toString.call(value) === \u0026#39;[object Object]\u0026#39;; } 在联合类型中，unknown 类型会吸收任何类型；如果任一组成类型是 unknown，联合类型也会相当于 unknown；在交叉类型中，任何类型都可以吸收 unknown 类型，任何类型与 unknown 相交不会改变结果类型：\n1 2 3 4 5 6 7 8 9 10 type UnionType0 = unknown | any; // any type UnionType1 = unknown | null; // unknown type UnionType2 = unknown | undefined; // unknown type UnionType3 = unknown | string; // unknown type UnionType4 = unknown | number[]; // unknown type IntersectionType0 = unknown \u0026amp; any; // any type IntersectionType1 = unknown \u0026amp; null; // null type IntersectionType2 = unknown \u0026amp; undefined; // undefined type IntersectionType3 = unknown \u0026amp; string; // string type IntersectionType4 = unknown \u0026amp; number[]; // number[] private 与 protected 当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 成员在派生类中仍然可以访问。\nTS 使用的是结构性类型系统；当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的；当我们比较带有 private 或 protected 成员的类型的时候，如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的；对于 protected 成员也使用这个规则。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Parent { public name: string; private age: number; protected job: string; readonly sex: boolean; constructor(name, age, job, sex) { this.name = name; this.age = age; this.job = job; this.sex = sex; } } class Child extends Parent { constructor(name, age, job, sex) { super(name, age, job, sex); this.name = name; this.age = age; // Error，私有属性只能在类内部访问 this.job = job; this.sex = sex; // Error，sex 属性是只读的，不能修改 } } let p: Parent = new Parent(\u0026#39;lee\u0026#39;, 18, \u0026#39;developer\u0026#39;, true); console.log(p.age); // Error，私有属性只能在类内部访问 console.log(p.job); // Error，受保护属性只能在类及其子类中访问 instanceof 通过判断构造函数进行类型保护。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 interface Animal { type: string; speak: () =\u0026gt; string; [prop: string]: any; } class Cat implements Animal { type = \u0026#39;猫\u0026#39;; speak() { return \u0026#39;喵喵\u0026#39;; } catchMouse() { console.log(\u0026#39;捉老鼠\u0026#39;); } } class Dog implements Animal { type = \u0026#39;狗\u0026#39;; speak() { return \u0026#39;汪汪\u0026#39;; } watchDoor() { console.log(this.speak()); } } let miao = new Cat(); let wang = new Dog(); function selectAnimal(animal: Animal) { if (animal instanceof Dog) { animal.watchDoor(); } else if (animal instanceof Cat) { animal.catchMouse(); } else { animal.speak(); } } selectAnimal(miao); selectAnimal(wang); typeof typeof 操作符可以用来获取一个变量声明或对象的类型，也可以用来类型保护（基本类型）。\n1 2 3 4 5 6 7 8 9 10 interface Person { name: string; age?: number; } const sam: Person = { name: \u0026#39;sam\u0026#39;, age: 32 }; type SamType = typeof sam; // Person function toArray\u0026lt;T\u0026gt;(x: T): Array\u0026lt;T\u0026gt; { return [x]; } type ToArrayType = typeof toArray; // \u0026lt;T\u0026gt;(x: T) =\u0026gt; T[] keyof keyof 操作符可以用于获取某种类型的所有键，其返回类型是联合类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Person { name: string; age?: number; } type KeyoOfPerson = keyof Person; const p1: KeyoOfPerson = \u0026#39;name\u0026#39;; const p2: KeyoOfPerson = \u0026#39;age\u0026#39;; type KeyoOfPersonArray = keyof Array\u0026lt;Person\u0026gt;; const p3: KeyoOfPersonArray = \u0026#39;length\u0026#39;; const p4: KeyoOfPersonArray = \u0026#39;push\u0026#39;; type keys = keyof { [props: string]: string }; // TS 支持两种索引，『字符串索引』和『数字索引』 const p5: keys = \u0026#39;string\u0026#39;; const p6: keys = \u0026#39;number\u0026#39;; infer infer 的作用是让 TS 自己推断，并将推断的结果存储到一个临时变量中，并且只能用于 extends 语句中；它与泛型的区别在于，泛型是声明一个“参数”，而 infer 是声明一个“中间变量”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type Unpacked\u0026lt;T\u0026gt; = T extends (infer U)[] ? U : T extends (...args: any[]) =\u0026gt; infer U ? U : T extends Promise\u0026lt;infer U\u0026gt; ? U : T; type T0 = Unpacked\u0026lt;string\u0026gt;; // string type T1 = Unpacked\u0026lt;string[]\u0026gt;; // string type T2 = Unpacked\u0026lt;() =\u0026gt; string\u0026gt;; // string type T3 = Unpacked\u0026lt;Promise\u0026lt;string\u0026gt;\u0026gt;; // string type T4 = Unpacked\u0026lt;Promise\u0026lt;string\u0026gt;[]\u0026gt;; // Promise\u0026lt;string\u0026gt; type T5 = Unpacked\u0026lt;Unpacked\u0026lt;Promise\u0026lt;string\u0026gt;[]\u0026gt;\u0026gt;; // string type CustomReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer R ? R : any; type T6 = CustomReturnType\u0026lt;() =\u0026gt; number\u0026gt;; // number in 用来遍历枚举类型或类型保护（属性 key）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 遍历枚举 type Keys = \u0026#39;a\u0026#39; | \u0026#39;b\u0026#39; | \u0026#39;c\u0026#39;; type Obj = { [p in Keys]: any; }; // 类型保护 interface Boss { name: string; worth: number; } interface Employee { name: string; salary: number; } type Human = Boss | Employee; function detectBoss(human: Human) { if (\u0026#39;worth\u0026#39; in human) { console.log(human.worth); } else { console.log(\u0026#39;not boss\u0026#39;); } } is is 关键字用来创建自定义类型保护：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Foo { foo: number; common: string; } interface Bar { bar: number; common: string; } function isFoo(arg: Foo | Bar): arg is Foo { return typeof (arg as Foo).foo === \u0026#39;number\u0026#39;; } function example(val: Foo | Bar) { if (isFoo(val)) { val.foo++; } else { val.bar--; } } example({ bar: 123, common: \u0026#39;456\u0026#39; }); 参考 TypeScript: Interfaces VS Types TypeScript 3.0: unknown 类型 TypeScript 强大的类型别名 ","date":"2020-04-24T00:00:00Z","image":"https://vikingama.github.io/img/cover/typescript.png","permalink":"https://vikingama.github.io/p/typescript-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%E4%BA%8C/","title":"TypeScript 复习总结（二）"},{"content":"与 Hooks 的区别 更符合 JS 习惯； 对调用顺序不敏感； 在每次渲染的过程中不会重复调用，对垃圾回收机制的压力更小； 避免了内联处理程序导致子组件重复渲染的问题（在 React 中需要使用 useCallback）； 不需要像 useEffect 和 useMemo 那样需要正确的设置依赖，Vue 会自动的追踪。 值传递与引用传递 新的 API 非常依赖引用传递，这样 Vue 才能及时捕获数据变化；这也是为什么 toRef 会将普通类型数据包装成对象的原因；reactive 包装的对象在解构时为了保持响应性需要用 toRefs 包装也是这个原因。\nsetup 作为 Composition API 在 Vue 组件中的入口；它会在组件实例被创建，props 完成初始化之后调用；和模板一起使用时，返回的对象会自动合并到渲染上下文中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ count }} {{ object.foo }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive } from \u0026#39;vue\u0026#39;; export default { setup() { // ref 在 setup 中返回并在模板中使用时会自动解构，不需要通过 count.value 访问 const count = ref(0); const object = reactive({ foo: \u0026#39;bar\u0026#39; }); return { count, object }; } }; \u0026lt;/script\u0026gt; setup 也可以返回一个渲染函数，渲染函数可以直接使用所在作用域中的响应式状态。\n1 2 3 4 5 6 7 8 import { h, ref, reactive } from \u0026#39;vue\u0026#39;; export default { setup() { const count = ref(0); const object = reactive({ foo: \u0026#39;bar\u0026#39; }); return () =\u0026gt; h(\u0026#39;div\u0026#39;, [count.value, object.foo]); } }; setup 的第一个参数接收 props。\n1 2 3 4 5 6 7 8 9 10 11 12 export default { props: { name: String }, setup(props) { // props 对象是响应式的并且是不可变（immutable）对象，不要尝试去修改它 console.log(props.name); watchEffect(() =\u0026gt; { console.log(`name is: ` + props.name); }); } }; 不要对 props 进行解构，这样就不再是响应式对象了。\n1 2 3 4 5 6 7 8 9 10 11 export default { props: { name: String }, setup({ name }) { watchEffect(() =\u0026gt; { // props 变化时，不会重新执行 console.log(`name is: ` + name); }); } }; 第二个参数是 context 对象，context 中包含着一些属性；context 可以被解构。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const OneComponent = { setup(props, context) { context.attrs; context.slots; context.emit; } }; const TwoComponent = { setup(props, { attrs }) { /** * 之所以没有把 props 作为 context 的一个属性的原因： * 1. props 更常用 * 2. 可以更好的用 TS 对其类型做限制 */ function onClick() { console.log(attrs.foo); // setup 中无法访问 this this \u0026amp;\u0026amp; console.log(this); } } }; setup 的类型：\n1 2 3 4 5 6 7 8 9 interface Data { [propsName: string]: unknown; } interface SetupContext { attrs: Data; slots: Slots; emit: (event: string, ...args: unknown[]) =\u0026gt; void; } function setup(props: Data, context: SetupContext): Data; reactive reactive 接受一个对象并返回一个响应式代理，相当于 2.x 版本的 Vue.observable({})。\n1 2 3 // 响应式转换是深层的，会影响所有嵌套的属性 function reactive\u0026lt;T extends object\u0026gt;(raw: T): T; const obj = reactive({ count: 0 }); ref ref 的返回值是一个响应式的可变对象，对象只有一个属性 value；如果传入一个对象，这个对象会被 reactive 方法进行响应式转换。\n1 2 3 4 5 6 7 8 9 10 11 const count = ref(0); const otherCount = ref(2); // 如果 ref 作为响应式对象的一个属性，也会自动展开内部的 value，就像普通属性一样 const state = reactive({ count }); console.log(state.count); // 0 state.count = 1; console.log(count.value); // 1 // count 被替换了，两个 ref 之间并没有建立任何联系 state.count = otherCount; console.log(state.count); // 2 console.log(count.value); // 1 ref 在 setup 中返回并在模板中使用时会自动解构，不需要通过 count.value 访问；如果从响应式数组或其他响应式的数据类型中获取 ref 的值时，还是需要访问 value 属性。\n1 2 3 4 5 const arr = reactive([ref(0)]); const map = reactive(new Map([[\u0026#39;foo\u0026#39;, ref(0)]])); // 需要访问 value 属性 console.log(arr[0].value); console.log(map.get(\u0026#39;foo\u0026#39;).value); ref 类型：\n1 2 3 4 5 6 interface Ref\u0026lt;T\u0026gt; { value: T; } function ref\u0026lt;T\u0026gt;(value: T): Ref\u0026lt;T\u0026gt;; const foo = ref\u0026lt;string | number\u0026gt;(\u0026#39;foo\u0026#39;); foo.value = 123; computed 传入一个 getter 函数并返回一个不可变的响应式的 ref 对象。\n1 2 3 4 const count = ref(1); const plusOne = computed(() =\u0026gt; count.value + 1); console.log(plusOne.value); // 2 plusOne.value++; // 报错 如果传入一个有 getter 和 setter 函数的对象，则返回一个可写的 ref 对象。\n1 2 3 4 5 6 7 8 9 10 11 const count = ref(1); const plusOne = computed({ get() { return count.value + 1; }, set(val) { count.value = val - 1; } }); plusOne.value = 1; console.log(count.value); // 0 computed 的类型：\n1 2 3 4 5 function computed\u0026lt;T\u0026gt;(getter: () =\u0026gt; T): Readonly\u0026lt;Ref\u0026lt;Readonly\u0026lt;T\u0026gt;\u0026gt;\u0026gt;; function computed\u0026lt;T\u0026gt;(options: { get: () =\u0026gt; T; set: (value: T) =\u0026gt; void; }): Ref\u0026lt;T\u0026gt;; readonly 返回一个原始对象的只读代理，代理中所有嵌套的属性都将是只读的。\n1 2 3 4 5 6 7 8 9 const original = reactive({ count: 0 }); const copy = readonly(original); watchEffect(() =\u0026gt; { console.log(copy); }); // 改变原始对象会触发 watcher 的执行，因为 watcher 依赖了原始对象的只读代理 original.count++; // 改变只读对象会报警告并失败 copy.count++; watchEffect 在追踪响应式依赖时会立即执行，当依赖发生变化时会重新运行；就像 React.useEffect 的自动设置依赖的版本。\n1 2 3 4 5 6 7 const count = ref(0); watchEffect(() =\u0026gt; { console.log(count.value); // 0, 1, 2, ... }); setTimeout(() =\u0026gt; { count.value++; }, 1000); 当 watchEffect 在 setup 或生命周期函数中调用时，watcher 会被关联到组件的生命周期上，当组件被卸载时会自动停止执行。当然它会返回一个函数，调用这个函数也可以停止 watcher。\n1 2 3 4 const stopWatcher = watchEffect(() =\u0026gt; { console.log(\u0026#39;...\u0026#39;); }); stopWatcher(); 有时 watchEffect 中会进行一些异步的副作用操作，当副作用失效时需要进行一些清理工作（比如，在副作用执行完毕之前，依赖发生了变化）；副作用函数可以接受一个 onInvalidate 函数，这个函数会在这些情况下被调用：\n副作用将被重新执行的时候； watcher 被停止的时候。 鹅，好像 React.useEffect 的返回函数。\n1 2 3 4 5 6 7 watchEffect(onInvalidate =\u0026gt; { const token = performAsyncOperation(id.value); onInvalidate(() =\u0026gt; { // 终止之前正在进行的异步操作 token.cancel(); }); }); Vue 的响应式系统会缓冲失效的副作用并且异步地释放掉他们来避免在一个事件循环中进行太多非必要的重复调用；在 Vue 内部，组件更新函数也是一个被观察的操作，当一个用户操作被加入到队列中时，在组件更新之后，它总是会被调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ count }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { setup() { const count = ref(0); watchEffect(() =\u0026gt; { /** * 将在初始化时同步运行，初始化运行会在组件挂载之前 * 当 count 改变时，回调函数会在组件更新之后调用 */ console.log(count.value); }); return { count }; } }; \u0026lt;/script\u0026gt; watchEffect 的初始化运行发生在组件挂载之前，如果想要在 watchEffect 中访问 DOM/refs，需要把 watchEffect 放在 onMounted 中。\n1 2 3 4 5 onMounted(() =\u0026gt; { watchEffect(() =\u0026gt; { // 这里可以访问 DOM }); }); watchEffect 可以接受第二个参数来控制副作用的执行时机。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 同步调用 watchEffect(() =\u0026gt; {}, { flush: \u0026#39;sync\u0026#39; // 默认值是 post }); // 在组件更新之前 watchEffect(() =\u0026gt; {}, { flush: \u0026#39;pre\u0026#39; }); // 调试 watchEffect(() =\u0026gt; {}, { // 这两个函数只在开发环境会被执行 onTrack() { // 当响应式属性或者 ref 作为一个依赖被追踪到时调用 }, onTrigger() { // 当依赖更新 watcher 回调被调用后调用 debugger; } }); watchEffect 的类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 type StopHandle = () =\u0026gt; void; type InvalidateCbRegistrator = (invalidate: () =\u0026gt; void) =\u0026gt; void; interface DebuggerEvent { effect: ReactiveEffect; target: any; type: OperationTypes; key: string | symbol | undefined; } interface WatchEffectOptions { flush?: \u0026#39;pre\u0026#39; | \u0026#39;post\u0026#39; | \u0026#39;sync\u0026#39;; onTrack?: (event: DebuggerEvent) =\u0026gt; void; onTrigger?: (event: DebuggerEvent) =\u0026gt; void; } function watchEffect( effect: (onInvalidate: InvalidateCbRegistrator) =\u0026gt; void, options?: WatchEffectOptions ): StopHandle; watch 和 2.x 的 this.$watch 一模一样，用来观察数据并（惰性的）执行对应的副作用：\n可以同时获取状态改变前后的值； watch 是惰性的（对比计算值前后有没有改变）； 更加有针对性，也就是说可以明确指定要追踪的依赖。 watch 可以监视 getter、一个或多个 ref：\n1 2 3 4 5 6 7 8 9 10 11 12 const state = reactive({ count: 0 }); const count = ref(0); watch( () =\u0026gt; state.count, (count, prevCount) =\u0026gt; {} ); watch(count, (count, prevCount) =\u0026gt; {}); watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) =\u0026gt; { /* ... */ }); 取消观察、取消副作用、时机控制和调试方面，watch 的行为和 watchEffect 行为一致。\nwatch 的类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 type WatcherSource\u0026lt;T\u0026gt; = Ref\u0026lt;T\u0026gt; | (() =\u0026gt; T); type MapSources\u0026lt;T\u0026gt; = { [K in keyof T]: T[K] extends WatcherSource\u0026lt;infer V\u0026gt; ? V : never; }; interface WatchEffectOptions { flush?: \u0026#39;pre\u0026#39; | \u0026#39;post\u0026#39; | \u0026#39;sync\u0026#39;; onTrack?: (event: DebuggerEvent) =\u0026gt; void; onTrigger?: (event: DebuggerEvent) =\u0026gt; void; } interface WatchOptions extends WatchEffectOptions { immediate?: boolean; // 默认是 false deep?: boolean; } function watch\u0026lt;T\u0026gt;( source: WatchSource\u0026lt;T\u0026gt;, callback: ( value: T, oldValue: T, onInvalidate: InvalidateCbRegistrator ) =\u0026gt; void, options?: WatchOptions ): StopHandle; function watch\u0026lt;T extends WatcherSource\u0026lt;unknown\u0026gt;[]\u0026gt;( source: T, callback: ( values: MapSources\u0026lt;T\u0026gt;, oldValues: MapSources\u0026lt;T\u0026gt;, onInvalidate: InvalidateCbRegistrator ) =\u0026gt; void, options?: WatchOptions ): StopHandle; 生命周期 生命周期函数只能用在 setup 里，因为它们依赖内部的全局状态来定位当前活跃的组件实例，否则会报错。\n对比 2.x 的生命周期函数：\nbeforeCreate -\u0026gt; setup created -\u0026gt; setup beforeMount -\u0026gt; onBeforeMount mounted -\u0026gt; onMounted beforeUpdate -\u0026gt; onBeforeUpdate updated -\u0026gt; onUpdated beforeDestroy -\u0026gt; onBeforeUnmount destroyed -\u0026gt; onUnmounted errorCaptured -\u0026gt; onErrorCaptured 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { onMounted, onUpdated, onUnmounted } from \u0026#39;vue\u0026#39;; const MyComponent = { setup() { onMounted(() =\u0026gt; { console.log(\u0026#39;mounted!\u0026#39;); }); onUpdated(() =\u0026gt; { console.log(\u0026#39;updated!\u0026#39;); }); onUnmounted(() =\u0026gt; { console.log(\u0026#39;unmounted!\u0026#39;); }); } }; 3.0 还新赠送了两个钩子它们都接收 DebuggerEvent 作为参数，用来检查是哪些依赖导致组件重新渲染的：\nonRenderTracked onRenderTriggered 1 2 3 4 5 export default { onRenderTriggered(e) { debugger; } }; 依赖注入 行为和 2.x 的 provide/inject 一样；两者需要在 setup 中使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { provide, inject } from \u0026#39;vue\u0026#39;; const ThemeSymbol = Symbol(); const Ancestor = { setup() { provide(ThemeSymbol, \u0026#39;dark\u0026#39;); } }; const Descendent = { setup() { // inject 的第二个参数是一个缺省值 const theme = inject(ThemeSymbol, \u0026#39;light\u0026#39;); return { theme }; } }; 可以注入一个 ref 来保持响应性，也可以传入一个响应式对象。\n1 2 3 4 5 6 7 8 // provider const themeRef = ref(\u0026#39;dark\u0026#39;); provide(ThemeSymbol, themeRef); // comsumer const theme = inject(ThemeSymbol, ref(\u0026#39;light\u0026#39;)); watchEffect(() =\u0026gt; { console.log(`theme set to: ${theme.value}`); }); provide/inject 的类型：\n1 2 3 4 interface InjectionKey\u0026lt;T\u0026gt; extends Symbol {} function provide\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string, value: T): void; function inject\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string): T | undefined; function inject\u0026lt;T\u0026gt;(key: InjectionKey\u0026lt;T\u0026gt; | string, defaultValue: T): T; Vue 提供一个继承于 Symbol 的 InjectionKey 接口：\n1 2 3 4 5 6 import { InjectionKey, provide, inject } from \u0026#39;vue\u0026#39;; const key: InjectionKey\u0026lt;string\u0026gt; = Symbol(); // provider provide(key, \u0026#39;foo\u0026#39;); // comsumer const foo = inject(key, \u0026#39;bar\u0026#39;); refs 在新 API 中，响应式 refs 和 模板 refs 的概念是统一的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div ref=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39;; export default { setup() { const root = ref(null); // 在初始化时，DOM 元素会赋值给 ref onMounted(() =\u0026gt; { console.log(root.value); // \u0026lt;div/\u0026gt; }); return { root }; } }; \u0026lt;/script\u0026gt; 在 VirtualDOM 的 patch 算法中，如果一个 VNode 的 ref 和渲染上下文中的 ref 对应，那么 VNode 对应的元素或组件实例会赋值给这个 ref；这发生在 VDOM 挂载/更新的过程中，所以 templateRefs 只会在渲染时被赋值。\n和 JSX/渲染函数 一起使用：\n1 2 3 4 5 6 7 8 9 10 11 12 export default { setup() { const root = ref(null); // 渲染函数 return () =\u0026gt; h(\u0026#39;div\u0026#39;, { ref: root }); // JSX return () =\u0026gt; \u0026lt;div ref={root} /\u0026gt;; } }; 在 v-for 中使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;template\u0026gt; \u0026lt;div v-for=\u0026#34;(item, i) in list\u0026#34; :ref=\u0026#34;el =\u0026gt; { divs[i] = el }\u0026#34;\u0026gt;{{ item }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { ref, reactive, onBeforeUpdate } from \u0026#39;vue\u0026#39;; export default { setup() { const list = reactive([1, 2, 3]); const divs = ref([]); onBeforeUpdate(() =\u0026gt; { divs.value = []; }); return { list, divs }; } }; \u0026lt;/script\u0026gt; unref 如果传入的是 ref，返回 ref.value；否则返回参数自身；val = isRef(val) ? val.value : val 的语法糖。\n1 2 3 function useFoo(x: number | Ref\u0026lt;number\u0026gt;) { const unwrapped = unref(x); // 黑人问号，这是为了保持 Vue API 巨多的传统吗？ } toRef 使用响应式对象中的某个属性来创建 ref，这个 ref 会和那个属性保持响应式的连接。\n1 2 3 4 5 6 7 8 9 10 const state = reactive({ foo: 1, bar: 2 }); const fooRef = toRef(state, \u0026#39;foo\u0026#39;); // 两个会相互影响 fooRef.value++; console.log(state.foo); // 2 state.foo++; console.log(fooRef.value); // 3 toRef 这个时候最有用：\n1 2 3 4 5 export default { setup(props) { useSomeFeature(toRef(props, \u0026#39;foo\u0026#39;)); } }; toRefs 将响应式对象转化为普通对象，这个对象的每个属性都是一个 ref，指向原来的对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const state = reactive({ foo: 1, bar: 2 }); /** * Type of stateAsRefs: * { * foo: Ref\u0026lt;number\u0026gt;, * bar: Ref\u0026lt;number\u0026gt; * } */ const stateAsRefs = toRefs(state); // ref 和原对象中对应的属性连接 state.foo++; console.log(stateAsRefs.foo); // 2 stateAsRefs.foo.value++; console.log(state.foo); // 3 toRefs 这个时候最有用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function useFeatureX() { const state = reactive({ foo: 1, bar: 2 }); return toRefs(state); } export default { setup() { // 可以解构而不会丢失响应性 const { foo, bar } = useFeatureX(); return { foo, bar }; } }; 其他 isProxy，判断对象是否是 reactive/readonly 创建的一个代理； isReactive，判断对象是否是 reactive 创建的一个响应式代理； isReadonly，判断对象是否是 readonly 创建的一个只读代理； isRef，判断值是否为 ref 对象。 ","date":"2020-04-23T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/vue-composition-api/","title":"Vue Composition API"},{"content":"改变 Vue 新版本根据 社区 的意见主要做了以下几点：\n性能上的提升； Vue 本身的 TreeShaking 支持； Composition API； Fragment、Teleport、Suspense； CustomRender API； TS Support； IE11 Support。 性能 新版本重写了 VisualDOM，具体怎么工作可以看 这里 。\n当 Vue 将模板编译为 render 函数时，会将模板中绑定数据的部分做上标记（Patch Flag）；当数据变化时，Vue 将只关注会变化的部分。Vue 还引入了 HoistStatic，将模板中静态的部分抽离到 render 函数外部，提高性能。\n在服务器渲染时，静态内容会被编译成字符串：\n编译时，自动进行 useMemo 和 useCallback 优化：\nTreeShaking Vue 本身支持了 TreeShaking，除了响应式系统和 diff 系统外，其他没用到的功能都可以在打包时剥离掉。\n如果对兼容性没要求，甚至可以去掉对 Vue/2 的支持。\nComposition API Vue 3.0 将同时支持 Options API 和 Composition API ，逻辑复用不再需要 mixin 了；代码逻辑会更加清晰，灵活性也会更高。\nFragment Vue 3.0 不再要求模板中必须要有根节点了，模板现在可以直接是一段文字或者多个节点，Vue 会将多个节点用 Fragment 包裹。\nIE11 Vue 3.0 将为 IE11 建立专门的 build，开发者可以选择不同的版本；2.7 将会是 2.x 时代的最后一个版本，有 18 个月的支持期。\n","date":"2020-04-22T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/vue-3.0-%E6%9D%A5%E4%BA%86/","title":"Vue 3.0 来了"},{"content":"数据格式 弹幕一般用在直播或者视频播放的场景中，是评论的一种变形；按照我的理解，它的数据格式应该是：\n1 2 3 4 5 { [时间戳/视频对应的秒数]: [对应时间点的弹幕列表], 31415926: [{name: \u0026#34;张三\u0026#34;, content: \u0026#34;哈哈哈哈哈\u0026#34;}, {}, {}...], ... } 发布弹幕 当用户发布弹幕时，获取当前视频的时间点，将弹幕插入到弹幕列表中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 addBarrage = () =\u0026gt; { let barrage = inputEle.value; if (barrage \u0026amp;\u0026amp; barrage.trim().length \u0026gt; 0) { let now = this.getCurrentTime(); let content = barrage.trim(); if (this.barrages[now]) { this.barrages[now].push({ name: \u0026#39;麻辣个鸡\u0026#39;, // 当前用户的用户名 content }); } else { this.barrages[now] = [ { name: \u0026#39;麻辣个鸡\u0026#39;, content } ]; } inputEle.value = \u0026#39;\u0026#39;; } }; 弹幕展示 实时获取视频的播放状态，当视频播放时，获取视频播放位置；当播放时间等于弹幕时间时，展示对应弹幕：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 这个函数要放到计时器里执行 appendBarrage = () =\u0026gt; { let list = this.barrages[this.getCurrentTime()] || null; if (Array.isArray(list)) { list.forEach((item, index) =\u0026gt; { this.id = this.id + 1; let id = this.id; let node = this.generateSpan(item, index, id); // 生成每条弹幕的容器 sectioner.append(node); // 弹幕最短的运动长度就是视频窗口宽度加上弹幕本身的长度了 let temp = document.querySelector(`[data-id=\u0026#34;${id}\u0026#34;]`); let where = temp.dataset.where; // 使用 transform 性能比较好 temp.style.transform = `translate3D(-${temp.clientWidth}px, ${ where * 20 }px, 0)`; // 当弹幕弹出屏幕时，可将弹幕移除 DOM 提升性能 temp.addEventListener( \u0026#39;transitionend\u0026#39;, function () { this.remove(true); }, { once: true } ); }); } }; 怎么展示弹幕呢？可以根据视频的高度和弹幕的高度，设置相应的弹幕轨道：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 计算轨道数 setFloors = () =\u0026gt; { this.floor = Math.floor(videoEle.clientHeight / 20) - 1; }; generateSpan = (item, index, id) =\u0026gt; { let where = 0; let span = document.createElement(\u0026#39;span\u0026#39;); where = this.where; // 分层摆放每条弹幕 if (this.where \u0026gt; this.floor - 1) { this.where = 0; } else { this.where++; } span.innerText = `${item.name}: ${item.content}`; span.dataset.id = `${id}`; span.dataset.where = `${where}`; span.style.zIndex = `${index}`; span.style.transform = `translate3D(${videoEle.clientWidth}px, ${ where * 20 }px, 0)`; return span; }; 未完待续 DEMO 在 这里 ，暂停视频时当前时间对应的弹幕停止滚动还没想好怎么实现（初步想法是使用 animation 替换 transform，因为 animation-play-state 可以控制动画的状态）。\n","date":"2020-04-20T00:00:00Z","image":"https://vikingama.github.io/img/cover/interaction.png","permalink":"https://vikingama.github.io/p/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BC%B9%E5%B9%95%E6%95%88%E6%9E%9C/","title":"如何实现弹幕效果？"},{"content":" 观察者模式 观察者模式就好个体奶农（Subject）和个人（Observers）的关系；奶农负责统计有多少人订了产品（Subscribe），个人都会有一个相同拿牛奶的方法（Event）；奶农有新奶了就负责调用这个方法（Fire Event）。\n观察者模式是一对多的关系，多个观察者对应一个对象；当被观察对象更新时会通知所有观察者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 观察者 class Observer { constructor(name) { this.name = name; this.fn = null; } update() { console.log(`我是${this.name}，听说被观察者更新了...`); typeof this.fn === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; this.fn(); } } // 被观察对象 class Subject { list = []; // 保存所有观察者 addObserver(observer) { // 添加新增的观察者 this.list.push(observer); } notifyObservers() { // 通知观察者，我更新了 this.list.forEach(item =\u0026gt; { item.update(); }); } } let subject = new Subject(); let zhangsan = new Observer(\u0026#39;张三\u0026#39;); let lisi = new Observer(\u0026#39;李四\u0026#39;); let wangwu = new Observer(\u0026#39;王五\u0026#39;); zhangsan.fn = () =\u0026gt; { console.log(\u0026#39;哈哈\u0026#39;); }; lisi.fn = () =\u0026gt; { console.log(\u0026#39;呵呵\u0026#39;); }; wangwu.fn = () =\u0026gt; { console.log(\u0026#39;嗨嗨\u0026#39;); }; // 添加订阅 subject.addObserver(zhangsan); subject.addObserver(lisi); subject.addObserver(wangwu); // 通知更新 subject.notifyObservers(); 发布订阅模式 发布订阅模式就好像报社（Publishers）、邮局（Topic/Event Channel）和个人（Subscribers）的关系；报纸的订阅（Subscribe）和分发（Fire Event）是由邮局来完成的，报社只负责将报纸发送给邮局（Publish Topic/Event）。\n发布订阅模式是多对多的关系，可以有多个发布者多个观察者；每个发布者对应着多个观察者，每个观察者对应着多个发布者。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Subscriber { constructor(name) { this.name = name; this.fn = null; } subscribe(channel) { channel.addSubscriber(this.name, this); } update() { console.log(`我是${this.name}，我的快递到了...`); typeof this.fn === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; this.fn(); } } class Publisher { constructor(type) { this.type = type; } publishTopic(channel) { channel.notifySubscribers(this.type); } } class Channel { list = {}; addSubscriber(type, subscriber) { let list = this.list[type] || []; list.push(subscriber); this.list[type] = list; } notifySubscribers(type) { this.list[type].forEach(item =\u0026gt; { item.update(); }); } } let channel = new Channel(); let zhangsan = new Subscriber(\u0026#39;张三\u0026#39;); let lisi = new Subscriber(\u0026#39;李四\u0026#39;); let wangwu = new Publisher(\u0026#39;王五\u0026#39;); let zhaoliu = new Publisher(\u0026#39;赵六\u0026#39;); zhangsan.subscribe(channel); lisi.subscribe(channel); wangwu.publishTopic(channel); zhaoliu.publishTopic(channel); 回归 Vue 对于响应式对象，Vue 会在对象属性的 getter 中收集属性对应的依赖，在对象属性的 setter 中通知对应依赖进行更新；一个数据对象对应多个依赖，数据是被观察目标，视图、计算属性、侦听器这些是观察者/依赖者。\n参考 不好意思，观察者模式跟发布订阅模式就是不一样 介绍下观察者模式和订阅发布模式的区别 ","date":"2020-04-18T00:00:00Z","image":"https://vikingama.github.io/img/cover/patterns.png","permalink":"https://vikingama.github.io/p/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","title":"观察者模式与发布订阅模式"},{"content":"HTTP 与 TCP/IP HTTP（Hypertext Transfer Protocol）是以 TCP/IP（Transmission Control Protocol/Internet Protocol）协议族为基础的，属于 TCP/IP 内部的一个子集；TCP/IP 协议族按层次分别分：\n应用层，预存了各类通用的应用服务（比如：FTP、DNS、ARP），HTTP 也处于该层； 传输层，提供处于网络连接中的两台计算机之间的数据传输； 网络层，负责数据包的产生以及 IP 数据包在逻辑网络上的路由转发； 数据链路层，处理连接网络的硬件部分。 利用 TCP/IP 进行网络通信时，会通过分层顺序与对方进行通信；发送端从应用层往下走，接收端则从链路层往上走；发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息；反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\nIP、TCP 与 DNS IP 网际协议位于网络层，用于把各种数据包传送给对方；要保证数据传送到对方那里，需要满足两个重要的条件：IP 地址和 MAC 地址（Media Access Control Address 媒体访问控制地址）；互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），一切网络设备都由 MAC 地址唯一标识。\nIP 间的通信依赖 MAC 地址，通信双方通常是经过多台计算机和网络设备中转才能连接到对方；而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标；这时，会采用 ARP 协议（Address Resolution Protocol 地址解析协议是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议），根据通信方的 IP 地址就反查出对应的 MAC 地址。\nTCP 位于传输层，在发送数据前，通信双方必须在彼此间建立一条连接；为了方便传输，TCP 字节流服务会将大块数据分割成以报文段为单位的数据包进行管理；为了准确无误地将数据送达目标处，TCP 协议采用了三次握手四次挥手策略。\n客户端和服务端通信前要进行连接，“三次握手”的作用就是双方都能明确自己和对方的收发能力是正常的（握手的过程会确认协议类型、协议版本、编码方式、传输速率等）：\n第一次握手：客户端发送网络包，服务端收到了；这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的； 第二次握手：服务端发包，客户端收到了；这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的； 第三次握手：客户端发包，服务端收到了；这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 特别的，HTTPS 的连接建立需要七次握手，在 TCP 三次握手建立连接后，使用 TLS 握手建立安全连接（协商加密算法、加密密钥等）；HTTP/3 使用基于 UDP 的 QUIC 协议进行握手，将 TCP 和 TLS 握手过程结合起来，握手次数从七次减少到了三次。\nTCP 断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了 4 个动作；之所以中间的两个动作没有合并，是因为 TCP 存在「半关闭」状态，也就是单向关闭。\n上面有一个非常特殊的状态 time_wait，它是主动关闭的一方在回复完对方的挥手后进入的一个长期状态，这个状态标准的持续时间是 4 分钟，4 分钟后才会进入到 closed 状态，释放套接字资源。\nDNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议；它提供域名到 IP 地址之间的解析服务。\nURI 与 URL URI（统一资源标志符）就像是人的身份证号，可以把人独一无二地表示出来；URL（统一资源定位符）就像是人的居住地址，我们也可以通过住址找到这个人；不论是用定位的方式还是用编号的方式，我们都可以唯一确定一个人，都是 URI 的一种实现，而 URL 就是用定位的方式实现的 URI。\nHTTP 协议 HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信；请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。\nHTTP 是一种无状态协议，自身不对请求和响应之间的通信状态进行保存；也就是说 HTTP 对于发送过的请求或响应都不做持久化处理。cookie 技术通过在请求和响应报文中写入 cookie 信息来控制客户端的状态；cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 cookie；当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 cookie 值后发送出去；服务器端发现客户端发送过来的 cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。\nHTTP 报文 用于 HTTP 协议交互的信息被称为 HTTP 报文；请求端的 HTTP 报文叫做请求报文，响应端的叫做响应报文；HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本；HTTP 报文大致可分为报文首部和报文主体两块。\nHTTP 状态码 状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。\n200 表示从客户端发来的请求在服务器端被正常处理了； 201 表示资源已创建，服务器已确认； 204 代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分； 205 与 204 的区别是“要求请求方内容重置”； 206 表示客户端进行了范围请求，而服务器成功执行了这部分请求；响应报文中包含由 Content-Range 指定范围的实体内容； 301 永久性重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI； 302 临时性重定向，表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问； 303 表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源（与 302 的区别）； 304 表示服务器端资源未改变，可直接使用客户端未过期的缓存； 400 表示请求报文中存在语法错误； 401 表示发送的请求需要有通过 HTTP 认证信息； 403 表明对请求资源的访问被服务器拒绝了； 404 表明服务器上无法找到请求的资源； 429 表明在一定的时间内发送了太多的请求，超出了“频次限制”； 500 表明服务器端在执行请求时发生了错误； 502 表示服务器作为网关或代理，从上游服务器收到无效响应； 503 表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求； 504 表明网关超时。 HTTP 与服务器 HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。\n在互联网上，域名通过 DNS 服务映射到 IP 地址；当请求发送到服务器时，已经是以 IP 地址形式访问了；在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。\nHTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道\u0026hellip;\n代理：有转发功能的应用程序，位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端； 网关：转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理； 隧道：在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器；代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。\n在 HTTP 通信过程中，可级联多台代理服务器；请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加 Via 首部字段以标记出经过的主机信息。\n使用代理服务器的理由有：利用缓存技术减少网络带宽的流量（缓存代理）、组织内部针对特定网站的访问控制、获取访问日志、透明代理\u0026hellip;\n网关的工作机制和代理十分相似；而网关能使通信线路上的服务器提供非 HTTP 协议服务；利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。\n隧道可按要求建立起一条与其他服务器的通信线路，使用 SSL 等加密手段进行通信；隧道的目的是确保客户端能与服务器进行安全的通信；隧道本身不会去解析 HTTP 请求。隧道会在通信双方断开连接时结束。\nHTTP 首部 在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。\n在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。\n通用首部字段：\nCache-Control 用来操作缓存的工作机制； Connection 用来控制不再转发给代理的首部字段、管理持久连接；HTTP/1.x 默认使用持久连接； Date 表明创建 HTTP 报文的日期和时间； Pragma 历史遗留字段，仅为向后兼容而定义； Trailer 事先说明在报文主体后记录了哪些首部字段； Transfer-Encoding 规定了传输报文主体时采用的编码方式； Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议； Via 用于追踪客户端与服务器之间的请求和响应报文的传输路径； Warning 用于告知用户一些与缓存相关的问题的警告。 请求首部字段：\nAccept 可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级； Accept-Charset 用来通知服务器用户代理支持的字符集及字符集的相对优先顺序； Accept-Encoding 用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序； Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级； Authorization 用来告知服务器用户代理的认证信息（证书值）； Expect 用来告知服务器，期望出现的某种特定行为； From 用来告知服务器，使用用户代理的用户的电子邮件地址； Host 使用首部字段 Host 加以区分运行在同一个 IP 上的虚拟主机； If-Match 只有当字段值跟 ETag（实体标记）值匹配一致时，服务器才会接受请求； If-None-Match 只有当字段值与 ETag 值不一致时，服务器才会接受请求； If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求； If-Unmodified-Since 字段指定的日期时间后，资源未发生更新，服务器会接受请求； If-Range 若指定的字段值（ETag 或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理；反之，则返回全体资源； Max-Forwards 以十进制整数形式指定可经过的服务器最大数目，当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应； Proxy-Authorization 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息； Range 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围； Referer 用来告知服务器请求的原始资源的 URI； TE 用来告知服务器客户端能够处理响应的传输编码方式及相对优先级；它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码； User-Agent 将创建请求的浏览器和用户代理名称等信息传达给服务器。 响应首部字段：\nAccept-Ranges 用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源； Age 用来告知客户端，源服务器在多久前创建了响应；字段值的单位为秒； ETag 可将资源以字符串形式做唯一性标识的方式；服务器会为每份资源分配对应的 ETag 值；当资源更新时，ETag 值也需要更新；生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配； Location 将响应接收方引导至某个与请求 URI 位置不同的资源；该字段会配合 3xx 的响应，提供重定向的 URI； Proxy-Authenticate 由代理服务器所要求的认证信息发送给客户端； Retry-After 用来告知客户端应该在多久之后再次发送请求；主要配合状态码 503/3xx 响应一起使用； Server 用来告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息； Vary 对缓存进行控制；源服务器会向代理服务器传达关于本地缓存使用方法的命令； WWW-Authenticate 用于 HTTP 访问认证，会告知客户端适用于访问请求 URI 所指定资源的认证方案和带参数提示的质询。 实体首部字段：\nAllow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法； Content-Encoding 用于告知客户端，服务器对实体的主体部分选用的内容编码方式。 Content-Language 用于告知客户端，实体主体使用的自然语言（指中文或英文等语言）； Content-Length 表明了实体主体部分的大小； Content-Location 给出与报文主体部分相对应的 URI；和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI； Content-MD5 检查报文主体在传输过程中是否保持完整，以及确认传输到达； Content-Range 针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求； Content-Type 实体主体内对象的媒体类型，和首部字段 Accept 一样，字段值用 type/subtype 形式赋值； Expires 用于告知客户端资源失效的日期； Last-Modified 指明资源最终修改的时间。 Cookie 相关首部字段：\n其他首部字段：\nDNT（请求首部）意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法； P3P（响应首部）可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的； X-Frame-Options（响应首部）用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题，其主要目的是为了防止点击劫持攻击； X-XSS-Protection（响应首部）针对跨站脚本攻击的一种对策，用于控制浏览器 XSS 防护机制的开关。 HTTP 缓存策略 HTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存；主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，降低运营成本，缓解服务端的压力。\n强缓存不需要发送请求到服务端，客户端直接读取本地缓存；由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。\nExpires 用于告知客户端资源失效的日期； Cache-Control 用来操作缓存的工作机制； Pragma 历史遗留字段，值为‘no-cache’时禁用缓存（告知客户端不要对该资源进行缓存）； 当强缓存失效或者被禁用的时候，客户端会到服务端去协商；如果命中了协商缓存，服务器会返回 304，告诉客户端使用协商缓存。\nIf-Match 只有当字段值跟 ETag（实体标记）值匹配一致时，服务器才会接受请求； If-None-Match 只有当字段值与 ETag 值不一致时，服务器才会接受请求； If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求； If-Unmodified-Since 字段指定的日期时间后，资源未发生更新，服务器会接受请求； ETag 可将资源以字符串形式做唯一性标识的方式；服务器会为每份资源分配对应的 ETag 值；当资源更新时，ETag 值也需要更新； Last-Modified 指明资源最终修改的时间。 HTTPS HTTP 的缺点：\n通信使用明文（不加密），内容可能会被窃听； 不验证通信方的身份，因此有可能遭遇伪装； 无法证明报文的完整性，所以有可能已遭篡改。 即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的；只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。\n加密技术：通信加密、内容加密。\nHTTP 协议中的请求和响应不会对通信方进行确认，因此会存在以下各种隐患：\n无法确定请求发送至目标的服务器是否是按真实意图返回响应的那台服务器； 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端； 无法确定正在通信的对方是否具备访问权限； 无法判定请求是来自何方、出自谁手； 即使是无意义的请求也会照单全收，无法阻止海量请求下的 DoS 攻击（Denial Of Service 拒绝服务攻击）。 HTTP 协议无法证明通信的报文完整性；没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的；请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-In-The-Middle Attack）。\nHTTPS 并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL 和 TLS 协议代替；通常，HTTP 直接和 TCP 通信，当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了；不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。\n对称密钥加密：加密和解密同用一个密钥；非对称密钥加密：私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。\nHTTPS 采用“对称密钥加密”和“非对称密钥加密”两者并用的混合加密机制，“非对称密钥加密”用于交换“对称密钥加密”的密钥，“对称密钥加密”用于通信。\n如何证明公开密钥本身就是货真价实的公开密钥呢？可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。\n首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请；数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。\n服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信；公钥证书也可叫做数字证书或直接称为证书。\n接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构；二，服务器的公开密钥是值得信赖的。\n此处认证机关的公开密钥必须安全地转交给客户端；多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。\nHSTS HTTP Strict Transport Security 是一个安全功能，它告诉浏览器只能通过 HTTPS 访问当前资源。\n当请求由 HTTP 跳转到 HTTPS 时，HSTS 可以阻止用户被中间人攻击。\n1 2 3 Strict-Transport-Security: max-age=\u0026lt;expire-time\u0026gt; Strict-Transport-Security: max-age=\u0026lt;expire-time\u0026gt;; includeSubDomains Strict-Transport-Security: max-age=\u0026lt;expire-time\u0026gt;; preload max-age=\u0026lt;expire-time\u0026gt; 表示在浏览器收到这个请求后的 \u0026lt;expire-time\u0026gt; 秒的时间内，凡是访问这个域名下的资源都使用 HTTPS 请求。 includeSubDomains 表示此规则也适用于该网站的所有子域名。 preload 表示浏览器将会永不使用非安全的方式连接到你的域名。\nWeb 性能优化 减少 DNS 查询：每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求； 减少 HTTP 请求：任何请求都不如没有请求更快，因此要去掉页面上没有必要的资源； 使用 CDN：从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延迟，增加吞吐量； 添加 Expires 首部并配置 ETag 标签：相关资源应该缓存，以避免重复请求每个页面中相同的资源； 使用 Gzip 压缩：所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输； 避免 HTTP 重定向：HTTP 重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下，还会导致额外的 DNS 查询、TCP 连接延迟； 使用 HTTP 持久连接：避免第二次 TCP 连接时的三次握手、消除另一次 TCP 慢启动的往返，节约整整一次网络延迟。 CORS（跨域资源共享） CORS 请求的选择同意认证机制由底层处理，请求发出后，浏览器自动追加受保护的 Origin 首部，包含着发出请求的来源；相应地，远程服务器可以检查 Origin 首部，决定是否接受该请求，如果接受就返回 Access-Control-Allow-Origin 响应首部：\n1 2 3 4 5 6 7 8 GET /resource.js HTTP/1.1 Host: thirdparty.com Origin: http://example.com（Origin 首部由浏览器自动设置） ... HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com（选择同意首部由服务器设置） ... thirdparty.com 决定同意与 example.com 跨源共享资源，因此就在响应中返回了适当的访问控制首部；假如它选择不同意接受这个请求，那么只要不在响应中包含 Access-Control-Allow-Origin 首部即可；这样，客户端的浏览器就会自动将发出的请求作废；如果第三方服务器不支持 CORS，那么客户端请求同样会作废。\nCORS 还允许服务器返回一个通配值（Access-Control-Allow-Origin: *），表示它允许来自任何源的请求。\n对于 CORS，浏览器还会采取一系列安全措施：\nCORS 请求会省略 cookie 和 HTTP 认证等用户凭据； 客户端被限制只能发送“简单的跨源请求”，包括只能使用特定的方法（GET、POST 和 HEAD）。 要启用 cookie 和 HTTP 认证，客户端必须在发送请求时发送额外的属性（withCredentials），而服务器也必须以适当的首部（Access-Control-Allow-Credentials）响应，表示它允许应用发送用户的隐私数据；如果客户端需要写或者读自定义的 HTTP 首部，或者想要使用“不简单的方法”发送请求，那么它必须首先要获得第三方服务器的许可，即向第三方服务器发送一个预备（preflight）请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ➊ 预备请求 OPTIONS /resource.js HTTP/1.1 Host: thirdparty.com Origin: http://example.com Access-Control-Request-Method: POST Access-Control-Request-Headers: My-Custom-Header ... ➋ 预备响应 HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: My-Custom-Header ... ➌ 正式的 HTTP 请求 ... CSRF（跨站请求伪造） 原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载；用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。\n最简单的 CSRF 攻击：\n用户 Alice 登录和访问某银行网站 A，保留 cookie； Alice 被某些信息诱导访问危险网站 B； 危险网站 B 上有一个标签 \u0026lt;img src=\u0026ldquo; http://www.bank.com?name=Alice\u0026money=1000\u0026for=Badman\" /\u0026gt; 这个标签的 src 不指向一张图片，而是一个 HTTP 请求，由于 Alice 的浏览器上有银行网站的 cookie，这样浏览器发出的这个请求就能得到响应执行；这样 Alice 的钱就被偷了。 进阶 CSRF 攻击：\n危险网站可以伪造一个表单并隐藏，并在自己网站的 onload 事件中，触发这个表单的提交事件，就可以改 GET 攻击为 POST 攻击。\nCSRF 防范思路：\n仅仅靠发起 CSRF 攻击的话，黑客只能借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容；另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析； 我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护； 而保护的关键，是在请求中放入黑客所不能伪造的信息。 CSRF 防范手段：\n涉及敏感操作的请求改为 POST 请求； 用户操作限制，加入验证码机制； 验证 HTTP 头部 Origin/Referer 字段，它记录了请求的来源地址，服务器需要做的是验证这个来源地址是否合法，非法则拒绝响应； 添加隐藏字段，在请求时服务端对前端提交的隐藏字段进行验证。 XSS（跨站脚本攻击） 向页面里插入恶意 Script 代码（代码注入型攻击）；当用户浏览该页时，嵌入其中 Script 代码会被执行，从而达到恶意攻击用户的目的；归根结底，XSS 就是想办法让用户的浏览器去执行一些这个网页中原本不存在的前端代码。\nXSS 的危害：\n窃取网页浏览中的 cookie； 劫持流量实现恶意跳转。 如何利用 XSS：\n大小写绕过：因为网站仅仅只过滤了 \u0026lt;script/\u0026gt; 标签，而没有考虑标签中的大小写并不影响浏览器的解释； 不是只有 script 标签才可以插入代码：\u0026lt;img src=\u0026lsquo;w.123\u0026rsquo; onerror=\u0026lsquo;alert(\u0026ldquo;hey!\u0026rdquo;)\u0026rsquo; /\u0026gt;； 编码脚本代码绕过关键字过滤：eval(\\u0061\\u006c\\u0065\\u0072\\u0074(1))； 主动闭合标签实现注入代码：var a = \u0026ldquo;\u0026quot;;alert(1);\u0026rdquo;\u0026quot;;。 XSS 防范手段：\n对用户输入信息进行过滤，不允许用户插入 HTML 标签，对用户输入信息长度进行限制； 严格的 CSP（Content Security Policy）策略。 HTTP/2 HTTP/2 的出现，相比于 HTTP/1.x，大幅度的提升了性能；在与 HTTP/1.1 完全语义兼容的基础上，进一步减少了网络延迟。\n多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求 - 响应消息；众所周知，在 HTTP/1.1 协议中「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制；超过限制数目的请求会被阻塞」；这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。而 HTTP/2 的多路复用则允许同时通过单一的 HTTP/2 连接发起多重的请求 - 响应消息。\n因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息并行地在同一个 TCP 连接上双向交换消息。\n在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下，HTTP/2 是如何做到「突破 HTTP/1.x 的性能限制，改进传输性能，实现低延迟和高吞吐量」的？关键之一就是在应用层（HTTP）和传输层（TCP or UDP）之间增加一个二进制分帧层。\nHTTP/1.x 以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码。\n在二进制分帧层中，HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码，其中 HTTP/1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面；HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。\n在过去，HTTP 性能优化的关键并不在于高带宽，而是低延迟；TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度；这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。\nHTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升；单连接多资源的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大；由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少；使拥塞和丢包恢复速度更快。\nHTTP/1.x 并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生，SPDY 使用的是通用的 DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。\n服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应；Server Push 让 HTTP/1.x 时代使用内嵌资源的优化手段变得没有意义。\n如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、Logo 以及样式表，因为它知道客户端会用到这些东西；这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。\nHTTP/3 HTTP/3 相比于之前版本的一个重要区别：是它在一种新的传输协议 QUIC 上运行；QUIC 专为移动密集型互联网使用而设计。QUIC 的使用意味着 HTTP/3 依赖于用户数据报协议（UDP），而不是传输控制协议（TCP）；切换到 UDP 将使在线浏览时的连接速度和用户体验更快。\nQUIC 将帮助修复 HTTP/2 的一些重大缺点：\n解决当智能手机从 Wi-Fi 切换到蜂窝数据时性能缓慢的问题； 减少丢包的影响，当一个信息包没有到达目的地时，它不会再阻塞所有的信息流（称为“队头阻塞”的问题）； 更快的连接建立：QUIC 允许 TLS 版本协商与加密和传输握手同时发生； 零往返时间（0-RTT）：对于它们已经连接的服务器，客户端可以跳过握手要求； 更全面的加密：QUIC 的新握手方式将默认提供加密，有助于减轻攻击的风险。 默认加密 在传输层而不是在应用程序层进行加密，意味着连接将始终被加密。以前，在 HTTPS 中，加密和传输层连接是分开发生的。TCP 连接可以携带加密或未加密的数据，TCP 握手和 TLS 握手是不同的事件。但是，QUIC 默认在传输层设置加密连接——应用程序层数据将始终被加密。\nQUIC 通过将两次握手合并为一个动作来实现这一点，从而减少延迟，因为应用程序在发送数据之前只需等待一次握手完成。它还加密有关每个连接的元数据，包括数据包编号和标头的其他一些部分，以帮助防止攻击者掌握有关用户行为的信息。HTTP/2 中不包含此功能。加密这些数据有助于防止攻击者掌握有关用户行为的可操作信息。\n浏览器缓存 缓存位置：\nService Worker：传输协议必须为 HTTPS，开发者控制缓存哪些文件、如何匹配缓存、如何读取缓存； Memory Cache：读取高效，缓存时间短；不受 Cache-Control 限制；Tab 关闭，缓存失效；prefetch 缓存存在于此； Disk Cache：读取稍慢，缓存时间长；受到 HTTP 请求/响应头缓存字段的控制；一般存放使用频率不那么高、体积较大的文件； Push Cache：只在会话（Session）中存在；并且仅适用于 HTTP/2 的连接。 用户行为：\n地址栏输入：查找 Disk Cache 中是否有匹配；如有则使用，如没有则发送网络请求； 普通刷新：因为 Tab 并没有关闭，因此优先使用 Memory Cache，其次才是 Disk Cache； 强制刷新：不使用缓存，因此发送的请求头部均带有 cache-control: no-cache，服务器直接返回 200 和最新内容。 Cookie、Session 和 Token HTTP 是一种无状态协议，每个请求都是独立存在的，服务端无法区分当前在给谁提供服务，所以才有了 cookie、session 和 token；它们是一种客户端身份凭证，用来告诉服务端‘我’是谁。\ncookie：服务端保存在客户端的数据，每次请求会自动发送给服务端；不能跨域，仅在相同域名下共享；仅能保存有限数据； session：服务端保存 session、客户端保存 sessionId（服务器提供并保存），重要信息保存在服务端；可以存无限多的数据； token：服务端提供 token，客户端保存并在每次请求时放入请求头，服务端解析 token 验证客户端。 参考 前端安全系列之二：如何防止 CSRF 攻击？ HTTP 2.0 相比 1.x 有哪些重大改进？ 对于跨站伪造请求的理解和总结 三次握手、七次握手、四次挥手 HTTP Strict Transport Security 深入理解浏览器的缓存机制 浅谈 XSS 攻击的那些事 什么是 HTTP/3？ CSRF 是什么？ ","date":"2020-04-15T00:00:00Z","image":"https://vikingama.github.io/img/cover/http.png","permalink":"https://vikingama.github.io/p/%E5%9B%BE%E8%A7%A3-http%E7%AC%94%E8%AE%B0/","title":"《图解 HTTP》笔记"},{"content":"生命周期 异步组件 Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义；只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。\n1 2 3 4 5 6 7 8 9 10 11 12 const AsyncComponent = () =\u0026gt; ({ // 需要加载的组件 (应该是一个 Promise 对象) component: import(\u0026#39;./MyComponent.vue\u0026#39;), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了，则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000 }); 插件系统 插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制：\n添加全局方法或者属性； 添加全局资源：指令/过滤器/过渡等； 通过全局混入来添加一些组件选项； 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现； 提供自己的 API，同时提供上面提到的一个或多个功能。 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Example.install = (Vue, options) =\u0026gt; { Vue.$shareConfig = configObj =\u0026gt; { const { sharetitle, sharedesc, shareimg, shareurl } = configObj; const shareObj = { title: sharetitle, desc: sharedesc, link: shareurl, imgUrl: shareimg, success: function () {}, cancel: function () {} }; wx.config({ appId: this.$store.state.appId, debug: false, jsApiList: [ \u0026#39;onMenuShareTimeline\u0026#39;, \u0026#39;onMenuShareAppMessage\u0026#39;, \u0026#39;onMenuShareQQ\u0026#39;, \u0026#39;onMenuShareWeibo\u0026#39; ], nonceStr: this.$store.state.nonceStr, signature: this.$store.state.signature, timestamp: this.$store.state.timestamp }); wx.ready(function () { wx.onMenuShareTimeline(shareObj); wx.onMenuShareQQ(shareObj); wx.onMenuShareAppMessage(shareObj); wx.onMenuShareWeibo(shareObj); }); }; }; // 使用插件并向插件传入可选选项 Vue.use(Example, {}); 自定义指令 自定义指令适用于需要对普通 DOM 元素进行底层操作的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 全局注册 Vue.directive(\u0026#39;focus\u0026#39;, { // 当被绑定的元素插入到 DOM 中时 inserted: function (el) { el.focus(); // 聚焦元素 } }); // 局部注册 new Vue({ directives: { focus: { inserted(el) { el.focus(); } } } }); 指令定义对象可以提供如下几个钩子函数：\nbind：只调用一次，指令第一次绑定到元素时调用；在这里可以进行一次性的初始化设置； inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）； update：所在组件的 VNode 更新时调用，可以通过比较更新前后的值来忽略不必要的模板更新； componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用； unbind：只调用一次，指令与元素解绑时调用。 钩子函数参数：\nel：指令所绑定的元素，可以用来直接操作 DOM； binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀； value：指令的绑定值，例如：v-my=\u0026ldquo;1 + 1\u0026quot;中，绑定值为 2； oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用； expression：字符串形式的指令表达式，例如 v-my=\u0026ldquo;1 + 1\u0026quot;中，表达式为 \u0026ldquo;1 + 1\u0026rdquo;； arg：传给指令的参数，可选；例如 v-my:foo 中，参数为 \u0026ldquo;foo\u0026rdquo;； modifiers：一个包含修饰符的对象；例如：v-my.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：编译生成的虚拟节点； oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;div id=\u0026#34;hook-arguments\u0026#34; v-demo:foo.a.b=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; Vue.directive(\u0026#39;demo\u0026#39;, { bind(el, binding, vnode) { var s = JSON.stringify; el.innerHTML = ` name: ${s(binding.name)}, value: ${s(binding.value)}, expression: ${s(binding.expression)}, argument: ${s(binding.arg)}, modifiers: ${s(binding.modifiers)}, vnode keys: ${Object.keys(vnode).join(\u0026#39;, \u0026#39;)} `; } }); new Vue({ el: \u0026#39;#hook-arguments\u0026#39;, data: { message: \u0026#39;hello\u0026#39; } }); /** * name: \u0026#34;demo\u0026#34; * value: \u0026#34;hello\u0026#34; * expression: \u0026#34;message\u0026#34; * argument: \u0026#34;foo\u0026#34; * modifiers: {\u0026#34;a\u0026#34;:true,\u0026#34;b\u0026#34;:true} * vnode keys: tag, data, children, text... */ \u0026lt;/script\u0026gt; 动态指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;div id=\u0026#34;dynamic\u0026#34;\u0026gt; \u0026lt;h3\u0026gt;Scroll down inside this section...\u0026lt;/h3\u0026gt; \u0026lt;p v-pin:[direction]=\u0026#34;200\u0026#34;\u0026gt; I am pinned onto the page at 200px to the left... \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#dynamic\u0026#39;, data() { return { direction: \u0026#39;left\u0026#39; }; }, directives: { pin: { bind(el, binding, vnode) { el.style.position = \u0026#39;fixed\u0026#39;; el.style[binding.arg] = `${binding.value}px`; } } } }); \u0026lt;/script\u0026gt; 响应式原理 当把一个普通的 JS 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter；在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更；每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖；之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\nObject.freeze 会阻止修改现有的属性，也意味着响应系统无法再追踪变化。\nVue 不能检测以下数组的变动（因为性能问题）：\n利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue； 修改数组的长度时，例如：vm.items.length = newLength。 举个例子：\n1 2 3 4 5 6 7 8 9 10 var vm = new Vue({ data: { items: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] } }); vm.items[1] = \u0026#39;x\u0026#39;; // 不是响应性的 vm.$set(vm.items, indexOfItem, newValue); // 解决问题 vm.items.splice(indexOfItem, 1, newValue); // 解决问题 vm.items.length = 2; // 不是响应性的 vm.items.splice(newLength); // 解决问题 Vue 不能检测对象属性的添加或删除：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var vm = new Vue({ data: { a: 1, userProfile: { name: \u0026#39;Anika\u0026#39; } } }); // 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性 vm.b = 2; // vm.b 不是响应式的 // 可以向嵌套对象添加响应式属性 vm.$set(vm.userProfile, \u0026#39;age\u0026#39;, 27); vm.userProfile = Object.assign({}, vm.userProfile, { favoriteColor: \u0026#39;Green\u0026#39; }); Vue 在更新 DOM 时是异步执行的；只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更；如果同一个 watcher 被多次触发，只会被推入到队列中一次；然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。\n在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n可以在数据变化之后立即使用 Vue.nextTick(callback)；回调函数将在 DOM 更新完成后被调用；例如：\n1 2 3 4 5 6 7 8 9 10 11 var vm = new Vue({ el: \u0026#39;#example\u0026#39;, data: { message: \u0026#39;123\u0026#39; } }); vm.message = \u0026#39;new message\u0026#39;; // 更改数据 vm.$el.textContent === \u0026#39;new message\u0026#39;; // false vw.$nextTick(function () { vm.$el.textContent === \u0026#39;new message\u0026#39;; // true }); 依赖注入 Vue 中也有 context 机制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 \u0026lt;google-map\u0026gt; \u0026lt;google-map-region v-bind:shape=\u0026#34;cityBoundaries\u0026#34;\u0026gt; \u0026lt;google-map-markers v-bind:places=\u0026#34;iceCreamShops\u0026#34;\u0026gt;\u0026lt;/google-map-markers\u0026gt; \u0026lt;/google-map-region\u0026gt; \u0026lt;/google-map\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;google-map\u0026#39;, { data() { return { sigma: 123 }; }, provide() { return { sigma: this.sigma, getMap: this.getMap }; }, methods: { getMap() { // ... } } }); Vue.component(\u0026#39;google-map-markers\u0026#39;, { // 可以跨越多个层级拿到值 inject: [\u0026#39;sigma\u0026#39;, \u0026#39;getMap\u0026#39;] }); \u0026lt;/script\u0026gt; 事件监听器 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 new Vue({ mounted() { this.picker = new Pikaday({ field: this.$refs.input, format: \u0026#39;YYYY-MM-DD\u0026#39; }); }, beforeDestroy() { this.picker.destroy(); } }); // 可以修改为 new Vue({ mounted() { var picker = new Pikaday({ field: this.$refs.input, format: \u0026#39;YYYY-MM-DD\u0026#39; }); this.$once(\u0026#39;hook:beforeDestroy\u0026#39;, function () { picker.destroy(); }); } }); 混入 混入提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能；一个混入对象可以包含任意组件选项；当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。\n混入原则：\n数据对象在内部会进行递归合并，并在发生冲突时以『组件数据优先』； 同名钩子函数将合并为一个数组，因此都将被调用；『混入对象』的钩子将在『组件自身』钩子『之前』调用； 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象；『组件对象』优先级较高。 Vue.extend 也使用同样的合并策略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 var myMixin = { data() { return { message: \u0026#39;hello\u0026#39;, foo: \u0026#39;abc\u0026#39; }; }, methods: { hi() { console.log(\u0026#39;hi\u0026#39;); }, bye() { console.log(\u0026#39;bye\u0026#39;); } }, mounted() { console.log(\u0026#39;mixin mounted\u0026#39;); } }; var vm = new Vue({ mixins: [myMixin], data() { return { message: \u0026#34;it\u0026#39;s me\u0026#34;, bar: \u0026#39;def\u0026#39; }; }, methods: { hi() { console.log(\u0026#39;hihihi\u0026#39;); }, do() { console.log(\u0026#39;dododo\u0026#39;); } }, created() { console.log(this.$data); // { message: \u0026#34;it\u0026#39;s me\u0026#34;, foo: \u0026#34;abc\u0026#34;, bar: \u0026#34;def\u0026#34; } }, mounted() { console.log(\u0026#39;component mounted\u0026#39;); // mixin mounted, component mounted } }); vm.hi(); // hihihi vm.bye(); // bye vm.do(); // dododo // 全局混入，将影响每一个之后创建的 Vue 实例 Vue.mixin(myMixin); computed vs watch vs methods 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div\u0026gt;{v1()}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{v2}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{v3}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; new Vue({ data() { // data 选项必须是一个函数，每个实例可以维护一份被返回对象的独立的拷贝 return { value: 123, v3: 0 }; }, methods: { // 每当触发重新渲染时，方法将总会再次执行；无论 vm.value 是否变化 v1() { return `v1: ${this.value}`; } }, computed: { // 计算属性是基于响应式依赖进行缓存的，只在相关响应式依赖发生改变时它们才会重新求值 v2() { return `v2: ${this.value}`; } }, watch: { // 在相关数据变化时，执行异步或开销较大的副作用有点像 React.useEffect v3() { this.v3 = `v3: ${this.value}`; } } }); \u0026lt;/script\u0026gt; v-model v-model 本质上是语法糖；它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理；在内部为不同的输入元素使用不同的属性并抛出不同的事件：\n1 2 3 4 5 6 \u0026lt;input v-model=\u0026#34;searchText\u0026#34; /\u0026gt; 等价于 \u0026lt;input v-bind:value=\u0026#34;searchText\u0026#34; v-on:input=\u0026#34;searchText = $event.target.value\u0026#34; /\u0026gt; text 和 textarea 使用 value 属性和 input 事件； checkbox 和 radio 使用 checked 属性和 change 事件； select 字段将 value 作为 prop 并将 change 作为事件。 v-model 有配套的修饰符：\n1 2 3 4 5 6 \u0026lt;!-- 使用 change 事件替换 input 事件将输入框的值与数据进行同步 --\u0026gt; \u0026lt;input v-model.lazy=\u0026#34;msg\u0026#34; /\u0026gt; \u0026lt;!-- 将用户的输入值转为数值类型 --\u0026gt; \u0026lt;input v-model.number=\u0026#34;age\u0026#34; type=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;!-- 过滤用户输入的首尾空白字符 --\u0026gt; \u0026lt;input v-model.trim=\u0026#34;msg\u0026#34; /\u0026gt; 一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件；但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Vue.component(\u0026#39;base-checkbox\u0026#39;, { model: { prop: \u0026#39;checked\u0026#39;, event: \u0026#39;change\u0026#39; }, props: { checked: Boolean }, template: ` \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-bind:checked=\u0026#34;checked\u0026#34; v-on:change=\u0026#34;$emit(\u0026#39;change\u0026#39;, $event.target.checked)\u0026#34; \u0026gt;` }); // 这样使用 \u0026lt;base-checkbox v-model=\u0026#34;lovingVue\u0026#34;\u0026gt;\u0026lt;/base-checkbox\u0026gt;; props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 new Vue({ props: [\u0026#39;title\u0026#39;, \u0026#39;likes\u0026#39;, \u0026#39;isPublished\u0026#39;, \u0026#39;commentIds\u0026#39;, \u0026#39;author\u0026#39;] }); new Vue({ // 类型可以是：String、Number、Boolean、Array、Object、Date、Function、Symbol props: { title: String, likes: Number, isPublished: Boolean, commentIds: Array, author: Object, callback: Function, contactsPromise: Promise } }); new Vue({ props: { // 基础的类型检查（null 和 undefined 会通过任何类型验证） propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default() { return { message: \u0026#39;hello\u0026#39; }; } }, // 自定义验证函数 propF: { validator(value) { // 这个值必须匹配下列字符串中的一个 return [\u0026#39;success\u0026#39;, \u0026#39;warning\u0026#39;, \u0026#39;danger\u0026#39;].indexOf(value) !== -1; } } } }); key 管理可复用元素； 表示元素是独立的，不要复用。 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 如果不设置独立的 key 属性，在切换 loginType 时，input 将被复用 用户已经输入的内容将不会被清除，很明显是不合理的 --\u0026gt; \u0026lt;template v-if=\u0026#34;loginType === \u0026#39;username\u0026#39;\u0026#34;\u0026gt; \u0026lt;label\u0026gt;UserName\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your username\u0026#34; key=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-else\u0026gt; \u0026lt;label\u0026gt;Email\u0026lt;/label\u0026gt; \u0026lt;input placeholder=\u0026#34;Enter your email\u0026#34; key=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; is is 用来将普通元素或组件指定渲染为指定的组件。\n有些 HTML 元素，诸如 \u0026lt;ul\u0026gt;、\u0026lt;ol\u0026gt;、\u0026lt;table\u0026gt; 和 \u0026lt;select\u0026gt;，对于哪些元素可以出现在其内部是有严格限制的；而有些元素，诸如 \u0026lt;li\u0026gt;、\u0026lt;tr\u0026gt; 和 \u0026lt;option\u0026gt;，只能出现在其它某些特定的元素内部。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 这个自定义组件 \u0026lt;blog-post-row\u0026gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错 --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;blog-post-row\u0026gt;\u0026lt;/blog-post-row\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- 可以这样解决 --\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr is=\u0026#34;blog-post-row\u0026#34;\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;!-- 通过将 currentTabComponent 设定为不同的组件来切换渲染结果--\u0026gt; \u0026lt;component v-bind:is=\u0026#34;currentTabComponent\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; slot 具名插槽：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!-- \u0026lt;base-layout\u0026gt; 组件 --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;slot name=\u0026#34;header\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;main\u0026gt; \u0026lt;slot\u0026gt;后备用内容，name=\u0026#34;default\u0026#34;\u0026lt;/slot\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;slot name=\u0026#34;footer\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- 这样使用 --\u0026gt; \u0026lt;base-layout\u0026gt; \u0026lt;template v-slot:header\u0026gt; \u0026lt;h1\u0026gt;header 内容\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;这两行会被插入到 main 标签\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;这两行会被插入到 main 标签\u0026lt;/p\u0026gt; \u0026lt;template v-slot:footer\u0026gt; \u0026lt;p\u0026gt;footer 内容\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/base-layout\u0026gt; \u0026lt;!-- 缩写 --\u0026gt; \u0026lt;base-layout\u0026gt; \u0026lt;template #header\u0026gt; \u0026lt;h1\u0026gt;header 内容\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;p\u0026gt;这两行会被插入到 main 标签\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;这两行会被插入到 main 标签\u0026lt;/p\u0026gt; \u0026lt;template #footer\u0026gt; \u0026lt;p\u0026gt;footer 内容\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/base-layout\u0026gt; 作用域插槽（让插槽内容能够访问子组件中才有的数据）：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- \u0026lt;current-user\u0026gt; 组件 --\u0026gt; \u0026lt;span\u0026gt; \u0026lt;!-- user 存在于 current-user 组件内作用域中--\u0026gt; \u0026lt;slot\u0026gt;{{ user.lastName }}\u0026lt;/slot\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!-- 在父组件中 --\u0026gt; \u0026lt;current-user\u0026gt; \u0026lt;!-- 取不到 current-user 组件内作用域中的 user--\u0026gt; {{ user.firstName }} \u0026lt;/current-user\u0026gt; 为了让 user 在父级的插槽内容中可用，可以将 user 作为 \u0026lt;slot\u0026gt; 元素的一个属性绑定上去：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!-- \u0026lt;current-user\u0026gt; 组件 --\u0026gt; \u0026lt;span\u0026gt; \u0026lt;slot v-bind:user=\u0026#34;user\u0026#34;\u0026gt;{{ user.lastName }}\u0026lt;/slot\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;!-- 在父组件中 --\u0026gt; \u0026lt;current-user\u0026gt; \u0026lt;template v-slot:default=\u0026#34;slotProps\u0026#34;\u0026gt; {{ slotProps.user.firstName }} \u0026lt;template v-slot:one=\u0026#34;oneSlotProps\u0026#34;\u0026gt; slotProps is NOT available here \u0026lt;/template\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:two=\u0026#34;twoSlotProps\u0026#34;\u0026gt;slotProps is NOT available here\u0026lt;/template\u0026gt; \u0026lt;/current-user\u0026gt; \u0026lt;!-- 也可以酱 --\u0026gt; \u0026lt;current-user v-slot=\u0026#34;{ user }\u0026#34;\u0026gt;{{ user.firstName }}\u0026lt;/current-user\u0026gt; \u0026lt;!-- 也可以酱 --\u0026gt; \u0026lt;current-user v-slot=\u0026#34;{ user: person }\u0026#34;\u0026gt;{{ person.firstName }}\u0026lt;/current-user\u0026gt; \u0026lt;!-- 还可以定义后备内容 --\u0026gt; \u0026lt;current-user v-slot=\u0026#34;{ user = { firstName: \u0026#39;Guest\u0026#39; } }\u0026#34;\u0026gt; {{ user.firstName }} \u0026lt;/current-user\u0026gt; 命名视图 \u0026amp; 滚动行为 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;router-view class=\u0026#34;view one\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view class=\u0026#34;view two\u0026#34; name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;router-view class=\u0026#34;view three\u0026#34; name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; \u0026lt;script\u0026gt; new VueRouter({ routes: [ { path: \u0026#39;/\u0026#39;, components: { default: Foo, a: Bar, b: Baz } } ], scrollBehavior(to, from, savedPosition) { // return 期望滚动到哪个的位置 if (savedPosition) { return savedPosition; } else { return { x: 0, y: 0 }; } } }); \u0026lt;/script\u0026gt; 路由组件传参 有一个 User 组件，对于所有 ID 不同的用户，都要使用这个组件来渲染；通常的做法是“动态路由匹配”或者“Query 参数”，在组件中使用 vm.$route 来获取参数；在组件中使用 $route 会使之与其对应路由形成高度耦合，从而使组件只能在某些特定的 URL 上使用，限制了其灵活性。\n组件与 $route 的耦合：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; new Router({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, name: \u0026#39;User\u0026#39;, component: User } ] }); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;div\u0026gt;userId：{{$route.params.id}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 通过 props 与组件解耦：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;script\u0026gt; // 布尔模式 new Router({ routes: [ { path: \u0026#39;/user/:id\u0026#39;, name: \u0026#39;User\u0026#39;, component: User, props: true } ] }); // 对象模式 new Router({ routes: [ { path: \u0026#39;/user\u0026#39;, name: \u0026#39;User\u0026#39;, component: User, props: { id: 1 } } ] }); // 函数模式 new Router({ routes: [ { path: \u0026#39;/user\u0026#39;, name: \u0026#39;User\u0026#39;, component: User, // /user?id=123 会将 {query: \u0026#39;123\u0026#39;} 作为属性传递给 user 组件 props: route =\u0026gt; ({ query: route.query.id }) } ] }); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div class=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;div\u0026gt;userId：{{id}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { props: [\u0026#39;id\u0026#39;] }; \u0026lt;/script\u0026gt; 路由钩子 参数或查询的改变并不会触发进入/离开的导航守卫；可以通过观察 $route 对象来应对这些变化，或使用 beforeRouteUpdate 的组件内守卫。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, // 路由独享守卫 beforeEnter: (to, from, next) =\u0026gt; { /** * to:Route 即将要进入的目标路由 * from:Route 当前导航正要离开的路由 * next:Function 调用该方法来 resolve 这个钩子 * next() * 进行管道中的下一个钩子 * next(false) * 中断当前的导航 * next(\u0026#39;/\u0026#39;) 或者 next({ path: \u0026#39;/\u0026#39; }) * 当前的导航被中断，然后进行一个新的导航；可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: \u0026#39;home\u0026#39; 之类的选项 * next(error) * 传入 Error 实例，导航会被终止且该错误会被传递给 router.onError */ } } ] }); // 全局前置守卫 router.beforeEach((to, from, next) =\u0026gt; { // 参数含义同上 }); // 全局解析守卫 router.beforeResolve((to, from, next) =\u0026gt; { // 参数含义同上，所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用 }); // 全局后置钩子 router.afterEach((to, from) =\u0026gt; { // 参数含义同上 }); new Vue({ // 用来在导航完成前获取数据 beforeRouteEnter(to, from, next) { // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 this // 守卫执行前，组件实例还没被创建 next(vm =\u0026gt; { // 通过 vm 访问实例 }); }, beforeRouteUpdate(to, from, next) { // 在当前路由改变，但是该组件被复用时调用 // 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 组件实例会被复用；而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 this }, beforeRouteLeave(to, from, next) { // 导航离开该组件的对应路由时调用 // 可以访问组件实例 this let isBye = window.confirm(); if (isBye) { next(); } else { next(false); } } }); 完整的导航解析流程：\n导航被触发； 在失活的组件里调用 beforeRouteLeave； 调用全局的 beforeEach； 在重用的组件里调用 beforeRouteUpdate； 在路由配置里调用 beforeEnter； 解析异步路由组件； 在被激活的组件里调用 beforeRouteEnter； 调用全局的 beforeResolve； 导航被确认； 调用全局的 afterEach； 触发 DOM 更新； 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 路由元信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const router = new VueRouter({ routes: [ { path: \u0026#39;/foo\u0026#39;, component: Foo, children: [ { path: \u0026#39;bar\u0026#39;, component: Bar, meta: { requiresAuth: true } } ] } ] }); router.beforeEach((to, from, next) =\u0026gt; { if (to.matched.some(v =\u0026gt; v.meta.requiresAuth)) { if (!auth.loggedIn()) { next({ path: \u0026#39;/login\u0026#39;, query: { redirect: to.fullPath } }); } else { next(); } } else { next(); } }); ","date":"2020-03-04T00:00:00Z","image":"https://vikingama.github.io/img/cover/vue.png","permalink":"https://vikingama.github.io/p/vue-2.x-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"Vue 2.x 复习总结"},{"content":"Hook 产生的动机 代码层次更清晰；在类组件中，共属于一个功能的代码分散在各个钩子函数中； 更好的状态逻辑复用，renderProps 和高阶组件不是那么好用； 干掉 this。 Hook 使用规则 只能在最外层调用 Hook；不要在循环、条件判断或者子函数中调用（Hook 靠的是调用顺序来确定哪个 state 对应哪个 useState）； 只在函数组件中调用 Hook。 useState state 只在组件首次渲染的时候被创建；在下一次重新渲染时，useState 返回给我们当前的 state。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state。\n1 const [state, setState] = useState(() =\u0026gt; someExpensiveComputation(props)); 在初始渲染期间，state 与传入的 initialState 值相同；setState 函数用于更新 state，它接收一个新的 state 值并将组件的一次重新渲染加入队列。\n1 2 3 4 5 6 7 8 9 10 11 12 function Counter({ initialCount }) { // initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略 const [count, setCount] = useState(initialCount); return ( \u0026lt;\u0026gt; \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(initialCount)}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount - 1)}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; setCount(prevCount =\u0026gt; prevCount + 1)}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); } 与 class 组件中的 setState 方法不同，useState 不会自动合并更新对象。\n1 2 3 setState(prevState =\u0026gt; { return { ...prevState, ...updatedState }; }); 注意：在组件重新渲染时，state 和 setState 不会重新初始化（渲染前后都是同一个引用），state 像保存在 ref 中的变量一样。\nuseEffect useEffect 会在浏览器完成本次渲染之后进行下次渲染之前调用，不会阻塞浏览器更新屏幕；每次运行 effect 的时候，DOM 都已经更新完毕。某种意义上讲，effect 更像是渲染结果的一部分，每个 effect“属于”某一次特定的渲染。\n1 2 3 4 5 6 function Example() { const [count, setCount] = useState(0); useEffect(() =\u0026gt; { document.title = `u clicked ${count} times`; }); } 默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它在只有**某些值（能够触发组件重新渲染的值）**改变的时候才执行；如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组 [] 作为第二个参数，effect 内部的 props 和 state 就会一直持有其初始值。\n副作用函数还可以通过返回一个函数来指定如何“清除”副作用；通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器等资源；要实现这一点，useEffect 函数需返回一个清除函数；如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。\n1 2 3 4 5 6 7 8 9 10 11 12 useEffect( () =\u0026gt; { // 添加订阅 const subscription = props.source.subscribe(); return () =\u0026gt; { // 清除订阅 subscription.unsubscribe(); }; }, // 只有当 props.source 改变后才会重新创建订阅 [props.source] ); useContext 接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值；当前的 context 值由上层组件中距离当前组件最近的 \u0026lt;MyContext.Provider/\u0026gt; 的 value 决定。当组件上层最近的 \u0026lt;MyContext.Provider/\u0026gt; 更新时，该 Hook 会触发重渲染，并使用最新传递的 value 值。即使祖先使用 React.memo、React.PureComponent 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 const themes = { light: { foreground: \u0026#39;#000\u0026#39;, background: \u0026#39;#eee\u0026#39; }, dark: { foreground: \u0026#39;#fff\u0026#39;, background: \u0026#39;#222\u0026#39; } }; // 默认值为 themes.light const ThemeContext = createContext(themes.light); const App = () =\u0026gt; ( // 传递值为 themes.dark \u0026lt;ThemeContext.Provider value={themes.dark}\u0026gt; \u0026lt;Toolbar /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); const Toolbar = props =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/div\u0026gt; ); const ThemedButton = () =\u0026gt; { // 传递 createContext 的返回值 const theme = useContext(ThemeContext); return ( // 当 theme 改变时，触发重新渲染 \u0026lt;button style={{ background: theme.background, color: theme.foreground }} \u0026gt; 噼里啪啦 \u0026lt;/button\u0026gt; ); }; useReducer useState 的替代方案（useState 就是使用 useReducer 实现的）；接收一个 reducer，并返回当前的 state 以及与其配套的 dispatch 方法；dispatch 不会在组件重新渲染的时候重新初始化，渲染前后的 dispatch 是同一个方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 const formInit = { username: \u0026#39;\u0026#39;, useremail: \u0026#39;\u0026#39; }; const formReducer = (state, action) =\u0026gt; { switch (action.type) { case \u0026#39;CHANGE\u0026#39;: const { name, value } = action.payload; return { ...state, [name]: value }; case \u0026#39;RESET\u0026#39;: return { ...formInit }; default: return state; } }; const Form = () =\u0026gt; { const [formValues, dispatch] = useReducer(formReducer, formInit); const handleChange = e =\u0026gt; { dispatch({ type: \u0026#39;CHANGE\u0026#39;, payload: e.target }); }; return ( \u0026lt;form\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;username\u0026#34;\u0026gt;UserName\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; value={formValues.username} onChange={handleChange} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;label htmlFor=\u0026#34;useremail\u0026#34;\u0026gt;UserEmail\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;email\u0026#34; name=\u0026#34;useremail\u0026#34; value={formValues.useremail} onChange={handleChange} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button\u0026gt;Submit\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(\u0026#39;RESET\u0026#39;)}\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; ); }; 注意：如果通过 createContext 将 useReducer 的 state 和 dispatch 当作 value 传递下去；你甚至可以得到一个简单的 redux。\nuseCallback \u0026amp; useMemo Memo 是一种优化技术，大体上就是缓存昂贵计算的值并在相同输入的情况下直接返回缓存值（某种程度上的 Vue.computed）；useCallback 用来缓存函数的引用，useMemo 用来缓存计算数据的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 在 a 和 b 的变量值不变的情况下，即使组件重新渲染，memoCallback 的引用不变 * useCallback 的第一个入参函数会被缓存，从而达到渲染性能优化的目的 */ const memoCallback = useCallback(() =\u0026gt; { // ... doSomething(a, b); // ... }, [a, b]); /** * 在 a 和 b 的变量值不变的情况下，memoValue 的值/引用不变 * useMemo 函数的第一个入参函数不会被执行，从而达到节省计算量的目的 */ const memoValue = useMemo(() =\u0026gt; computeExpensiveValue(a, b), [a, b]); 具体使用场景：\n当复合数据（函数也是一种）存在于 useEffect 的依赖数组中，同时当前 useEffect 中有触发组件重新渲染的逻辑；则需要将数据用 useMemo | useCallback 包裹，否则会导致组件无限循环渲染。(1 === 1，{} !=== {}) ； 父组件重新渲染会导致子组件重新渲染，当子组件使用 React.memo 包裹时（仅当 props 改变才会出触发重新渲染），如果复合数据不使用 useMemo | useCallback 包裹，会导致 React.memo 失效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 获取上一次指定的值 const usePrevValue = value =\u0026gt; { const ref = useRef(); useEffect(() =\u0026gt; { ref.current = value; }); return ref.current; }; const App = ({ name }) =\u0026gt; { const [count, setCount] = useState(0); /** * 每次组件重新渲染，handleCount 都是重新创建的新函数； * 将 handleCount 作为 props 传递给其他组件时， * 会导致 PureComponent、React.memo 等相关优化失效 */ const handleCount = () =\u0026gt; { setCount(count =\u0026gt; count + 1); }; // useCallback 将传入的函数永久缓存了起来 const memoHandleCount = useCallback(() =\u0026gt; { setCount(count =\u0026gt; count + 1); }, []); const prevHandleCount = usePrevValue(handleCount); const memoPrevHandleCount = usePrevValue(memoHandleCount); console.log(prevHandleCount === handleCount); // false console.log(memoPrevHandleCount === memoHandleCount); // true // 将性能消耗比较大的计算缓存起来，只有 name 改变时会重新计算，count 改变不会进行重新计算 const memoArray = useMomo(() =\u0026gt; { return Array(999) .fill(name) .map(v =\u0026gt; v.toUpperCase()); }, [name]); return ( \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;{name}\u0026lt;/span\u0026gt; \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={handleCount}\u0026gt;AddOne\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 注意：如果 useCallback/useMemo 缓存的函数/值不依赖组件内部的变量，可以将函数/值提到组件外部；酱紫，不使用 useCallback/useMemo 可以达到相同的效果。\nuseRef useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数 initialValue；返回的 ref 对象在组件的整个生命周期内保持不变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 const TextInputWithFocusButton = () =\u0026gt; { const inputEl = useRef(null); const onButtonClick = () =\u0026gt; { // `current` 指向已挂载到 DOM 上的文本输入元素 inputEl.current.focus(); }; return ( \u0026lt;\u0026gt; \u0026lt;input ref={inputEl} type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;button onClick={onButtonClick}\u0026gt;Focus\u0026lt;/button\u0026gt; \u0026lt;/\u0026gt; ); }; useRef 不仅用于 DOM refs，ref.current 是一个可以容纳任何值的通用容器，类似于 class 的实例属性；useRef 和自建一个 {current: \u0026hellip;} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象（当然你可以在组件外定义一个变量，效果是一样的）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 const Timer = () =\u0026gt; { const intervalRef = useRef(null); useEffect(() =\u0026gt; { intervalRef.current = setInterval(() =\u0026gt; { // ... }); return () =\u0026gt; { clearInterval(intervalRef.current); }; }); // ... return null; }; useLayoutEffect 顾名思义，它是作用在浏览器 Layout 阶段的“副作用”；和 useEffect 的区别只是调用时机不同；既然是作用在 Layout 阶段的副作用，那么必须在浏览器渲染之前进行调用，所以可能会阻塞浏览器渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新，如果在里面执行耗时任务的话，页面就会卡顿。\n自定义 Hook 自定义 Hook 是一个函数，其名称以“use”开头（方便静态代码检测），函数内部可以调用其他的 Hook；它是一种重用状态逻辑的机制，其中的所有 state 和副作用都是完全隔离的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function useFriendStatus(friendID) { const [isOnline, setIsOnline] = useState(null); useEffect(() =\u0026gt; { function handleStatusChange(status) { setIsOnline(status.isOnline); } ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () =\u0026gt; { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } 使用 Hook 实现节流/防抖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 type intervalType = | ReturnType\u0026lt;typeof setInterval\u0026gt; | ReturnType\u0026lt;typeof setTimeout\u0026gt; | null; type fnType = (...rest: any[]) =\u0026gt; unknown; // 节流 function jieliuFn(callback: fnType | null, delay: number) { const getNow = () =\u0026gt; Date.now(); let pervious = 0; return function (this: any, ...rest: any[]) { let current = getNow(); if (current - pervious \u0026gt;= delay) { pervious = current; if (typeof callback === \u0026#39;function\u0026#39;) { callback.apply(this, rest); } } }; } export function useJieliu(fn: fnType, delay: number) { const fnRef = useRef\u0026lt;fnType | null\u0026gt;(fn); useEffect(() =\u0026gt; { fnRef.current = fn; }); return useCallback(jieliuFn(fnRef.current, delay), []); } // 使用节流 export default function JieliuTest() { const handleClick = function (this: any, params: MouseEvent) { console.log(params, this); }; const jieliuFn = useJieliu(handleClick, 1000); useEffect(() =\u0026gt; { document.addEventListener(\u0026#39;click\u0026#39;, jieliuFn); return () =\u0026gt; document.removeEventListener(\u0026#39;click\u0026#39;, jieliuFn); }, []); return \u0026lt;main\u0026gt;节流测试\u0026lt;/main\u0026gt;; } // 防抖 function fangdouFn( callback: fnType | null, delay: number, isImmediate: boolean = false ) { let interval: intervalType = null; return function (this: any, ...rest: any[]) { if (interval) { clearTimeout(interval); } if (isImmediate \u0026amp;\u0026amp; !interval) { if (typeof callback === \u0026#39;function\u0026#39;) { callback.apply(this, rest); } } interval = setTimeout(() =\u0026gt; { if (typeof callback === \u0026#39;function\u0026#39;) { callback.apply(this, rest); } }, delay); }; } export function useFangdou(fn: fnType, delay: number, isImmediate = false) { const fnRef = useRef\u0026lt;fnType | null\u0026gt;(fn); useEffect(() =\u0026gt; { fnRef.current = fn; }); return useCallback(fangdouFn(fnRef.current, delay, isImmediate), []); } export default function FangdouTest() { const handleClick = function (this: any, params: MouseEvent) { console.log(params, this); }; const fangdouFn = useFangdou(handleClick, 1000); useEffect(() =\u0026gt; { document.addEventListener(\u0026#39;click\u0026#39;, fangdouFn); return () =\u0026gt; document.removeEventListener(\u0026#39;click\u0026#39;, fangdouFn); }, []); return \u0026lt;main\u0026gt;防抖测试\u0026lt;/main\u0026gt;; } 使用 Hook 实现 setInterval/setTimeout：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 // setInterval export function useSetInterval(fn: fnType, delay: number) { const fnRef = useRef\u0026lt;fnType | null\u0026gt;(fn); const interval = useRef\u0026lt;intervalType\u0026gt;(null); const clearFn = useCallback(() =\u0026gt; { interval?.current \u0026amp;\u0026amp; clearInterval(interval.current); }, []); useEffect(() =\u0026gt; { fnRef.current = fn; }); useEffect(() =\u0026gt; { interval.current = setInterval(() =\u0026gt; { if (typeof fnRef.current === \u0026#39;function\u0026#39;) { fnRef.current(); } }, delay); return clearFn; }, [delay]); return clearFn; } // 使用 useSetInterval export default function SetIntervalTest() { const clearSetInterval = useSetInterval(() =\u0026gt; { console.log(\u0026#39;useSetInterval\u0026#39;); }, 3000); return \u0026lt;main onClick={clearSetInterval}\u0026gt;useSetInterval 测试\u0026lt;/main\u0026gt;; } // setTimeout export function useSetTimneout(fn: fnType, delay: number) { const fnRef = useRef\u0026lt;fnType | null\u0026gt;(fn); const interval = useRef\u0026lt;intervalType\u0026gt;(null); const clearFn = useCallback(() =\u0026gt; { interval?.current \u0026amp;\u0026amp; clearTimeout(interval.current); }, []); useEffect(() =\u0026gt; { fnRef.current = fn; }); useEffect(() =\u0026gt; { interval.current = setTimeout(() =\u0026gt; { if (typeof fnRef.current === \u0026#39;function\u0026#39;) { fnRef.current(); clearFn(); } }, delay); return clearFn; }, [delay]); return clearFn; } // 使用 useSetTimneout export default function SetIntervalTest() { const clearSetTimeout = useSetTimneout(() =\u0026gt; { console.log(\u0026#39;useSetTimneout\u0026#39;); }, 3000); return \u0026lt;main onClick={clearSetTimeout}\u0026gt;useSetInterval 测试\u0026lt;/main\u0026gt;; } 使用 Hook 实现 forceUpdate：\n1 2 3 4 5 6 7 8 9 10 // forceUpdate export function useForceUpdate() { const [, forceUpdate] = useReducer(x =\u0026gt; x + 1, 0); return useCallback(() =\u0026gt; forceUpdate(), []); } // 使用 useForceUpdate export default function ForceUpdateTest() { const forceUpdate = useForceUpdate(); return \u0026lt;main onClick={forceUpdate}\u0026gt;{Date.now()} 测试\u0026lt;/main\u0026gt;; } ","date":"2020-02-27T00:00:00Z","image":"https://vikingama.github.io/img/cover/react.png","permalink":"https://vikingama.github.io/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%AD/","title":"React 复习笔记（中）"},{"content":"JSX 与 React 元素 JSX 是一个 JavaScript 的语法扩展；在编译之后，JSX 会被 Babel 转为函数调用，对其取值后得到 JS 对象。JSX 使用 camelCase 来定义属性的名称，而不使用 HTML 属性名称的命名约定。\n对于 React，JSX 仅仅是 React.createElement(component, props, \u0026hellip;children) 函数的语法糖；包含在开始和结束标签之间的 JSX 表达式内容将作为特定属性 props.children 传递给外层组件。\n与浏览器的 DOM 元素不同，React 元素是不可变对象；一旦被创建，就无法更改它的子元素或者属性；一个元素就像电影的单帧：它代表了某个特定时刻的 UI。React 元素是创建开销极小的普通对象；ReactDOM 会将元素和它的子元素与它们之前的状态进行比较，通过 Diff 算法使 DOM 与 React 元素保持一致。\n组件生命周期 当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：\nconstructor() static getDerivedStateFromProps() render() componentDidMount() 当组件的 props 或 state 发生变化时会触发更新；其生命周期调用顺序如下：\nstatic getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 当组件从 DOM 中移除时，其生命周期调用顺序如下：\ncomponentWillUnmount() 当渲染过程、生命周期、或子组件的构造函数中抛出错误时，其生命周期调用顺序如下：\nstatic getDerivedStateFromError() componentDidCatch() 错误边界 错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JS 错误，并且会渲染出备用 UI，而不是渲染那些崩溃了的子组件树；如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界；自 React 16 起，任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载。\n只有 class 组件才可以成为错误边界组件，如果一个 class 组件中定义了 static getDerivedStateFromError 或 componentDidCatch 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError 渲染备用 UI，使用 componentDidCatch 打印错误信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error) { // 更新 state，渲染能够显示降级后的 UI return { hasError: true }; } componentDidCatch(error, errorInfo) { // 将错误日志上报给服务器 logErrorToMyService(error, errorInfo); } render() { if (this.state.hasError) { // 自定义降级后的 UI 并渲染 return \u0026lt;h1\u0026gt;出错啦...\u0026lt;/h1\u0026gt;; } return this.props.children; } } // 然后你可以将它作为一个常规组件去使用 \u0026lt;ErrorBoundary\u0026gt; \u0026lt;MyWidget /\u0026gt; \u0026lt;/ErrorBoundary\u0026gt;; 错误边界无法捕获以下场景中产生的错误：\n事件处理； 异步代码，例如 setTimeout 或 requestAnimationFrame 回调函数； 服务端渲染； 它自身抛出来的错误（并非它的子组件）。 Refs 1 2 3 4 5 6 7 8 9 10 11 12 class AutoFocusTextInput extends React.Component { constructor(props) { super(props); this.textInput = React.createRef(); } componentDidMount() { this.textInput.current.focusTextInput(); } render() { return \u0026lt;CustomTextInput ref={this.textInput} /\u0026gt;; } } refs 主要用于：\n管理焦点，文本选择或媒体播放； 触发强制动画； 集成第三方 DOM 库。 ref 的值根据节点的类型而有所不同：\n当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问； 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性； 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。 React.createContext 创建一个 Context 对象，每个 Context 对象都会返回一个 Provider 组件，它允许消费组件订阅 Context 的变化；当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 Context 值。\nProvider 接收一个 value 属性，传递给消费组件；一个 Provider 可以和多个消费组件有对应关系；多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。\n当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染；Provider 及其内部 Consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 Consumer 组件在其祖先组件退出更新的情况下也能更新。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); // 默认值 light const App = () =\u0026gt; { /** * 使用一个 Provider 来将当前的 theme 传递给以下的组件树 * 无论多深，任何组件都能读取这个值 * 在这个例子中，我们将“dark”作为当前的值传递下去 */ return ( \u0026lt;ThemeContext.Provider value=\u0026#34;dark\u0026#34;\u0026gt; \u0026lt;Toolbar /\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); }; // 中间的组件再也不必指明往下传递 theme 了 const Toolbar = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;ThemedButton /\u0026gt; \u0026lt;/div\u0026gt; ); // 指定 contextType 读取当前的 ThemeContext，React 会往上找到最近的 ThemeContext.Provider，然后使用它的值 const ThemedButton = () =\u0026gt; \u0026lt;Button theme={this.context} /\u0026gt;; ThemedButton.contextType = ThemeContext; Context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。\n1 2 3 4 const MyContext = React.createContext(/* some value */); MyContext.displayName = \u0026#39;MyDisplayName\u0026#39;; \u0026lt;MyContext.Provider\u0026gt; // \u0026#34;MyDisplayName.Provider\u0026#34; 在 DevTools 中 \u0026lt;MyContext.Consumer\u0026gt; // \u0026#34;MyDisplayName.Consumer\u0026#34; 在 DevTools 中 消费多个 Context。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const ThemeContext = React.createContext(\u0026#39;light\u0026#39;); const UserContext = React.createContext({ name: \u0026#39;Guest\u0026#39; }); const App = ({ signedInUser, theme }) =\u0026gt; { // 提供初始 context 值的 App 组件 return ( \u0026lt;ThemeContext.Provider value={theme}\u0026gt; \u0026lt;UserContext.Provider value={signedInUser}\u0026gt; \u0026lt;Layout /\u0026gt; \u0026lt;/UserContext.Provider\u0026gt; \u0026lt;/ThemeContext.Provider\u0026gt; ); }; const Layout = () =\u0026gt; ( \u0026lt;div\u0026gt; \u0026lt;Sidebar /\u0026gt; \u0026lt;Content /\u0026gt; \u0026lt;/div\u0026gt; ); const Content = () =\u0026gt; ( \u0026lt;ThemeContext.Consumer\u0026gt; {theme =\u0026gt; ( \u0026lt;UserContext.Consumer\u0026gt; {user =\u0026gt; \u0026lt;ProfilePage user={user} theme={theme} /\u0026gt;} \u0026lt;/UserContext.Consumer\u0026gt; )} \u0026lt;/ThemeContext.Consumer\u0026gt; ); ReactDOM.createPortal 将子节点渲染到父组件以外的 DOM 节点，AntDesign 的弹窗就是使用 ReactDOM.createPortal 进行渲染的；尽管 portal 可以被放置在 DOM 树中的任何地方，但其行为和普通的 React 子节点行为一致，portal 仍存在于 React 树，且与 DOM 中的位置无关；一个从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 中的祖先。\nReactDOM.createPortal 返回的 VitrualDOM 对象会有一个叫做 containerInfo 的属性指向挂载的 DOM 节点；React 内部正是通过判断 containerInfo 属性是否存在来决定 VitrualDOM 的挂载方式的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 在 DOM 中有两个容器是兄弟级 const appRoot = document.getElementById(\u0026#39;app-root\u0026#39;); const modalRoot = document.getElementById(\u0026#39;modal-root\u0026#39;); const Child = () =\u0026gt; { // 这个按钮的点击事件会冒泡到父元素 return ( \u0026lt;div className=\u0026#34;modal\u0026#34;\u0026gt; \u0026lt;button\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; class Modal extends React.Component { constructor(props) { super(props); this.el = document.createElement(\u0026#39;div\u0026#39;); } componentDidMount() { modalRoot.appendChild(this.el); } componentWillUnmount() { modalRoot.removeChild(this.el); } render() { return ReactDOM.createPortal(this.props.children, this.el); } } class Parent extends React.Component { constructor(props) { super(props); this.state = { clicks: 0 }; } handleClick = () =\u0026gt; { // 当子元素里的按钮被点击时，这个将会被触发更新父元素的 state，即使这个按钮在 DOM 中不是直接关联的后代 this.setState(state =\u0026gt; ({ clicks: state.clicks + 1 })); }; render() { return ( \u0026lt;div onClick={this.handleClick}\u0026gt; \u0026lt;p\u0026gt;{this.state.clicks}\u0026lt;/p\u0026gt; \u0026lt;Modal\u0026gt; \u0026lt;Child /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; ); } } ReactDOM.render(\u0026lt;Parent /\u0026gt;, appRoot); React.forwardRef React.forwardRef 用于 refs 转发，将 ref 自动地通过组件传递到其一子组件；React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * 1. 通过调用 React.createRef 创建了一个 ref 并将其赋值给 btn 变量 * 2. 通过指定 ref 为 JSX 属性，将其向下传递给 \u0026lt;FancyButton ref={btn}\u0026gt; * 3. React 传递 ref 给 forwardRef 内函数 (props, ref) =\u0026gt; ...，作为其第二个参数 * 4. 向下转发该 ref 参数到 \u0026lt;button ref={ref}\u0026gt;，将其指定为 JSX 属性 * 5. 当 ref 挂载完成，ref.current 将指向 \u0026lt;button\u0026gt; DOM 节点 */ const FancyButton = React.forwardRef((props, ref) =\u0026gt; ( \u0026lt;button ref={ref} className=\u0026#34;FancyButton\u0026#34;\u0026gt; {props.children} \u0026lt;/button\u0026gt; )); const App = () =\u0026gt; { const btn = React.createRef(); // 可以获取底层 DOM 节点 button 的 ref return ( \u0026lt;\u0026gt; \u0026lt;FancyButton ref={btn}\u0026gt;点我\u0026lt;/FancyButton\u0026gt; \u0026lt;/\u0026gt; ); }; React.lazy \u0026amp; Suspense React.lazy 接受一个函数，这个函数需要动态调用 import 并返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件；是的，React.lazy 目前只支持默认导出。应该在 Suspense 组件中渲染 React.lazy 组件，如此使得在等待加载组件时做优雅降级。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 基于路由的代码分割 const Home = React.lazy(() =\u0026gt; import(\u0026#39;./pages/Home\u0026#39;)); const About = React.lazy(() =\u0026gt; import(\u0026#39;./pages/About\u0026#39;)); const App = () =\u0026gt; ( \u0026lt;Router\u0026gt; \u0026lt;Suspense fallback={\u0026lt;div\u0026gt;Loading...\u0026lt;/div\u0026gt;}\u0026gt; \u0026lt;Switch\u0026gt; \u0026lt;Route exact path=\u0026#34;/\u0026#34; component={Home} /\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34; component={About} /\u0026gt; \u0026lt;/Switch\u0026gt; \u0026lt;/Suspense\u0026gt; \u0026lt;/Router\u0026gt; ); 高阶组件 高阶组件是参数为组件，返回值为新组件的函数；组件是将 props 转换为 UI，而高阶组件是将组件转换为另一个组件；高阶组件有两种：\n新组件包裹旧组件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function withEnhancerOne(WrappedComponent) { class EnhancerComponent extends Component { // ... render() { if (boolean) { return null; } // 将 HOC 接受到的 props 传入被包裹的组件，还传入了一些新的 props return ( \u0026lt;\u0026gt; \u0026lt;div style={{ fontSize: 16 }}\u0026gt; \u0026lt;WrappedComponent {...this.props} {...otherProps} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/\u0026gt; ); } } EnhancerComponent.displayName = `EC-(${ WrappedComponent.displayName || WrappedComponent.name || \u0026#39;Component\u0026#39; })`; return EnhancerComponent; } 新组件继承旧组件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function withEnhancerTwo(WrappedComponent) { return class EnhancerComponent extends WrappedComponent { // 可以通过 super 访问到 WrappedComponent 中的各种变量和方法 render() { if (boolean) { return null; } return ( \u0026lt;\u0026gt; \u0026lt;div\u0026gt;EnhancerComponent\u0026lt;/div\u0026gt; {super.render()} \u0026lt;/\u0026gt; ); } }; } 组合模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const TabItem = ({ active, children, onClick }) =\u0026gt; { const style = { border: active ? \u0026#39;1px solid red\u0026#39; : 0, color: active ? \u0026#39;red\u0026#39; : \u0026#39;green\u0026#39; }; return ( \u0026lt;h3 style={style} onClick={onClick}\u0026gt; {children} \u0026lt;/h3\u0026gt; ); }; class Tabs extends Component { state = { activeIndex: 0 }; render() { const childrenReplacement = React.children .toArray(this.props.children) .map((child, index) =\u0026gt; { if (React.isValidElement(child)) { /** * 要想扩展传给子节点的 props，只能通过 React.cloneElement * 直接修改 props 对象是不行滴 */ return React.cloneElement(child, { active: this.state.activeIndex === index, onClick: () =\u0026gt; this.setState({ activeIndex: index }) }); } }) .filter(({ props }) =\u0026gt; !props.disabled); // 不渲染原有的 children，改为渲染 childrenReplacement return \u0026lt;\u0026gt;{childrenReplacement}\u0026lt;/\u0026gt;; } } \u0026lt;Tabs\u0026gt; \u0026lt;TabItem\u0026gt;One\u0026lt;/TabItem\u0026gt; \u0026lt;TabItem disabled\u0026gt;Two\u0026lt;/TabItem\u0026gt; \u0026lt;TabItem\u0026gt;Three\u0026lt;/TabItem\u0026gt; \u0026lt;/Tabs\u0026gt;; ","date":"2020-02-25T00:00:00Z","image":"https://vikingama.github.io/img/cover/react.png","permalink":"https://vikingama.github.io/p/react-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%8A/","title":"React 复习笔记（上）"},{"content":"原始类型（一）：boolean、number、string、void、undefined、null、symbol、bigint 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 不是 Boolean，否则会被认为是布尔对象 const isOk: boolean = true; // 十进制、十六进制、二进制都是 number 类型 const num: number = 666; const str: string = \u0026#39;hahasha\u0026#39;; const sym: symbol = Symbol(\u0026#39;sym\u0026#39;); // JS 安全整数范围有限，可以使用 bigint 类型解决，ES6 也引入了 BigInt const bigInt: bigint = BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1); // strictNullChecks = true const a: void = undefined; // pass const a: void = null; // fault const a: null = undefined; // fault const a: undefined = null; // fault // strictNullChecks = false const a: void = undefined; // pass const a: void = null; // pass const a: null = undefined; // pass const a: undefined = null; // pass 原始类型（二）：any、unknown、never、object、数组、元组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 检查器不会对 any 类型进行类型检查而直接进行编译 let anyType: any; anyType = \u0026#39;hahasha\u0026#39;; anyType = 0; anyType.foo.bar; // pass anyType[0][1]; // pass new anyType(); // pass anyType(); // pass /** * unknown 类型的值可以被赋值给任何类型 * 当 unknown 类型被确定是某个类型之前 * 不可以被进行任何操作比如实例化等 */ let unknownType: unknown; unknownType = \u0026#39;hahasha\u0026#39;; unknownType = false; unknownType.foo.bar; // fault unknownType[0][1]; // fault new unknownType(); // fault unknownType(); // fault function example(v: unknown): string { if (v instanceof Date) { // v 的类型从 unknown 缩小到了 Date 实例，可以进行操作 return v.toISOString(); } return String(v); } // never 类型表示永远不存在的类型 type people = \u0026#39;male\u0026#39; \u0026amp; \u0026#39;female\u0026#39;; // 不同字符串类型不能相交，故为 never const emptyArr: never[] = []; // 永远是空数组 function error(e: string): never { // 抛出异常，永远不会有返回值 throw new Error(e); } // 数组类型定义方式 const list1: Array\u0026lt;number\u0026gt; = [1, 2, 3, 4]; const list2: number[] = [5, 6, 7, 8]; // 元组表示一个已知元素数量和类型的数组 const tuple1: [string, number, boolean] = [\u0026#39;hello\u0026#39;, 123, true]; // pass // 元组中的元素，必须与声明的类型一致，不能多、不能少、顺序不能错 const tuple2: [string, number, boolean] = [true, 123, \u0026#39;hello\u0026#39;]; // fault const tuple3: [string, number, boolean] = [\u0026#39;hello\u0026#39;, \u0026#39;hello\u0026#39;]; // fault // 元组继承于数组，拥有比数组更严格的类型检查 interface Tuple extends Array\u0026lt;string | number | boolean\u0026gt; { 0: string; 1: number; 2: boolean; length: 3; } // 元组越界问题 const over: [string, number] = [\u0026#39;over\u0026#39;, 0]; over.push(1); // pass // 允许向元组中使用数组的 push 方法插入新元素 console.log(over); // [\u0026#34;over\u0026#34;, 0, 1]; // 访问新加入的元素时，会报错 console.log(over[2]); // fault // object 表示非原始类型，普通对象、枚举、数组、元组都是 object 类型 let o: object; o = [1]; o = { value: false }; 枚举类型：用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型，本质是 JS 对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 // 数字枚举 enum Direction { Up, Down, Left, Right } console.log(Direction.Up === 0); // true console.log(Direction.Down === 1); // true console.log(Direction.Left === 2); // true console.log(Direction.Right === 3); // true // 把第一个值赋值后，后面也会根据第一个值进行累加 enum Direction { Up = 10, Down, Left, Right } console.log( Direction.Up, // 10 Direction.Down, // 11 Direction.Left, // 12 Direction.Right // 13 ); // 字符串枚举 enum Direction { Up = \u0026#39;Up\u0026#39;, Down = \u0026#39;Down\u0026#39;, Left = \u0026#39;Left\u0026#39;, Right = \u0026#39;Right\u0026#39; } console.log( Direction[\u0026#39;Right\u0026#39;], // Right Direction.Up // Up ); // 异构枚举 enum BooleanLikeHeterogeneousEnum { No = 0, Yes = \u0026#39;YES\u0026#39; } // 反向映射 name \u0026lt;=\u0026gt; value enum Direction { Up, Down, Left, Right } console.log(Direction[0]); // Up // 枚举的本质 var Direction; (function (Direction) { Direction[(Direction[\u0026#39;Up\u0026#39;] = 10)] = \u0026#39;Up\u0026#39;; Direction[(Direction[\u0026#39;Down\u0026#39;] = 11)] = \u0026#39;Down\u0026#39;; Direction[(Direction[\u0026#39;Left\u0026#39;] = 12)] = \u0026#39;Left\u0026#39;; Direction[(Direction[\u0026#39;Right\u0026#39;] = 13)] = \u0026#39;Right\u0026#39;; })(Direction || (Direction = {})); // 联合枚举与枚举成员的类型 enum Direction { Up, Down, Left, Right } const va = 0; console.log(va === Direction.Up); // true type vc = 0; declare let vb: vc; vb = 1; // fault vb = Direction.Up; // pass // 联合枚举类型 enum Direction { Up, Down, Left, Right } declare let a: Direction; enum Animal { Dog, Cat } a = Direction.Up; // pass a = Animal.Dog; // fault // 枚举合并 enum Direction { Up = \u0026#39;Up\u0026#39;, Down = \u0026#39;Down\u0026#39;, Left = \u0026#39;Left\u0026#39;, Right = \u0026#39;Right\u0026#39; } enum Direction { Center = 1 } // 转换为 JS 后 var Direction; (function (Direction) { Direction[\u0026#39;Up\u0026#39;] = \u0026#39;Up\u0026#39;; Direction[\u0026#39;Down\u0026#39;] = \u0026#39;Down\u0026#39;; Direction[\u0026#39;Left\u0026#39;] = \u0026#39;Left\u0026#39;; Direction[\u0026#39;Right\u0026#39;] = \u0026#39;Right\u0026#39;; })(Direction || (Direction = {})); (function (Direction) { Direction[(Direction[\u0026#39;Center\u0026#39;] = 1)] = \u0026#39;Center\u0026#39;; })(Direction || (Direction = {})); // 为枚举添加静态方法（借助命名空间） enum Month { January, February, March, April, May, June, July, August, September, October, November, December } namespace Month { export function isSummer(month: Month) { switch (month) { case Month.June: case Month.July: case Month.August: return true; default: return false; } } } console.log(Month.isSummer(Month.January)); // false 接口：为类型命名、为你的代码或第三方代码定义契约 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 使用接口来描述 Cook 函数 interface Cook { (foods: string): string; } // 可索引类型 interface Mail { [name: string]: string; } // 使用接口来描述 User 对象 interface User { name: string; age?: number; // 可选属性 readonly isMale: boolean; // 只读属性 say: (words: string) =\u0026gt; string; // 函数属性 cook: Cook; // 函数属性 mail: Mail; } const getUserName = (user: User) =\u0026gt; user.name; // 属性检查 interface Config { width?: number; } function CalculateAreas(config: Config): { area: number } { let square = 100; if (config.width) { square = config.width * config.width; } return { area: square }; } // 如果对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误 let mySquare = CalculateAreas({ widdth: 5 }); // 这里传入的是 widdth 不是 width，TS 会认为这段代码有问题 let mySquare = CalculateAreas({ widdth: 5 } as Config); // 可以使用类型断言解决错误 interface Config { width?: number; [propName: string]: any; // 可以给 Config 类型添加字符串索引 } // 继承接口 interface VIPUser extends User { broadcast: () =\u0026gt; void; } 类 接口与类的区别：\ninterface 是仅存在于 TS 上下文中的一种虚拟结构，TS 依赖接口用于类型检查，编译为 JS 后，接口将会被移除； class 作为 TS 的一种变量类型存在于上下文之中，class 可以提供变量、方法等的具体实现方式等，它的作用不仅仅是约束数据结构； class 和 interface 都可以用来约束数据的结构，但是频繁使用 class 会使程序的性能受到影响。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 抽象类：其它派生类的基类，不同于接口，它可以包含成员的实现细节 * abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法 */ abstract class Animal { abstract makeSound(): void; move(): void { console.log(\u0026#39;move\u0026#39;); } } // 抽象类不能直接实例化，需要创建子类集成基类 class Cat extends Animal { makeSound() { console.log(\u0026#39;miao\u0026#39;); } } const tom = new Cat(); cat.makeSound(); // miao cat.move(); // move /** * 访问限定符：public（默认）、private、protected * 当成员被设置为 private 之后，被此限定符修饰的成员是只可以被类的内部访问 * 当成员被设置为 protected 之后，被此限定符修饰的成员是只可以被类的内部以及类的子类访问 */ class Car { protected run() { console.log(\u0026#39;启动...\u0026#39;); } } class GTR extends Car { init() { this.run(); } } const car = new Car(); const gtr = new GTR(); car.run(); // fault gtr.init(); // 启动... gtr.run(); // fault 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // TS 可以感知到函数的返回值是 number 类型 const add = (a: number, b: number) =\u0026gt; a + b; const decline: (a: number, b?: number) =\u0026gt; number = (a, b) =\u0026gt; a - (b ? b : 0); // 重载 interface Direction { top: number; right?: number; bottom?: number; left?: number; } function assigned(all: number): Direction; function assigned(topAndBottom: number, leftAndRight: number): Direction; function assigned( top: number, right: number, bottom: number, left: number ): Direction; // 代码实现函数不可被调用 function assigned(a: number, b?: number, c?: number, d?: any) { if (b === undefined \u0026amp;\u0026amp; c === undefined \u0026amp;\u0026amp; d === undefined) { b = c = d = a; } else if (c === undefined \u0026amp;\u0026amp; d === undefined) { c = a; d = b; } return { top: a, right: b, bottom: c, left: d }; } 泛型：一种特殊的变量，只用于表示类型而不是值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 function returnValue\u0026lt;T\u0026gt;(para: T): T { return para; } function swap\u0026lt;T, U\u0026gt;(tuple: [T, U]): [U, T] { let temp = tuple.concat(); return temp.reverse(); } // 泛型变量 function getLength\u0026lt;T\u0026gt;(arg: Array\u0026lt;T\u0026gt;) { console.log(arg.length); return arg; } // 泛型接口 interface ReturnItem\u0026lt;T\u0026gt; { (para: T): T; } const returnItem: ReturnItem\u0026lt;number\u0026gt; = para =\u0026gt; para; // 泛型类 class Stack\u0026lt;T\u0026gt; { private arr: T[] = []; public push(item: T) { this.arr.push(item); } public pop() { this.arr.pop(); } } // 泛型约束：泛型似乎可以是任何类型，如果我们知道传入的泛型属于哪一类，比如属于 number 或者 string 其中之一，那么应该如何约束泛型 type Params = number | string; // 泛型类型被约束为 number 或 string class Stack\u0026lt;T extends Params\u0026gt; { private arr: T[] = []; public push(item: T) { this.arr.push(item); } public pop() { this.arr.pop(); } } function getValue\u0026lt;T extends object, U extends keyof T\u0026gt;(o: T, k: U) { return o[k]; } // 泛型参数的默认类型 interface DefaultType\u0026lt;T = boolean\u0026gt; { isMarried: T; } type isMarried = DefaultType\u0026lt;number\u0026gt;; const gwenIsMarried: isMarried = { isMarried: 1 }; // 多重泛型约束 interface First { doSomething(): number; } interface Second { doSomethingElse(): string; } interface Child extends First, Second {} class Demo\u0026lt;T extends Child\u0026gt; { private genericProperty: T; useT() { this.genericProperty.doSomething(); this.genericProperty.doSomethingElse(); } } // 也可以用 \u0026amp; 实现多重泛型约束 class Demo\u0026lt;T extends First \u0026amp; Second\u0026gt; { private genericProperty: T; useT() { this.genericProperty.doSomething(); this.genericProperty.doSomethingElse(); } } // 泛型与 new function factory\u0026lt;T\u0026gt;(type: { new (): T }): T { return new type(); } // 泛型条件类型 interface Dictionary\u0026lt;T = unknown\u0026gt; { [prop: string]: T; } // 当 T 是类型 Dictionary 的子集时，就返回类型 V type VDictionary\u0026lt;T\u0026gt; = T extends Dictionary\u0026lt;infer V\u0026gt; ? V : never; type ChineseDictionary = Dictionary\u0026lt;\u0026#39;chinese\u0026#39;\u0026gt;; type Chinese = VDictionary\u0026lt;ChineseDictionary\u0026gt;; // \u0026#39;chinese\u0026#39; // 泛型工具 type CustomPartial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; type CustomRequired\u0026lt;T\u0026gt; = { [P in keyof T]-?: T[P]; }; type CustomRecord\u0026lt;K extends keyof any, T\u0026gt; = { [P in K]: T; }; type CustomPick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[P]; }; type CustomExclude\u0026lt;T, U\u0026gt; = T extends U ? never : U; type CustomExtract\u0026lt;T, U\u0026gt; = T extends U ? T : never; type CustomOmit\u0026lt;T, K extends keyof any\u0026gt; = Pick\u0026lt;T, Exclude\u0026lt;keyof T, K\u0026gt;\u0026gt;; type CustomReturnType\u0026lt;T\u0026gt; = T extends (...args: any[]) =\u0026gt; infer V ? V : never; 类型断言与类型守卫 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 interface Person { name: string; age: number; } const person = {} as Person; person.name = \u0026#39;hahasha\u0026#39;; person.age = 18; /** * 断言的前提是“值的类型需要和断言的类型兼容” * 如果不兼容，可以使用双重断言 */ const anyPerson = \u0026#39;hahasha\u0026#39; as any as Person; // 类型守卫，缩小类型范围 class Person { name = \u0026#39;xiaomuzhu\u0026#39;; age = 20; } class Animal { name = \u0026#39;petty\u0026#39;; color = \u0026#39;pink\u0026#39;; } function getSometing(arg: Person | Animal) { if (arg instanceof Person) { console.log(arg.color); // fault console.log(arg.age); // pass } if (arg instanceof Animal) { console.log(arg.age); // fault console.log(arg.color); // pass } } // 字面量类型守卫 type Foo = { kind: \u0026#39;foo\u0026#39;; // 字面量类型 foo: number; }; type Bar = { kind: \u0026#39;bar\u0026#39;; // 字面量类型 bar: number; }; function doStuff(arg: Foo | Bar) { if (arg.kind === \u0026#39;foo\u0026#39;) { console.log(arg.foo); // pass console.log(arg.bar); // fault } else { console.log(arg.foo); // fault console.log(arg.bar); // pass } } 高级类型：交叉类型、联合类型、类型别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // 交叉类型是将多个类型合并为一个类型 interface AnyObject { [prop: string]: any; } function mixin\u0026lt;T extends AnyObject, U extends AnyObject\u0026gt;( first: T, second: U ): T \u0026amp; U { const result = \u0026lt;T \u0026amp; U\u0026gt;{}; for (let id in first) { (\u0026lt;T\u0026gt;result)[id] = first[id]; } for (let id in second) { if (!result.hasOwnProperty(id)) { (\u0026lt;U\u0026gt;result)[id] = second[id]; } } return result; } // 联合类型 function formatCommandline(command: string[] | string) { let line = \u0026#39;\u0026#39;; if (typeof command === \u0026#39;string\u0026#39;) { line = command.trim(); } else { line = command.join(\u0026#39; \u0026#39;).trim(); } } // 类型别名 type some = boolean | string; const b: some = true; // pass const c: some = \u0026#39;hello\u0026#39;; // pass const d: some = 123; // fault type Container\u0026lt;T\u0026gt; = { value: T }; type Tree\u0026lt;T\u0026gt; = { value: T; left: Tree\u0026lt;T\u0026gt;; right: Tree\u0026lt;T\u0026gt;; }; /** * interface 只能用于定义对象类型，而 type 还可以定义交叉、联合、原始类型等 * interface 可以实现接口的 extends 和 implements * interface 可以实现接口合并声明 */ type Alias = { num: number }; interface Interface { num: number; } declare function aliased(arg: Alias): Alias; declare function interfaced(arg: Interface): Interface; 可辨识联合类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * 字面量：真值字面量类型、数字字面量类型、枚举字面量类型、大整数字面量类型、字符串字面量类型 * 字面量类型要和实际的值的字面量一一对应 */ const a: 2333 = 2333; // pass const b: 0x1919n = 6425n; // pass const c: \u0026#39;xiaomuzhu\u0026#39; = \u0026#39;xiaomuzhu\u0026#39;; // pass const g: \u0026#39;github\u0026#39; = \u0026#39;gitlab\u0026#39;; // fault const d: false = false; // pass // 字面量类型与联合类型结合模拟一个类似于枚举的效果 type Direction = \u0026#39;North\u0026#39; | \u0026#39;East\u0026#39; | \u0026#39;South\u0026#39; | \u0026#39;West\u0026#39;; function move(distance: number, direction: Direction) {} // 类型字面量，跟 JS 中的对象字面量的语法很相似 type Foo = { readonly [Symbol.iterator]: \u0026#39;github\u0026#39;; baz: [number, \u0026#39;xiaomuzhu\u0026#39;]; toString(): string; 0x1: \u0026#39;foo\u0026#39;; bar: 12n; }; // 可辨识联合类型 type UserAction = | { id: number; action: \u0026#39;delete\u0026#39;; info: Info; } | { action: \u0026#39;create\u0026#39;; info: Info; }; const UserReducer = (userAction: UserAction) =\u0026gt; { // 类型守卫 switch (userAction.action) { case \u0026#39;delete\u0026#39;: console.log(userAction.id); break; default: break; } }; 装饰器：在多个不同的类之间共享或者扩展一些方法或行为，而不是去直接修改它本身 JS 需要配合 babel-plugin-transform-decorators-legacy，TS 需要配合 experimentalDecorators 选项。\n装饰器本质上是一个函数，@expression 其实是一个语法糖，@expression 求值后必须也是一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 // 类装饰器 function addAge(constructor: Function) { constructor.prototype.age = 18; } @addAge class Person { name: string; age: number; constructor() { this.name = \u0026#39;xiaomuzhu\u0026#39;; } } console.log(new Person().age); // 18 // 这段代码等同于 Person = addAge(function Person() {}); // 属性/方法装饰器 function method(target: any, propKey: string, descriptor: PropertyDescriptor) { console.log(`target: ${target}`); console.log(`propKey: ${propKey}`); console.log(`descriptor: ${descriptor}`); descriptor.writable = false; } class Person { name: string; constructor() { this.name = \u0026#39;xiaomuzhu\u0026#39;; } @method say() { return \u0026#39;instance method\u0026#39;; } static run() { return \u0026#39;static method\u0026#39;; } } const xmz = new Person(); // 修改实例方法 xmz.say = function () { return \u0026#39;hello\u0026#39;; }; /** * target: Person { say: [Function] } * propKey: say * descriptor: {\u0026#34;writable\u0026#34;:true,\u0026#34;enumerable\u0026#34;:true,\u0026#34;configurable\u0026#34;:true} * * target: [Function: Person] { run: [Function] } * propKey: run * descriptor: {\u0026#34;writable\u0026#34;:true,\u0026#34;enumerable\u0026#34;:true,\u0026#34;configurable\u0026#34;:true} * * xmz.say = function() { * ^ * TypeError: Cannot assign to read only property \u0026#39;say\u0026#39; of object \u0026#39;#\u0026lt;Person\u0026gt;\u0026#39; */ // 参数装饰器 function logPara(target: object, propKey: string, index: number) { // Person { greet: [Function] } greet 1 // Person { greet: [Function] } greet 0 console.log(target, propKey, index); } class Person { greet(@logPara message: string, @logPara name: string): string { return `${message} ${name}`; } } const p = new Person(); p.greet(\u0026#39;hello\u0026#39;, \u0026#39;xiaomuzhu\u0026#39;); 赋值断言、is 关键字、可调用类型注解和类型推导 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 明确赋值断言：将 ! 放置在实例属性和变量声明之后，来表明此属性已经确定它已经被赋值了 let x: number; initialize(); console.log(x! + x!); // pass function initialize() { x = 10; } // is 关键字 function isString(test: any): test is string { // 判断 test 是不是 string 类型，并根据结果返回 boolean 类型 return typeof test === \u0026#39;string\u0026#39;; } function example(foo: number | string) { if (isString(foo)) { /** * 如果将 test is string 修改为 boolean 将报错 * 类型 string|number 上不存在 length 属性 */ console.log(foo.length); } } example(\u0026#39;hello world\u0026#39;); // 可调用类型注解 interface A { (): string; } declare const a: A; a(); // pass interface B { new (): string; } declare const b: B; new b(); //pass // 类型推导 const bar = [1, 2]; let [a, b] = bar; a = \u0026#39;hello\u0026#39;; // Error：不能把 \u0026#39;string\u0026#39; 类型赋值给 \u0026#39;number\u0026#39; 类型 索引类型、映射类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // keyof 索引类型查询操作符，用来获取所有 public 属性名构成的联合类型 class Image { src: string = \u0026#39;\u0026#39;; alt: string = \u0026#39;\u0026#39;; width: number = \u0026#39;\u0026#39;; } type propsNames = keyof Images; // \u0026#34;src\u0026#34; | \u0026#34;alt\u0026#34; | \u0026#34;width\u0026#34; // T[K] 索引访问操作符 type propsType = Images[propsName]; // \u0026#34;string\u0026#34; | \u0026#34;number\u0026#34; function pick\u0026lt;T, K extends keyof T\u0026gt;(o: T, names: K[]): T[K][] { return names.map(n =\u0026gt; o[n]); } // [K in Keys] 映射类型，K：类型变量，对应每个属性名的类型；Keys：字符串字面量构成的联合类型，表示一组属性名（的类型） interface User { username: string; id: number; token: string; avatar: string; role: string; } type partial\u0026lt;T\u0026gt; = { [K in keyof T]?: T[K] }; type partialUser = partial\u0026lt;User\u0026gt;; // 所有属性都变成了可选类型 条件类型 1 2 3 4 5 type Z = T extends U ? X : Y; // 若 T 能够赋值给 U，那么类型是 X，否则为 Y declare function f\u0026lt;T extends boolean\u0026gt;(x: T): T extends true ? string : number; f(Math.random() \u0026lt; 0.5); // string | number f(false); // number f(true); // string 参考 深入理解 TypeScript ","date":"2020-02-08T00:00:00Z","image":"https://vikingama.github.io/img/cover/typescript.png","permalink":"https://vikingama.github.io/p/typescript-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%80/","title":"TypeScript 复习总结（一）"},{"content":"跟着教程走还是比较顺畅的，虽然没有面面俱到，但是入门还是可以的。\n婴儿学步 1 2 3 4 5 6 7 8 9 let paramsArr = process.argv.slice(2); let result = 0; paramsArr.forEach(item =\u0026gt; { const i = item - 0; if (typeof i === \u0026#39;number\u0026#39;) { result += i; } }); console.log(result); 第一个 I/O 1 2 3 4 5 6 7 8 9 let fs = require(\u0026#39;fs\u0026#39;); try { const data = fs.readFileSync(process.argv[2], \u0026#39;utf-8\u0026#39;); const dataStr = data.toString(); const strArr = dataStr.split(\u0026#39;\\n\u0026#39;); console.log(strArr.length - 1); } catch (err) { console.error(err); } 第一个异步 I/O 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 let fs = require(\u0026#39;fs\u0026#39;); let readOneFile = file =\u0026gt; new Promise((resolve, reject) =\u0026gt; { fs.readFile(file, \u0026#39;utf-8\u0026#39;, (err, data) =\u0026gt; { if (err) { reject(err); } resolve(data); }); }); readOneFile(process.argv[2]) .then(data =\u0026gt; { const dataStr = data.toString(); const strArr = dataStr.split(\u0026#39;\\n\u0026#39;); console.log(strArr.length - 1); }) .catch(err =\u0026gt; new Error(err)); LS 过滤器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const ext = `.${process.argv[3]}`; let readDir = dir =\u0026gt; new Promise((resolve, reject) =\u0026gt; { fs.readdir(dir, (err, list) =\u0026gt; { if (err) { reject(err); } resolve(list); }); }); readDir(process.argv[2]) .then(list =\u0026gt; { list .filter(item =\u0026gt; path.extname(item) === ext) .forEach(item =\u0026gt; { console.log(item); }); }) .catch(err =\u0026gt; { console.error(err); }); 使其模块化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // module 1 const subModule = require(\u0026#39;./ms.06.p2\u0026#39;); const dir = process.argv[2]; const ext = process.argv[3]; let res = (dir, ext) =\u0026gt; new Promise((resolve, reject) =\u0026gt; { const cb = (err, data) =\u0026gt; { if (err) { reject(err); } resolve(data); }; subModule(dir, ext, cb); }); res(dir, ext) .then(list =\u0026gt; { list.forEach(item =\u0026gt; { console.log(item); }); }) .catch(err =\u0026gt; { console.error(err); }); // module 2 const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); module.exports = (dir, ext, cb) =\u0026gt; { fs.readdir(dir, (err, data) =\u0026gt; { if (err) { return cb(err); } const realExt = `.${ext}`; const list = data.filter(item =\u0026gt; realExt === path.extname(item)); return cb(null, list); }); }; HTTP 客户端 1 2 3 4 5 6 7 const http = require(\u0026#39;http\u0026#39;); http.get(process.argv[2], res =\u0026gt; { res.setEncoding(\u0026#39;utf-8\u0026#39;); res.on(\u0026#39;data\u0026#39;, data =\u0026gt; { console.log(data); }); }); HTTP 收集器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const http = require(\u0026#39;http\u0026#39;); let result = \u0026#39;\u0026#39;; http.get(process.argv[2], res =\u0026gt; { res.setEncoding(\u0026#39;utf-8\u0026#39;); res.on(\u0026#39;data\u0026#39;, data =\u0026gt; { result = result + data; }); res.on(\u0026#39;end\u0026#39;, () =\u0026gt; { console.log(result.length); console.log(result); }); res.on(\u0026#39;error\u0026#39;, err =\u0026gt; { console.error(err); }); }); 玩转异步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const http = require(\u0026#39;http\u0026#39;); const getUrl = url =\u0026gt; new Promise((resolve, reject) =\u0026gt; { let answer = \u0026#39;\u0026#39;; http.get(url, res =\u0026gt; { res.setEncoding(\u0026#39;utf-8\u0026#39;); res.on(\u0026#39;data\u0026#39;, data =\u0026gt; { answer = answer + data; }); res.on(\u0026#39;end\u0026#39;, () =\u0026gt; { resolve(answer); }); res.on(\u0026#39;error\u0026#39;, err =\u0026gt; { reject(err); }); }); }); Promise.all([ getUrl(process.argv[2]), getUrl(process.argv[3]), getUrl(process.argv[4]) ]) .then(res =\u0026gt; { res.forEach(item =\u0026gt; { console.log(item); }); }) .catch(err =\u0026gt; { console.log(err); }); 授时服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const net = require(\u0026#39;net\u0026#39;); const time = () =\u0026gt; { let now = new Date(); let y = now.getFullYear(); let m = now.getMonth() + 1; let d = now.getDate(); let h = now.getHours(); let ms = now.getMinutes(); m = m.toString().length \u0026gt; 1 ? m : `0${m}`; d = d.toString().length \u0026gt; 1 ? d : `0${d}`; h = h.toString().length \u0026gt; 1 ? h : `0${h}`; ms = ms.toString().length \u0026gt; 1 ? ms : `0${ms}`; const ymd = `${y}-${m}-${d}`; const hms = `${h}:${ms}`; return `${ymd} ${hms}\\n`; }; const server = net.createServer(socket =\u0026gt; { socket.end(time()); }); server.listen(process.argv[2]); HTTP 文件服务器 1 2 3 4 5 6 7 8 9 10 11 const http = require(\u0026#39;http\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { let readStream = fs.createReadStream(process.argv[3], { encoding: \u0026#39;utf-8\u0026#39; }); readStream.on(\u0026#39;data\u0026#39;, data =\u0026gt; { res.write(data); }); }); server.listen(process.argv[2]); HTTP 大写转换器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const http = require(\u0026#39;http\u0026#39;); const server = http.createServer((req, res) =\u0026gt; { req.setEncoding(\u0026#39;utf-8\u0026#39;); let body = \u0026#39;\u0026#39;; if (req.method === \u0026#39;POST\u0026#39;) { req.on(\u0026#39;data\u0026#39;, data =\u0026gt; { body = body + data.toUpperCase(); }); req.on(\u0026#39;end\u0026#39;, () =\u0026gt; { res.write(body); }); } }); server.listen(process.argv[2]); HTTP JSON API 服务器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 const http = require(\u0026#39;http\u0026#39;); const url = require(\u0026#39;url\u0026#39;); const app = http.createServer((req, res) =\u0026gt; { req.setEncoding(\u0026#39;utf-8\u0026#39;); if (req.method === \u0026#39;GET\u0026#39;) { const temp = url.parse(req.url, true); res.writeHead(200, { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }); res.end(JSON.stringify(job(temp))); } else { res.writeHead(405); res.end(); } }); function job(url) { const { pathname, query } = url; const { iso } = query; switch (pathname) { case \u0026#39;/api/parsetime\u0026#39;: return handleParse(iso); case \u0026#39;/api/unixtime\u0026#39;: return handleUnix(iso); default: return null; } } function handleParse(time) { const t = new Date(time); return { hour: t.getHours(), minute: t.getMinutes(), second: t.getSeconds() }; } function handleUnix(time) { const t = new Date(time); return { unixtime: t.getTime() }; } app.listen(process.argv[2]); ","date":"2019-12-26T00:00:00Z","image":"https://vikingama.github.io/img/cover/node.png","permalink":"https://vikingama.github.io/p/nodeschool-%E4%B9%8B-learnyounode/","title":"NodeSchool 之 LearnYouNode"},{"content":"梳理主干流程 从浏览器接收 URL 到开启网络请求线程（浏览器的机制、进程与线程之间的关系）； 开启网络线程到发出一个完整的 HTTP 请求（DNS 查询、TCP/IP 请求、五层因特网协议栈）； 从服务器接收到请求到对应后台接收到请求（负载均衡、安全拦截、后台内部的处理）； 后台和前台的 HTTP 交互（HTTP 头部、响应码、报文结构、Cookie 优化、编码解码）； 缓存问题，HTTP 的缓存（HTTP 缓存头部、ETag、Catch-Control）； 浏览器接收到 HTTP 数据包后的解析流程（解析 HTML、词法分析、DOM 树、CSS 规则树、渲染树、Layout、Paint、渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded、DOMContentLoaded）； CSS 的可视化格式模型（元素的渲染规则）； JS 引擎解析过程（解释阶段、预处理阶段、执行阶段生成执行上下文、作用域链、回收机制）； 拓展（跨域、Web 安全、Hybrid 模式）。 从浏览器接收 URL 到开启网络请求线程 这一部分展开的内容是：浏览器进程/线程模型，JS 运行机制。\n一、多进程的浏览器 浏览器是多进程的，有一个主控进程，以及每一个 Tab 页都会新开一个进程（某些情况下多个 Tab 会合并进程）；进程可能包括主控进程、插件进程、GPU、Tab 页（浏览器内核）等：\nBrowser 进程：浏览器的主进程（负责协调、主控），只有一个； 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建； GPU 进程：最多一个，用于 3D 绘制； 浏览器渲染进程（内核）：默认每个 Tab 页一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白 Tab 会合并成一个进程）。 二、多线程的浏览器内核 每一个 Tab 页可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：\nGUI 渲染线程； JS 引擎线程； 事件触发线程； 定时器线程； 网络请求线程。 三、解析 URL 输入 URL 后，会进行解析（URL 的本质就是统一资源定位符），URL 一般包括几大部分：\nprotocol，协议头，譬如有 http、ftp 等； host，主机域名或 IP 地址； port，端口号； path，目录路径； query，查询参数； fragment，即 # 后的 hash 值。 四、网络请求都是单独的线程 每次网络请求时都需要开辟单独的线程进行，如果 URL 解析到 HTTP 协议，就会新建一个网络线程去处理资源下载。\n更多参考： 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 。\n开启网络线程到发出一个完整的 HTTP 请求 这一部分主要内容包括：DNS 查询，TCP/IP 请求构建，五层因特网协议栈等。\n一、DNS 查询得到 IP 如果输入的是域名，需要进行 DNS 解析成 IP，大致流程：\n如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host； 如果本地没有，就向 DNS 域名服务器查询（中间可能还会经过路由，也有缓存等），查询到对应的 IP。 注意：域名查询时有可能是经过了 CDN 调度器的（如果有 CDN 存储功能的话）；DNS 解析是很耗时的，如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化。\n二、TCP/IP 请求 HTTP 的本质就是 TCP/IP 请求，TCP 将 HTTP 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。\n1. 三次握手的步骤 客户端：hello，你是 server 么？ 服务端：hello，我是 server，你是 client 么？ 客户端：yes，我是 client。 建立连接成功后，接下来就正式传输数据；待到断开连接时，需要进行四次挥手。\n2. 四次挥手的步骤 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了； 被动方：收到通道关闭的信息； 被动方：那我也告诉你，我这边向你的主动通道也关闭了； 主动方：最后收到数据，之后双方无法通信。 3. TCP/IP 的并发限制 浏览器对同一域名下并发的 TCP 连接是有限制的（2-10 个不等）；在 HTTP 1.0 中往往一个资源下载就需要对应一个 TCP/IP 请求，所以针对这个瓶颈，又出现了很多的资源优化方案。\n4. GET 和 POST 的区别 GET 和 POST 虽然本质都是 TCP/IP，但两者除了在 HTTP 层面外，在 TCP/IP 层面也有区别；GET 会产生一个 TCP 数据包，POST 两个，具体就是：\nGET 请求时，浏览器会把 Headers 和 Data 一起发送出去，服务器响应 200（返回数据）; POST 请求时，浏览器先发送 Headers，服务器响应 100，浏览器再发送 data，服务器响应 200（返回数据）。 5. 五层因特网协议栈 从应用层的发送 HTTP 请求，到传输层通过三次握手建立 TCP/IP 连接，再到网络层的 IP 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。\n五层因特网协议栈其实就是：\n应用层（DNS、HTTP）DNS 解析成 IP 并发送 HTTP 请求； 传输层（TCP、UDP）建立 TCP 连接（三次握手）； 网络层（IP、ARP）IP 寻址； 数据链路层（PPP）封装成帧； 物理层（利用物理介质传输比特流）物理传输（然后传输的时候通过双绞线，电磁波等各种介质）。 当然，其实也有一个完整的 OSI 七层框架，与之相比，多了会话层、表示层。\nOSI 七层框架：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层：\n表示层：主要处理两个通信系统中交换信息的表示方式，包括数据格式交换、数据加密与解密、数据压缩与终端类型转换等； 会话层：它具体管理不同用户和进程之间的对话，如控制登陆和注销过程。 从服务器接收到请求到对应后台接收到请求 服务端在接收到请求时，内部会进行很多的处理。\n一、负载均衡 对于大型的项目，由于并发访问量很大，所以往往一台服务器是吃不消的，所以一般会有若干台服务器组成一个集群，然后配合反向代理实现负载均衡，当然了，负载均衡不止这一种实现方式，这里不深入。\n用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户。\n二、后台处理 一般后台都是部署到容器中的，所以一般为：\n先是容器接受到请求（如 Tomcat）； 对应容器中的后台程序接收到请求（如 Java）； 后台会有自己的统一处理，处理完后响应结果。 概括下：\n一般，后端是有统一的验证的，如安全拦截、跨域验证； 如果这一步不符合规则，就直接返回了相应的 HTTP 报文（如拒绝请求等）； 当验证通过后，才会进入实际的后台代码，此时是程序接收到请求，然后执行（如查询数据库、大量计算等等）； 程序执行完毕后，就会返回一个 HTTP 响应包（一般这一步也会经过多层封装）； 将这个包从后端发送到前端，完成交互。 后台和前台的 HTTP 交互 前后端交互时，HTTP 报文作为信息的载体，所以 HTTP 是一块很重要的内容。\n一、HTTP 报文结构 报文一般包括了：通用头部、请求/响应头部、请求/响应体。\n1. 通用头部 Request URL：请求的 Web 服务器地址； Request Method：GET、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE； Status Code：请求的返回状态码； Remote Address：请求的远程服务器地址（会转为 IP）。 譬如，在跨域拒绝时，可能是 Method 为 OPTIONS，状态码为 404/405 等。\nHTTP/1.0 定义了三种请求方法：GET、POST 和 HEAD 方法； HTTP/1.1 定义了八种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT 方法。 不同范围状态的意义：\n1xx——指示信息，表示请求已接收，继续处理； 2xx——成功，表示请求已被成功接收、理解、接受； 3xx——重定向，要完成请求必须进行更进一步的操作； 4xx——客户端错误，请求有语法错误或请求无法实现； 5xx——服务器端错误，服务器未能实现合法的请求。 2. 请求/响应头部 常用的请求头部：\nAccept：接收类型，表示浏览器支持的 MIME 类型（对标服务端返回的 Content-Type）； Accept-Encoding：浏览器支持的压缩类型，如 gzip 等； Cache-Control：指定请求和响应遵循的缓存机制，如 no-cache 等； If-Modified-Since：对应服务端的 Last-Modified，用来匹配看文件是否变动； Expires：缓存控制，在这个时间内不会请求，直接使用缓存； Max-Age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存； If-None-Match：对应服务端的 ETag，用来匹配文件内容是否改变（非常精确）； Cookie：同域访问时会自动带上； Connection：当浏览器与服务器通信时对长连接如何进行处理，如 keep-alive； Host：请求的服务器 URL； Origin：最初的请求是从哪里发起的（只会精确到端口），Origin 比 Referer 更尊重隐私； Referer：该页面的来源 URL（适用于所有类型的请求，会精确到详细页面地址，CSRF 拦截常用到这个字段）； User-Agent：用户客户端的一些必要信息。 常用的响应头部：\nAccess-Control-Allow-Headers：服务器端允许的请求 Headers； Access-Control-Allow-Methods：服务器端允许的请求方法； Access-Control-Allow-Origin：服务器端允许的请求 Origin； Content-Type：服务端返回的实体内容的类型； Date：数据从服务器发送的时间； Last-Modified：请求资源的最后修改时间； Expires：应该在什么时候认为文档已经过期，从而不再缓存它； Max-Age：客户端的本地资源应该缓存多少秒，开启了 Cache-Control 后有效； ETag：请求变量的实体标签的当前值； Set-Cookie：设置和页面关联的 Cookie，服务器通过这个头部把 Cookie 传给客户端； Keep-Alive：如果客户端有 keep-alive，服务端也会有响应； Server：服务器的一些相关信息。 一般来说，请求头部和响应头部是匹配分析的；譬如，请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错。\n3. 请求/响应实体 HTTP 请求时，除了头部，还有消息实体，一般来说，请求实体中会将一些需要的参数都放入；譬如实体中可以放参数的序列化形式（a=1\u0026amp;b=2），或者直接放表单对象（FormData 对象，上传时可以夹杂参数以及文件）；而一般响应实体中，就是放服务端需要传给客户端的内容。\n二、Cookie 以及优化 Cookie 是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的 session 使用：\n在登录页面，用户登录了； 此时，服务端会生成一个 session，session 中有对应用户的信息（如用户名、密码等）； 然后会有一个 sessionId（相当于是服务端的这个 session 对应的 key）； 然后服务端在登录页面中写入 Cookie，值就是 :sessionid=xxx； 然后浏览器本地就有这个 Cookie 了，以后访问同域名下的页面时，自动带上 Cookie，在有效时间内无需二次登陆。 上述就是 Cookie 的常用场景简述（当然了，实际情况下得考虑更多因素）。\n一般来说，Cookie 是不允许存放敏感信息的（千万不要明文存储用户名、密码），因为非常不安全；如果一定要强行存储，首先，一定要在 Cookie 中设置 HTTPOnly（这样就无法通过 JS 操作了），另外可以考虑 RSA 等非对称加密（因为浏览器本地也是容易被攻克的，并不安全）。\n另外，由于在同域名的资源请求时，浏览器会默认带上本地的 Cookie，针对这种情况，在某些场景下是需要优化的：\n客户端在域名 A 下有 Cookie； 然后在域名 A 下有一个页面，页面中有很多依赖的静态资源（都是域名 A 的，譬如有 20 个静态资源）; 此时就有一个问题，页面加载，请求这些静态资源时，浏览器会默认带上 Cookie; 也就是说，这 20 个静态资源的 HTTP 请求，每一个都得带上 Cookie，而实际上静态资源并不需要 Cookie 验证。 此时就造成了较为严重的浪费，而且也降低了访问速度；当然了，针对这种场景，是有优化方案的（多域名拆分）。具体做法就是：\n将静态资源分组，分别放到不同的域名下（如 static.base.com）； 而 page.base.com（页面所在域名）下请求时，是不会带上 static.base.com 域名的 Cookie 的（前提是 Cookie 没有被写入到 base.com 下），避免了浪费。 说到了多域名拆分，这里再提一个问题，那就是：\n在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的）； 此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析 DNS 域名，勿滥用）。 三、gzip 压缩 首先，明确 gzip 是一种压缩格式，需要浏览器支持才有效，而且 gzip 压缩效率很好（高达 70% 左右）；gzip 一般是由 Apache、Tomcat 等服务器开启。\n除了 gzip 外，也还会有其它压缩格式（如 deflate，没有 gzip 高效，且不流行），所以一般只需要在服务器上开启了 gzip 压缩，之后的请求就都是基于 gzip 压缩格式的，非常方便。\ngzip 有（0~9）10 个压缩机别，压缩级别越高，压缩效果越好，也越占 CPU；考虑都性能和压缩率的取舍，压缩级别不易设的太高。\n四、长连接与短连接 TCP/IP 层面的定义：\n长连接：一个 TCP/IP 连接上可以连续发送多个数据包；在 TCP 连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）； 短连接：通信双方有数据交互时，就建立一个 TCP 连接，数据发送完成后，则断开此 TCP 连接。 HTTP 层面的定义：\nHTTP/1.0 中，默认使用的是短连接；浏览器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接；譬如每一个静态资源请求时都是一个单独的连接； HTTP/1.1 起，默认使用长连接，使用长连接会有这一行 Connection: keep-alive；在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 HTTP 的 TCP 连接不会关闭；如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接。 注意：keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 Apache）；另外长连接需要客户端和服务器都支持时才有效。\n五、HTTP/2 HTTP/2 与 HTTP/1.x 的显著不同点：\nHTTP/1.x 中，每请求一个资源，都是需要开启一个 TCP/IP 连接的；所以对应的结果是，每一个资源对应一个 TCP/IP 请求，由于 TCP/IP 本身有并发数限制，所以当资源一多，速度就显著慢下来； HTTP/2 中，一个 TCP/IP 请求可以请求多个资源；也就是说，只要一次 TCP/IP 请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升。 所以，如果 HTTP/2 全面应用，很多 HTTP/1.x 中的优化方案就无需用到了（如打包成精灵图、静态资源多域名拆分等）。\n简述下 HTTP/2 的一些特性：\n多路复用（即一个 TCP/IP 连接可以请求多个资源）； 首部压缩（HTTP 头部压缩，减少体积）； 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）； 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）； 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求）。 六、HTTPS HTTPS 就是安全版本的 HTTP，譬如一些支付等操作基本都是基于 HTTPS 的，因为 HTTP 请求的安全系数太低了；简单来看，HTTPS 与 HTTP 的区别就是：在请求前，会建立 SSL 链接，确保接下来的通信都是加密的，无法被轻易截取分析。\nSSL/TLS 的握手流程：\n浏览器请求建立 SSL 链接，并向服务端发送一个随机数 ClientRandom 和客户端支持的加密方法，比如 RSA 加密，此时是明文传输；\n服务端从中选出一组加密算法与 Hash 算法，回复一个随机数 ServerRandom，并将自己的身份信息以证书的形式发回给浏览器（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）；\n浏览器收到服务端的证书后：\n验证证书的合法性（颁发机构是否合法，证书中包含的网址是否和正在访问的一样），如果证书信任，则浏览器会显示一个小锁头，否则会有提示； 接收证书后（不管信不信任），浏览器会生产新的随机数 PremasterSecret，然后证书中的公钥以及指定的加密方法加密 PremasterSecret，发送给服务器； 利用 ClientRandom、ServerRandom 和 PremasterSecret 通过一定的算法生成 HTTP 链接数据传输的对称加密 key； 使用约定好的 Hash 算法计算握手消息，并使用生成的 key 对消息进行加密，最后将之前生成的所有信息发送给服务端。 服务端收到浏览器的回复：\n利用已知的加解密方式与自己的私钥进行解密，获取 PremasterSecret； 和浏览器相同规则生成 key； 使用 key 解密浏览器发来的握手消息，并验证 Hash 是否与浏览器发来的一致； 使用 key 加密一段握手消息，发送给浏览器。 浏览器解密并计算握手消息的 Hash，如果与服务端发来的 Hash 一致，此时握手过程结束。\n之后所有的 HTTPS 通信数据将由之前浏览器生成的 key 并利用对称加密算法进行加密。\nHTTP 缓存 前后端的 HTTP 交互中，使用缓存能很大程度上的提升效率：\n强缓存（200）时，浏览器如果判断本地缓存未过期，就直接使用，无需发起 HTTP 请求； 协商缓存（304）时，浏览器会向服务端发起 HTTP 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存。 对于协商缓存，强制刷新可以使得缓存无效；对于强缓存，在未过期时，必须更新资源路径才能发起新的请求。各大缓存头部的整体关系如下图：\n解析页面流程 浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：\n解析 HTML，构建 DOM 树； 解析 CSS，生成 CSS 规则树； 合并 DOM 树和 CSS 规则树，生成 render 树； 布局 render 树（layout/reflow），负责各元素尺寸、位置的计算； 绘制 render 树（paint），绘制页面像素信息； 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。 一、解析 HTML，构建 DOM 树 这个过程可以简述如下：bytes → characters → tokens → nodes → DOM；列举一些重点过程：\nConversion 转换：浏览器将获得的 HTML 内容（bytes）基于他的编码转换为单个字符； Tokenizing 分词：浏览器按照 HTML 规范标准将这些字符转换为不同的标记 token；每个 token 都有自己独特的含义以及规则集； Lexing 词法分析：分词的结果是得到一堆的 token，此时把他们转换为对象，这些对象分别定义他们的属性和规则； DOM 构建：因为 HTML 标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样。 二、生成 CSS 规则 CSS 规则树的生成也是类似；简述为：bytes → characters → tokens → nodes → CSSOM。\n三、构建渲染树 当 DOM 树和 CSSOM 都有了后，就要开始构建渲染树了；一般来说，渲染树和 DOM 树相对应的，但不是严格意义上的一一对应；有一些不可见的 DOM 元素不会插入到渲染树中，如 head 这种不可见的标签或者 display:none 等。\n注意：DOM 解析和 CSS 解析是两个并行的进程，所以 CSS 加载不会阻塞 DOM 树的解析；RenderTree 是依赖于 DOMTree 和 CSSOMTree 的，所以无论 DOMTree 是否已经完成，它都必须等待到 CSSOMTree 构建完成，即 CSS 加载完成（或 CSS 加载失败）后，才能开始渲染。\n四、渲染 有了渲染树，接下来就是开始渲染，基本流程如下：\n图中的线与箭头代表通过 JS 动态修改了 DOM 或 CSS，导致了 Reflow 或 Repaint：\nReflow（Layout），即回流；一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树； Repaint（Paint），即重绘；意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如：背景色、边框颜色、文字颜色等），此时只需要应用新样式绘制这个元素就可以了。 回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流，所以优化方案中一般都包括“尽量避免回流”。\n什么会引起回流：\n页面渲染初始化； DOM 结构改变，比如删除某节点； 渲染树变化，比如减少了 padding; 窗口 resize； 改变字体大小会引发回流； 获取某些属性会引发回流： offset(Top/Left/Width/Height)； scroll(Top/Left/Width/Height)； cilent(Top/Left/Width/Height)； width、height； IE\u0026rsquo;s currentStyle； getBoundingClientRect()； getComputedStyle()。 回流一定伴随着重绘，重绘却可以单独出现。 回流优化方案：\n减少逐项更改样式，最好一次性更改，或者将样式定义为 class 并一次性更新； 避免循环操作 DOM，创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 document； 避免多次读取 offset 等属性；无法避免则将它们缓存到变量； 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高； 使用 transform 替代 position； 使用 visibility:hidden 替换 display:none，因为前者只会引起重绘，后者会引发回流； 避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局； 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点；例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层； 使用硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘。 示例：\n1 2 3 4 5 6 7 var s = document.body.style; s.padding = \u0026#39;2px\u0026#39;; // 回流 + 重绘 s.border = \u0026#39;1px solid red\u0026#39;; // 回流 + 重绘 s.color = \u0026#39;blue\u0026#39;; // 重绘 s.backgroundColor = \u0026#39;#ccc\u0026#39;; // 重绘 s.fontSize = \u0026#39;14px\u0026#39;; // 回流 + 重绘 document.body.appendChild(document.createTextNode(\u0026#39;abc\u0026#39;)); // 添加 node，回流 + 重绘 五、简单层与复合层 上述中的渲染中止步于绘制，但实际上绘制这一步也没有这么简单，它可以结合复合层和简单层的概念来讲：\n可以认为默认只有一个复合图层，所有的 DOM 节点都是在这个复合图层下的； 如果开启了硬件加速功能，可以将某个节点变成复合图层； 复合图层之间的绘制互不干扰，由 GPU 直接控制； 简单图层中，就算是 position:absolute 等布局，变化时不影响整体的回流；但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低；而复合层是独立的，所以一般做动画推荐使用硬件加速。 更多参考： 普通图层和复合图层 六、资源外链的下载 实际上，在解析 HTML 时，会遇到一些资源连接，此时就需要进行单独处理了；简单起见，这里将遇到的静态资源分为一下几大类（未列举所有）：\nCSS 样式资源； JS 脚本资源； 图片类资源。 1. 遇到外链时的处理 当遇到上述的外链时，会单独开启一个下载线程去下载资源（HTTP/1.x 中，每一个资源的下载都要开启一个请求，对应一个 TCP/IP 链接）。\n2. 遇到 CSS 样式资源 CSS 的加载不会阻塞 DOM 树的构建； CSS 的加载会阻塞 DOM 树的渲染； mediaQuery 声明的 CSS 不会阻塞渲染。 3. 遇到 JS 脚本资源 阻塞浏览器的解析；发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析 HTML； 现代浏览器在脚本阻塞时，会继续下载其它资源（当然有并发上限），虽然脚本可以并行下载，解析过程仍然是阻塞的； 加上 async 或 defer，脚本就变成异步了，可以等到解析完毕后再执行； async 是异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在 load 前，但不确定在 DOMContentLoaded 的前或后； defer 是延迟执行，效果像是将脚本放在了 body 后面一样。 4. 遇到图片类资源 异步下载，不会阻塞解析，下载完毕后直接用图片替换原有 src 的地方。\n七、load 和 DOMContentLoaded load 事件触发时，页面上所有的 DOM、样式表、脚本、图片都已经加载完成了； DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表、图片。 CSS 可视化格式模型 CSS 可视化格式模型就是规定了浏览器在页面中如何处理文档树：\n每一个元素都有自己的盒子模型； 可视化格式模型则是把这些盒子按照规则摆放到页面上，也就是如何布局； 盒子模型规定了怎么在页面里摆放盒子，盒子的相互作用等等。 关键字：包含块（Containing Block）、控制框（Controlling Box）、BFC（Block Formatting Context）、IFC（Inline Formatting Context）、定位体系、浮动\u0026hellip;\n一、包含块（Containing Block） 一个元素的 Box 的定位和尺寸，会与某一矩形框有关，这个框就称之为包含块。元素会为它的子孙元素创建包含块，但是并不是说元素的包含块就是它的父元素，元素的包含块与它的祖先元素的样式等有关系：\n根元素是最顶端的元素，它没有父节点，它的包含块就是初始包含块； position:static/relative 的包含块由它最近的块级、单元格或者行内块祖先元素的内容框（Content）创建； position:fixed 的包含块是当前可视窗口； position:absolute 的包含块由它最近的 position:absolute/relative/fixed 的祖先元素创建： 如果祖先元素不是行内元素，那么包含块的区域应该是祖先元素的内边距边界； 如果祖先元素是行内元素，则包含块取决于其祖先元素的 direction 特性。 二、控制框（Controlling Box） 块级元素和块框以及行内元素和行框的相关概念。\n1. 块框 块级元素会生成一个块框（Block Box），块框会占据一整行，用来包含子 Box 和生成的内容； 块框同时也是一个块包含框（Containing Box），里面要么只包含块框，要么只包含行内框（不能混杂），如果块框内部有块级元素也有行内元素，那么行内元素会被匿名块框包围； 如果一个块框在其中包含另外一个块框，那么我们强迫它只能包含块框，因此其它文本内容生成出来的都是匿名块框。 2. 行内框 一个行内元素生成一个行内框； 行内元素能排在一行，允许左右有其它元素。 3. display 属性的影响 block，元素生成一个块框； inline，元素产生一个或多个的行内框； inline-block，元素产生一个行内级块框，行内块框的内部会被当作块框来格式化，而此元素本身会被当作行内级框来格式化（这也是为什么会产生 BFC）； none，不生成框，另一个 visibility:hidden 则会产生一个不可见的框。 三、BFC（Block Formatting Context） FC 即格式上下文，它定义框内部的元素渲染规则，比较抽象，譬如：\n格式上下文像是一个大箱子，里面装有很多元素； 箱子可以隔开里面的元素和外面的元素（所以外部并不会影响 FC 内部的渲染）； 内部的规则可以是：如何定位、宽高计算等等； 不同类型的框参与的 FC 类型不同，譬如块级框对应 BFC，行内框对应 IFC。 在块格式化上下文中，每一个元素左外边与包含块的左边相接触（对于从右到左的格式化，右外边接触右边）；即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合），除非这个元素也创建了一个新的 BFC。\nBFC 特点：\n内部 Box 在垂直方向，一个接一个的放置； 属于同一个 BFC 的两个 Box 间的 margin 会重叠； BFC 区域不会与 FloatBox 重叠； BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此； 计算 BFC 的高度时，浮动元素也参与计算（不会浮动坍塌）。 如何触发 BFC？\n根元素； float 属性不为 none； position:absolute/fixed； display:inline-block/flex/inline-flex/table/table-cell/table-caption； overflow:hidden。 注意：display:table 本身不产生 BFC，但是它会产生匿名框（包含 display:table-cell 的框），而这个匿名框产生 BFC。\nJS 引擎解析过程 前面有提到遇到 JS 脚本时，会等到它的执行，实际上是需要引擎解析的，这里展开描述。\n一、JS 解释阶段 JS 是解释型语音，所以它无需提前编译，而是由解释器实时运行，引擎对 JS 的处理过程可以简述如下：\n读取代码，进行词法分析（Lexical Analysis），然后将代码分解成词元（token）； 对词元进行语法分析（Parsing），然后将代码整理成语法树（Syntax Tree）； 使用翻译器（Translator），将代码转为字节码（Bytecode）； 使用字节码解释器（Bytecode Interpreter），将字节码转为机器码； 最终计算机执行的就是机器码。 现代浏览器一般采用即时编译（JIT-Just In Time Compiler），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存。\n二、JS 预处理阶段 在正式执行 JS 前，还会有一个预处理阶段（譬如变量提升、分号补全等），确保 JS 可以正确执行，这里仅提部分：\n1. 分号补全 JS 执行是需要分号的，但为什么以下语句却可以正常运行呢？\n1 2 console.log(\u0026#39;a\u0026#39;); console.log(\u0026#39;b\u0026#39;); 原因就是 JS 解释器有一个 Semicolon Insertion 规则，它会按照一定规则，在适当的位置补充分号。\n2. 变量提升 一般包括函数提升和变量提升，譬如：\n1 2 3 4 5 6 a = 1; b(); function b() { console.log(\u0026#39;b\u0026#39;); } var a; 经过变量提升后，就变成：\n1 2 3 4 5 6 function b() { console.log(\u0026#39;b\u0026#39;); } var a; a = 1; b(); 三、JS 执行阶段 此段内容中的图片来源： 深入理解 JavaScript 系列（10）：JavaScript 核心 解释器解释完语法规则后，就开始执行，整个执行流程中大致包含：\n执行上下文，执行堆栈概念（如全局上下文、当前活动上下文）； VO（变量对象）和 AO（活动对象）； 作用域链； this。 1. 执行上下文简单解释 浏览器首次载入脚本，它将创建全局执行上下文，并压入执行栈栈顶（不可被弹出）； 每进入其它作用域就创建对应的执行上下文并把它压入执行栈的顶部； 一旦对应的上下文执行完毕，就从栈顶弹出，并将上下文控制权交给当前的栈； 这样依次执行（最终都会回到全局执行上下文）。 如果程序执行完毕，被弹出执行栈，然后又没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收。\n每一个执行上下文，都有三个重要属性：\n变量对象（Variable Object）； 作用域链（Scope Chain）； this。 2. 变量对象与活动对象 只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问（因为在全局上下文里，全局对象自身就是变量对象）；AO（Activation Object），当函数被调用者激活，AO 就被创建了。\n在函数上下文中：VO === AO； 在全局上下文中：VO === this === global。 3. 作用域链 它是执行上下文中的一个属性，原理和原型链很相似，作用很重要，譬如流程简述：在函数上下文中，查找一个变量 foo；如果在函数的 VO 中找到了，就直接使用；否则去它的父级作用域链中找；如果父级中没找到，继续往上找；直到全局上下文中也没找到就报错。\n4. this 指针 this 是执行上下文环境的一个属性，而不是某个变量对象的属性：\nthis 是没有一个类似搜寻变量的过程； 当代码中使用了 this，this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻； this 的值只取决中进入上下文时的情况。 四、回收机制（Garbage Collecation） JS 有垃圾处理器，所以无需手动回收内存；而是由垃圾处理器自动处理，常用的两种垃圾回收规则是：\n标记清除； 引用计数。 JS 引擎基础 GC 方案是 Mark and Sweep（标记清除），简单解释如下：\n遍历所有可访问的对象； 回收已不可访问的对象。 1. GC 的缺陷： 和其他语言一样，JS 的 GC 策略也无法避免一个问题：垃圾回收时，停止响应其他操作；这是为了安全考虑。而 JS 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是引擎需要优化的点：避免 GC 造成的长时间停止响应。\n2. GC 的优化策略：分代回收（Generation GC） 目的是通过区分“临时”与“持久”对象：\n多回收“临时对象”区（Young Generation）； 少回收“持久对象”区（Tenured Generation）； 减少每次需遍历的对象，从而减少每次 GC 的耗时。 更多参考： V8 内存浅析 跨域 譬如发出网络请求时，会用 ajax，如果接口跨域，就会遇到跨域问题，可以参考：\najax 跨域，这应该是最全的解决方案了 安全 譬如浏览器在解析 HTML 时，有 XSSAuditor，可以延伸到安全相关领域，可以参考：\najax 请求真的不安全么？谈谈 Web 安全与 ajax 的关系 参考 从输入 URL 到页面加载的过程？如何由一道题完善自己的前端知识体系 ","date":"2019-07-26T00:00:00Z","image":"https://vikingama.github.io/img/cover/browser.png","permalink":"https://vikingama.github.io/p/%E8%BD%AC%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B/","title":"「转」从输入 URL 到页面加载的过程"},{"content":"什么是递归 小时候，我们都听过下面这则故事：\n从前有座山，山里有个庙，庙里有个老和尚在给小和尚讲故事，讲的什么呢？「从前有座山，山里有个庙，庙里有个老和尚在给小和尚讲故事，讲的什么呢？『从前有座山，山里有个庙，庙里有个老和尚在给小和尚讲故事，讲的什么呢？\u0026hellip;』」\n这个故事自己套着自己，没完没了，像是某种特征在不断地重复，这就是递归了。\n在计算机科学里，递归指的是一种通过重复将问题分解为同类的子问题而解决问题的方法。套用程序的概念，就是函数执行过程中直接或间接地调用自身。\n用递归来解决问题 由递归的概念可知，如果某个问题有一些自相似的特征，可以分解为子问题，那么它就可以被递归定义。如果问题被递归定义了，也差不多解决了。\n我们来看一个具体例子：\n假设现在有 5 个人、5 个座位，那这几个人的位置分布情况有几种。我们先来列举一下：\n1 2 3 4 5 第 1 个人：有 5 种选择 第 2 个人：有 (5 - 1) 种选择 第 3 个人：有 (5 - 2) 种选择 第 4 个人：有 (5 - 3) 种选择 第 5 个人：有 (5 - 4) 种选择 那么 5 个人总共的选择数是：\n1 5 * (5 - 1) * (5 - 2) * (5 - 3) * (5 - 4); 同理，如果总共是 n 个人、n 个座位，那么所有可能的情况数 f(n) 可以表示为：\n1 f(n) = n * (n - 1) * … * 2 * 1 这里的未知数 n 有无数种可能，我们不可能把所有的情况都列举出来，然后得到结果。要解决这样的问题，就要运用递归的思想，找到各个情况的共同模式，切分成小的有限的问题，然后尝试着把它描述出来。\n我们先把 n \u0026lt;= 5 的情况列举出来：\n1 2 3 4 5 f(1) = 1; f(2) = 2 * 1; f(3) = 3 * 2 * 1; f(4) = 4 * 3 * 2 * 1; f(5) = 5 * 4 * 3 * 2 * 1; 通过对比可以观察到一个现象：\n1 2 3 4 5 f(1) = 1; f(2) = 2 * f(1); f(3) = 3 * f(2); f(4) = 4 * f(3); f(5) = 5 * f(4); 我们找到了一个共同模式，描述出来就是，对于 f(n) 来说，它的值是参数 n 和前一步的值的乘积，前一步和后一步的参数之间相差 1，所以我们很自然就想到用这个 1 做切分，即：\n1 f(n) = n * f(n - 1); 这样我们就定义了这个函数 f，它会在执行的过程中调用自己，又称为递归函数，用 JavaScript 实现就是这样：\n1 2 3 var f = function (n) { return n * f(n - 1); }; 简单分析一下，这个函数每执行一次，参数 n 就少 1，最终它会到达 0，之后还会进一步到负数，看起来好像永远都得不到结果。\n我们回到命题，当 n 到达 0 时，f(0) 指的就是「在 0 个人、0 个座位时的位置分布情况」，没有意义，是 Empty Product，值为 1。而 n 是负数时就更没有意义了，所以 n 应该是一个自然数：\n1 2 f(0) = 1; f(n) = n * f(n - 1); 这里的 n = 0 就是递归函数 f 的一个临界条件，当达到临界条件时，递归函数继续执行没有意义，此时递归结束。在定义递归函数的时候，设定合适的临界条件很重要，否则容易陷入死循环。\n相应的，我们的代码也要改变：\n1 2 3 4 var f = function (n) { if (n === 0) return 1; return n * f(n - 1); }; 由此，我们就通过定义递归函数 f 描述了这个问题，对于任意的自然数 n，我们只需执行 f(n) 就可以得到答案。\n用递归的思路来解决问题，并不是写出具体的求解步骤，而是试着把问题描述出来，考虑有哪些共同模式，怎么切分，何处结束，以及何处执行递归。\n递归函数的优化 当 n = 5 时，我们把上面这个函数完整的执行过程模拟出来：\n1 2 3 4 5 6 7 8 9 10 11 12 f(5); 5 * f(4); 5 * (4 * f(3)); 5 * (4 * (3 * f(2))); 5 * (4 * (3 * (2 * f(1)))); 5 * (4 * (3 * (2 * (1 * f(0))))); 5 * (4 * (3 * (2 * (1 * 1)))); 5 * (4 * (3 * (2 * 1))); 5 * (4 * (3 * 2)); 5 * (4 * 6); 5 * 24; 120; 我们可以看到，随着 f(5) 这个函数的执行，需要记录的中间状态的数目一直在变，先增后减。在空间消耗上，表现就是栈先累积后收缩，整个计算过程空间复杂度是 O(n)，当 n 很大的时候会 Stack Overflow 。\n我们思考一下另一种方案，刚才的执行是从 n 开始，一步步计算，直到临界条件 0 为止。现在试着倒过来，由 1 开始，一步步计算，直到 n 为止，当然，此时的临界条件也相应的变为「超过 n」。\n实现起来应该就是这样：\n1 2 3 4 5 6 7 8 9 10 var f = function (n) { return f2(n, 1, 1); }; var f2 = function (n, i, result) { if (i \u0026gt; n) { return result; } else { return f2(n, i + 1, result * i); } }; 我们引入了另一个函数 f2 来完成从 1 到 n 的递归。函数 f2 在尾位置（函数执行的最后）调用自身，这样的递归称为尾递归。\n不少编程语言（包括 ES6）都支持对这样的函数进行空间优化，也叫尾递归优化。\n具体是怎么进行尾递归优化的呢？\n我们回顾一下函数 f2 的定义，因为函数 f2 每次执行的最后是函数调用，而下一步执行所需要的状态都是通过参数传递的，那么当前栈就可以清空被重用。比如，在计算第 3 步的时候，之前的第 1 步、第 2 步的中间状态都不需要了，只保留第 3 步执行需要的参数就行。\n我们把优化后的步骤列出来：\n1 2 3 4 5 6 7 8 f(5); f2(5, 1, 1); f2(5, 2, 1); f2(5, 3, 2); f2(5, 4, 6); f2(5, 5, 24); f2(5, 6, 120); 120; 可以看出，这种方案随着计算的增加，消耗的空间一直不变，占用恒量的内存，和迭代程序一样，它的空间复杂度是 O(1)。\n所以经过尾递归优化后，使得递归计算可以跟 while、for 等迭代式计算的效率基本相当。\n参考 谈谈递归 ","date":"2019-06-14T00:00:00Z","image":"https://vikingama.github.io/img/cover/javascript.png","permalink":"https://vikingama.github.io/p/%E8%BD%AC%E8%B0%88%E8%B0%88%E9%80%92%E5%BD%92/","title":"「转」谈谈递归"},{"content":"Singleton 是什么 单例模式是指：一个类仅有一个实例，并且有一个访问点可以访问到这个类；为了实现单例模式，需要在类第一次被调用的时候，将实例保存下来；在这个类被第 n 次调用时，将第一次的实例返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let createSingleton = (() =\u0026gt; { let singleton; return function () { if (!singleton) { // 将创建的对象保存在闭包里 singleton = Object.create(null); } return singleton; }; })(); // 每次调用都指向闭包里的变量 singleton let a = createSingleton(); let b = createSingleton(); console.log(a === b); // true 单例模式的应用：命名空间 最简单的单例模式就是以字面量这种形式创建的对象，这种最简单的单例模式可以防止全局变量被污染。\n1 2 3 4 5 6 7 // 命名空间可以将同命方法隔离开来，避免被不小心篡改 const lxh = { speak() {} }; const zpp = { speak() {} }; 单例模式的应用：管理模块 1 2 3 4 5 6 7 // f1 ,f2, f3 由命名空间 example 管理 const example = (function () { let f1 = function () {}; let f2 = function () {}; let f3 = function () {}; return { f1, f2, f3 }; })(); ES6 单例模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Apple { constructor(name, creator, products) { // 这个判断可以保证类实例化之后的对象均指向类的静态属性 instance if (!Apple.instance) { this.name = name; this.creator = creator; this.products = products; // 在调用 new 时，this 指向实例化的对象 Apple.instance = this; } // 每次调用 constructor，返回的都是第一次实例化返回的对象 return Apple.instance; } } let a1 = new Apple(\u0026#39;apple, inc\u0026#39;, \u0026#39;steve jobs\u0026#39;, \u0026#39;iPhone...\u0026#39;); let a2 = new Apple(\u0026#39;apple, inc\u0026#39;, \u0026#39;tim cook\u0026#39;, \u0026#39;MacBook...\u0026#39;); console.log(a1); // {name: \u0026#34;apple, inc\u0026#34;, creator: \u0026#34;steve jobs\u0026#34;, products: \u0026#34;iPhone...\u0026#34;} console.log(a2); // {name: \u0026#34;apple, inc\u0026#34;, creator: \u0026#34;steve jobs\u0026#34;, products: \u0026#34;iPhone...\u0026#34;} console.log(a1 === a2); // true 参考 从 ES6 重新认识 JavaScript 设计模式 (一)：单例模式 ","date":"2019-05-29T00:00:00Z","image":"https://vikingama.github.io/img/cover/patterns.png","permalink":"https://vikingama.github.io/p/%E5%AE%9E%E7%8E%B0-singleton/","title":"实现 Singleton"},{"content":"区别 attribute 指的是 HTML 的属性，property 指的是 DOM 对象（JS 对象）的属性； 非自定义的 attribute 特性与 property 有映射关系，比如：id，class 等； attribute 的值只能是字符串，property 的值可以是任意类型； 两者是可以相互影响的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;label for=\u0026#34;man\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;man\u0026#34; class=\u0026#34;div-ele\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;SEX\u0026#34; checked=\u0026#34;false\u0026#34; data-pf=\u0026#34;boy\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;Man\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;woman\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;woman\u0026#34; class=\u0026#34;div-ele\u0026#34; type=\u0026#34;radio\u0026#34; name=\u0026#34;SEX\u0026#34; data-pf=\u0026#34;girl\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;Woman\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; \u0026lt;script\u0026gt; console.log(document.querySelectorAll(\u0026#39;input\u0026#39;)); \u0026lt;/script\u0026gt; 总结 可以看到 attribute 只是 DOM 对象的 property 之一，保存着对应元素在 HTML 代码中的所有属性；其中 attribute 的值全部为字符串，而 property 的值可以为字符串、对象、数组、布尔值、null、undefined 等。\n为了操作 DOM 的简便，除了自定义属性，大部分 attribute 在 property 里都有对应的映射；修改其一等价于修改另一个。其中 for 和 class 为 JS 的保留字，所以 attribute 的 for/class 属性映射到了 property 的 htmlFor/className。\n因为 attribute 的属性值只能为字符串，所以当我们在 HTML 中加上‘checked=\u0026ldquo;false\u0026rdquo;’时，false 会被当作是长度为 5 的字符串，被隐式转换为 true，所以默认“man”被选中。因此 在设置“以非字符串为属性值”的属性时，应该在 JS 中设置 property。\n","date":"2019-05-25T00:00:00Z","image":"https://vikingama.github.io/img/cover/javascript.png","permalink":"https://vikingama.github.io/p/attribute-%E4%B8%8E-property/","title":"attribute 与 property"},{"content":"原生 DOM 操作 vs 通过框架封装操作 这是一个性能 vs 可维护性的取舍。\n框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。\n没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。\n针对任何一个 BenchMark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。\n框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。\n对 React 的 VirtualDOM 的误解 React 从来没有说过“React 比原生操作 DOM 快”。\nReact 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 VirtualDOM，简单来想就是直接重置 innerHTML。\n很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作。\n真正的问题是在“全部重新渲染”的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。\n我们可以比较一下 innerHTML 和 VirtualDOM 的重绘性能消耗：\ninnerHTML: render html string + O(template size) + 重新创建所有 DOM 元素 O(DOM size)； VirtualDOM: render VirtualDOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)。 VirtualDOM 的 render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 JS 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。\n可以看到，innerHTML 的总计算量不管是 JS 计算还是 DOM 操作都是和整个界面的大小相关，但 VirtualDOM 的计算量里面，只有 JS 计算和界面大小相关，DOM 操作是和数据的变动量相关的。\n前面说了，和 DOM 操作比起来，JS 计算是极其便宜的。这才是为什么要有 VirtualDOM：\n不管你的数据变化多少，每次重绘的性能都可以接受； 你依然可以用类似 innerHTML 的思路去写你的应用。 MVVM vs VirtualDOM 相比起 React，其他 MVVM 系框架比如 Angular、Knockout、Vue 以及 Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。\nMVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。\nMVVM 的性能也根据变动检测的实现原理有所不同：\nAngular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价； Knockout/Vue/Avalon 都采用了依赖收集，在 JS 和 DOM 层面都是 O(change)； 脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)； 依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)。 可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。\nMVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的\u0026quot;scope\u0026quot;对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel/scope 实例比起 VirtualDOM 来说要昂贵很多。\n这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。\n假如没有任何复用方面的优化，由于数据是“全新”的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 Angular/Knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。\nAngular 和 Vue 都提供了列表重绘的优化机制，也就是“提示”框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行“原地复用”：直接根据在数组里的位置进行复用。\n在题目给出的例子里，如果 Angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快，顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。\n参考 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ 壹题 ","date":"2019-05-23T00:00:00Z","image":"https://vikingama.github.io/img/cover/javascript.png","permalink":"https://vikingama.github.io/p/%E8%BD%ACvirtualdom-%E7%9C%9F%E7%9A%84%E6%AF%94%E6%93%8D%E4%BD%9C%E5%8E%9F%E7%94%9F-dom-%E5%BF%AB%E5%90%97/","title":"「转」VirtualDOM 真的比操作原生 DOM 快吗？"},{"content":"Array.prototype.sort() sort 方法不能实现随机排序的原因是：当对一个数组进行 n 次排序后，这 n 个数组的第 x 项的平均数并不是无限接近于原数组所有项的平均数。\n1 2 3 4 5 6 7 8 9 const arr = [1, 7, 0, 5, 6, 4, 2, 9, 3, 8]; // [1, 7, 0, 5, 6, 4, 2, 9, 3, 8] console.log(arr.slice().sort((a, b) =\u0026gt; 0)); // 保持不变 // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] console.log(arr.slice().sort((a, b) =\u0026gt; a - b)); // 升序 // [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] console.log(arr.concat().sort((a, b) =\u0026gt; b - a)); // 降序 // [3, 6, 5, 2, 9, 7, 1, 0, 4, 8] console.log(arr.concat().sort((a, b) =\u0026gt; 0.5 - Math.random())); // 伪随机 经典洗牌算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function randomList(initArr) { let length = initArr.length, tempArr = [], // 保存随机下标 resultArr = []; // 保存结果 while (length) { // 随机下标 [0, initArr.length] 的整数 let randomIndex = Math.floor(Math.random() * initArr.length); // 防止随机下标重复 if (!tempArr.includes(randomIndex)) { tempArr.push(randomIndex); resultArr[randomIndex] = initArr[length - 1]; length--; } } return resultArr; } let arr = [1, 7, 0, 5, 6, 4, 2, 9, 3, 8]; console.log(randomList(arr)); Fisher–Yates 1 2 3 4 5 6 7 8 9 function shuffleList(a) { for (let i = a.length; i; i--) { let j = Math.floor(Math.random() * i); [a[i - 1], a[j]] = [a[j], a[i - 1]]; } return a; } let arr = [1, 7, 0, 5, 6, 4, 2, 9, 3, 8]; console.log(shuffleList(arr)); 参考 JS 中随机排列数组顺序（经典洗牌算法）和数组的排序方法 ","date":"2019-05-22T00:00:00Z","image":"https://vikingama.github.io/img/cover/javascript.png","permalink":"https://vikingama.github.io/p/%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%88%97%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84/","title":"随机排列一个数组"},{"content":"浏览器 浏览器是多进程（CPU 资源分配的最小单位）的，新开一个 Tab 页其实就是创建了一个浏览器渲染进程（记得很早之前，FF 是多个 Tab 共用一个进程，导致一个页面的假死会使整个浏览器崩掉）；一个进程中包含了多个线程（CPU 资源调度的最小单位），比如渲染线程、JS 线程、HTTP 请求线程等。当你发起一个请求时，其实就是创建了一个请求线程，当请求结束后，该线程可能就会被销毁。一个浏览器渲染进程通常由以下常驻线程组成：\nGUI 渲染线程： 负责页面的渲染，解析 HTML 构建 DOM、解析 CSS 构建 CSSOM、构建 render 树，触发布局和绘制等； 与 JS 引擎线程互斥，当执行 JS 时，GUI 渲染会被挂起。 HTTP 请求线程： 负责执行异步请求的线程，执行代码时，遇到异步请求，会交给该线程处理； 当监听到状态码变更，事件触发线程会将异步回调加入到任务队列。 JS 引擎线程： 负责 JS 代码的解析和执行，每个 Tab 只有一个 JS 线程在运行； JS 代码的执行会阻塞页面的渲染； 空闲的时候，会轮询任务队列。 定时触发器线程： 负责执行异步定时器（setTimeout、setInterval）的线程； 当计时完毕后，回调会被加入到任务队列，等待被执行。 事件触发线程：负责任务队列的维护和事件循环的控制。 事件驱动 所谓的事件驱动，就是将一切抽象为事件。I/O 操作完成是一个事件，用户点击是一个事件，一个图片加载完成是一个事件；当这些事件发生时对应的代码逻辑就会进入任务队列，等待 JS 线程读取。\n事件驱动的实现过程主要靠“事件循环”完成；JS 线程不停的从任务队列里读取事件。如果事件有关联的处理函数，就执行函数。\nJS 线程运行时，产生堆 Heap 和栈 Stack，栈中的代码调用各种接口，在“任务队列”中加入各种事件；只要栈中的代码执行完毕，JS 线程就会去读取“任务队列”，依次执行那些事件所对应的回调函数。\n任务队列 JS 运行时包含了多个待处理任务的队列（宏任务队列 TaskQueue、微任务队列 JobsQueue 等）；每一个任务都关联着一个用以处理这个任务的函数。\n宏任务队列：ScriptCode、MessageChannel、setTimeout、setInterval、setImmediate、I/O、UIRender、requestAnimationFrame、requestIdleCallback 等； 微任务队列：Promise、MutationObserver、process.nextTick 等。 你可以将这些方法看作是任务分发装置，他们会将要执行的代码或回调函数分发给不同的任务队列。\n在事件循环期间的某个时刻，从最先进入队列的消息开始处理队列中的消息；这个消息会被移出队列，并作为输入参数调用与之关联的函数；函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会从任务队列中提取下一个任务（如果还有的话）。\n事件循环机制 为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止 JS 线程阻塞，JS 引入事件循环机制来管理协调这些事件，实现异步：\n从 ScriptCode 开始执行代码（宏任务）； 全局上下文进入调用栈； 执行微任务队列里所有的任务； 判断页面是否需要更新渲染（不一定存在于每轮事件循环，根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定）； 宏任务队列里取出一个宏任务执行； 一旦调用栈中的任务执行完毕，系统就会读取任务队列，将任务压入调用栈执行； JS 线程不断重复上面的步骤（执行一个宏任务-\u0026gt;执行微任务队列里的所有任务-\u0026gt;渲染工作-\u0026gt;执行下一个宏任务-\u0026gt;\u0026hellip;）。 注意 process.nextTick 队列中的任务会比 Promise 队列中的任务先入栈，Promise 队列中的任务会比 MutationObserver 队列中的任务先入栈（尽管他们都是微任务）； MessageChannel 队列中的任务会比 setInterval/setTimeout 队列中的任务先入栈（尽管他们都是宏任务）； setInterval/setTimeout 队列中的任务会比 setImmediate 队列中的任务先入栈（尽管他们都是宏任务）； 浏览器会尽可能的保持帧率稳定，如果页面性能无法维持 60fps，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧； 如果更新渲染不会带来视觉上的改变或者帧动画队列为空，浏览器会跳过当前帧的更新； 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。 参考 从浏览器多进程到 JS 单线程，JS 运行机制最全面的一次梳理 考古挖掘：高刷显示器下的 requestAnimationFrame Tasks, Microtasks, Queues and Schedules 浏览器与 Node 的事件循环有何区别？ JavaScript 中的事件循环 Event Loop 并发模型与事件循环 ","date":"2019-05-13T00:00:00Z","image":"https://vikingama.github.io/img/cover/javascript.png","permalink":"https://vikingama.github.io/p/js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","title":"JS 的事件循环机制"},{"content":"Alice 与 Bob 的通信 我们以 Alice 与 Bob 一次通信来贯穿全文，一开始他们都是用明文的形式在网络传输通信内容。\n嗅探以及篡改 如果在他们的通信链路出现了一个 Hacker，由于通信内容都是明文可见，所以 Hacker 可以嗅探看到这些内容；\n也可以篡改这些内容。\n公众号的文章之前就遇到很多被挟持篡改了内容，插入广告。\n加密解密 既然明文有问题，那就需要对明文进行加密处理，让中间人看不懂内容，于是乎要对原来的内容变成一段看不懂的内容，称为加密，反之则是解密。\n而本质其实就是一种数学运算的逆运算，类似加法减法，例如发送方可以将 abcd…xyz 每个字母 +1 映射成 bcd…yza，使得原文的字母变成看不懂的序列，而接收方只需要将每个字母 -1 就可以恢复成原来的序列，当然这种做法规律太容易被破解了。\n对称加密（AES、DES 等） 如果对 2 个二进制数 A 和 B 进行异或运算得到结果 C，那 C 和 B 再异或一次就会回到 A，所以异或也可以作为加密解密的运算。把操作数 A 作为明文，操作数 B 作为密钥，结果 C 作为密文。加密解密运用同一个密钥 B，把这种加解密都用同一个密钥的方式叫做对称加密。\nAlice 与 Bob 如果能提前拿到一个对称加密的密钥，他们就可以通过加密明文来保证他们说话内容不会被 Hacker 看到了。\n非对称加密（RSA、DSA 等） 刚刚还引发另一个问题，这个对称加密用到的密钥怎么互相告知呢？如果在传输真正的数据之前，先把密钥传过去，那 Hacker 还是能嗅探到，那之后就了无秘密了。于是乎出现另外一种手段：\n这就是非对称加密，任何人都可以通过拿到 Bob 公开的公钥对内容进行加密，然后只有 Bob 自己私有的钥匙才能解密还原出原来内容。\nRSA 就是这样一个算法，具体数学证明利用了大质数乘法难以分解、费马小定理等数学理论支撑它难以破解。相对于前边的对称加密来说，其需要做乘法模除等操作，性能效率比对称加密差很多。\n由于非对称加密的性能低，因此我们用它来先协商对称加密的密钥即可，后续真正通信的内容还是用对称加密的手段，提高整体的性能。\n认证 上边虽然解决了密钥配送的问题，但是中间人还是可以欺骗双方，只要在 Alice 像 Bob 要公钥的时候，Hacker 把自己公钥给了 Alice，而 Alice 是不知道这个事情的，以为一直都是 Bob 跟她在通信。\n一般我们现实生活是怎么证明 Bob 就是 Bob 呢？一般都是政府给我们每个人发一个身份证，我只要看到 Bob 身份证，就证明 Bob 就是 Bob。\n网络也可以这么做，如果有个大家都信任的组织 CA 给每个人出证明，那 Alice 只要拿到这个证明，检查一下是不是 CA 制作的 Bob 证书就可以证明 Bob 是 Bob。所以这个证书里边需要有两个重要的东西：Bob 的公钥 + CA 做的数字签名。\n前边说到用公钥进行加密，只有拥有私钥的人才能解密。数字证书有点反过来：用私钥进行加密，用公钥进行解密。CA 用自己的私钥对 Bob 的信息（包含 Bob 公钥）进行加密，由于 Alice 无条件信任 CA，所以已经提前知道 CA 的公钥，当她收到 Bob 证书的时候，只要用 CA 的公钥对 Bob 证书内容进行解密，发现能否成功解开（还需要校验完整性），此时说明 Bob 就是 Bob，那之后用证书里边的 Bob 公钥来走之前的流程，就解决了中间人欺骗这个问题了。\n这种方式也是一种防抵赖的方式，让对方把消息做一个数字签名，只要我收到消息，用对方的公钥成功解开校验这个签名，说明这个消息必然是对方发给我的，对方不可以抵赖这个行为，因为只有他才拥有做数字签名的私钥。\nCA 其实是有多级关系，顶层有个根 CA，只要他信任 B，B 信任 C，C 信任 D，那我们基本就可以认为 D 是可信的。\n完整性 上边基本上已经解决了保密性和认证，还有一个完整性没有保障。虽然 Hacker 还是看不懂内容，但是 Hacker 可以随便篡改通信内容的几个 bit 位，此时 Bob 解密看到的可能是很乱的内容，但是他也不知道这个究竟是 Alice 真实发的内容，还是被别人偷偷改了的内容。\n单向 Hash 函数可以把输入变成一个定长的输出串，其特点就是无法从这个输出还原回输入内容，并且不同的输入几乎不可能产生相同的输出，即便你要特意去找也非常难找到这样的输入，因此 Alice 只要将明文内容做一个 Hash 运算得到一个 Hash 值，并一起加密传递过去给 Bob。Hacker 即便篡改了内容，Bob 解密之后发现拿到的内容以及对应计算出来的 Hash 值与传递过来的不一致，说明这个包的完整性被破坏了。\n一次安全可靠的通信 对称加密以及非对称加密来解决：保密性； 数字签名：认证、不可抵赖； 单向 Hash 算法：完整性。 参考 一次安全可靠的通信——HTTPS 原理 ","date":"2019-05-02T00:00:00Z","image":"https://vikingama.github.io/img/cover/http.png","permalink":"https://vikingama.github.io/p/%E8%BD%AChttps-%E5%8E%9F%E7%90%86%E4%B8%80%E6%AC%A1%E5%AE%89%E5%85%A8%E5%8F%AF%E9%9D%A0%E7%9A%84%E9%80%9A%E4%BF%A1/","title":"「转」HTTPS 原理，一次安全可靠的通信"}]